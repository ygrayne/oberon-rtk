. <tool: Astrobe for RP2350>
. <prog: C:\Users\gray\Projects\oberon\dev\oberon-rtk\examples\v3.0\nxp\frdm-mcxa346\SignalSync\SignalSync.mod>

.     0  000001500              <Pad: 0>
MODULE Stacktrace;
(**
  Oberon RTK Framework
  Version: v3.0
  --
  Create stack trace amd read stack registers based on error data
  collected by run-time error handling RuntimeErrors.
  --
  MCU: MCX-A346
  --
  Copyright (c) 2020-2025 Gray, gray@grayraven.org
  Portions copyright (c) 2008-2024 CFB Software, https://www.astrobe.com
  Used with permission.
  Please refer to the licensing conditions as defined at the end of this file.
**)

  IMPORT SYSTEM, MCU := MCU2, Config, RuntimeErrors;

  CONST
    TraceDepth = 16;

    ExcRetMask = 0FFFFFFE3H;
    ExcRetVal = 0FFFFFFA0H;

    AnnNone* = 0;
    AnnStackframe* = -1;

    StackTraceNotLR = 0;
    StackTraceLineNo = 1;
    StackTraceNoLineNo = 2;

    (* stack context sizes *)
    StateContextSize = 8 * 4;
    (* unused
    ExtStateContextSize = 10 * 4;
    *)
    FPcontextSize = 18 * 4;

    (* register offsets from stacked r0 *)
    PSRoffset = 28;
    PCoffset = 24;
    LRoffset = 20;

    StackSeal = 0FEF5EDA5H;


    (* EXC_RETURN bits *)
    (*EXC_RET_S     = 6;*)  (* = 1: secure stack frame, faulty code was running in secure domain *)
    (*EXC_RET_DCRS  = 5;*)  (* = 0: all CPU regs stacked by hardware, extended state context *)
    EXC_RET_FType = 4;  (* = 0: all FPU regs stacked by hardware, extended FPU context *)
    (*EXC_RET_Mode  = 3; *) (* = 1: thread mode, faulty code was running in thread mode *)
    (*EXC_RET_SPSEL = 2; *) (* = 1: PSP used for stacking *)
    (*EXC_RET_ES    = 0;*)  (* = 1: exception running in secure domain *)

  TYPE
    TracePoint* = RECORD
      address*: INTEGER;
      lineNo*: INTEGER;
      stackAddr*: INTEGER;
      annotation*: INTEGER
    END;
.     4  000001504      01504      00010  <Type:   16>
.     8  000001508      01508      00000  <Type:   0>
.    12  00000150C      0150C      00000  <Type:   0>
.    16  000001510      01510      00000  <Type:   0>
.    20  000001514      01514      00000  <Type:   0>

    Trace* = RECORD
      tp*: ARRAY TraceDepth OF TracePoint;
      count*: INTEGER;
      more*: BOOLEAN
    END;
.    24  000001518      01518      00108  <Type:   264>
.    28  00000151C      0151C      00000  <Type:   0>
.    32  000001520      01520      00000  <Type:   0>
.    36  000001524      01524      00000  <Type:   0>
.    40  000001528      01528      00000  <Type:   0>

    StackedRegs* = RECORD
      r0*, r1*, r2*, r3*, r12*: INTEGER;
      lr*, pc*, xpsr*, sp*: INTEGER
    END;
.    44  00000152C      0152C      00024  <Type:   36>
.    48  000001530      01530      00000  <Type:   0>
.    52  000001534      01534      00000  <Type:   0>
.    56  000001538      01538      00000  <Type:   0>
.    60  00000153C      0153C      00000  <Type:   0>


  (* --- Astrobe code begin --- *)

  PROCEDURE* getHalfWord(addr: INTEGER; VAR value: INTEGER);
  (* from Astrobe library, modified *)
  (* get 16-bit data from an address that is possibly not word-aligned *)
    VAR b1, b2: BYTE;
  BEGIN
.    64  000001540      0B500  push      { lr }
    (*
    SYSTEM.PUT(LED.LSET, {LED.Red});
    Out.String("addr "); Out.Hex(addr, 0); Out.Ln;
    *)
    SYSTEM.GET(addr + 1, b1);
.    66  000001542      01C44  adds      r4,r0,#1
.    68  000001544      07822  ldrb      r2,[r4]
    (*
    SYSTEM.PUT(LED.LSET, {LED.Green});
    *)
    SYSTEM.GET(addr, b2);
.    70  000001546      07803  ldrb      r3,[r0]
    value := LSL(b1, 8) + b2;
.    72  000001548      00214  lsls      r4,r2,#8
.    74  00000154A      0441C  add       r4,r3
.    76  00000154C      0600C  str       r4,[r1]
  END getHalfWord;
.    78  00000154E      0BD00  pop       { pc }

  PROCEDURE isBL(codeAddr: INTEGER): BOOLEAN;
  (* from Astrobe library *)
  (* check if the instruction at 'codeAddr' is a BL instruction: [31:27] = 11110 *)
  (* note how the 32 bit code is stored as two 16 bit values:
      addr[x]   = [31:16]
      addr[x+2] = [15:0]
    since we have little endian encoding, it's physically:
      addr[x]   = [23:16][31:24]
      addr[x+2] = [7:0][15:8]
    but the load instruction takes care of *that* conversion.
  *)
    VAR instr: INTEGER;
  BEGIN
.    80  000001550      0B501  push      { r0, lr }
.    82  000001552      0B081  sub       sp,#4
    getHalfWord(codeAddr, instr);
.    84  000001554      09801  ldr       r0,[sp,#4]
.    86  000001556      04669  mov       r1,sp
.    88  000001558  0F7FFFFF2  bl.w      -28 -> 64
.    92  00000155C      0E000  b         0 -> 96
.    94  00000155E      0006B  <LineNo: 107>
    RETURN BFX(instr, 15, 11) = 01EH
.    96  000001560      09800  ldr       r0,[sp]
.    98  000001562  0F3C020C4  ubfx      r0,r0,11,5
  END isBL;
.   102  000001566      0281E  cmp       r0,#30
.   104  000001568      0BF0C  ite       eq
.   106  00000156A  0F04F0001  moveq.w   r0,#1
.   110  00000156E  0F04F0000  movne.w   r0,#0
.   114  000001572      0B002  add       sp,#8
.   116  000001574      0BD00  pop       { pc }
.   118  000001576      0BF00  nop       

  PROCEDURE isBLX(codeAddr: INTEGER): BOOLEAN;
  (* from Astrobe library, modified *)
  (* check if the instruction at 'codeAddr' is a BLX instruction: 010001111rrrr000 *)
    CONST
      BLXmask = 0FF87H; (* 1111 1111 1000 0111 *)
      BLXval  = 04780H; (* 0100 0111 1000 0000 *)
    VAR instr: INTEGER;
  BEGIN
.   120  000001578      0B501  push      { r0, lr }
.   122  00000157A      0B081  sub       sp,#4
    getHalfWord(codeAddr, instr);
.   124  00000157C      09801  ldr       r0,[sp,#4]
.   126  00000157E      04669  mov       r1,sp
.   128  000001580  0F7FFFFDE  bl.w      -68 -> 64
.   132  000001584      0E000  b         0 -> 136
.   134  000001586      00077  <LineNo: 119>
    RETURN BITS(instr) * BITS(BLXmask) = BITS(BLXval)
.   136  000001588      09800  ldr       r0,[sp]
.   138  00000158A  0F64F7187  movw      r1,#000FF87H
.   142  00000158E      04008  ands      r0,r1
    (*RETURN (BFX(instr, 15, 7) = 08FH) & (BFX(instr, 2, 0) = 0)*)
  END isBLX;
.   144  000001590  0F2447180  movw      r1,#18304
.   148  000001594  0EA900F01  teq.w     r0,r1
.   152  000001598      0BF0C  ite       eq
.   154  00000159A  0F04F0001  moveq.w   r0,#1
.   158  00000159E  0F04F0000  movne.w   r0,#0
.   162  0000015A2      0B002  add       sp,#8
.   164  0000015A4      0BD00  pop       { pc }
.   166  0000015A6      0BF00  nop       

  PROCEDURE getLR(stackAddr: INTEGER; VAR lr, res: INTEGER);
  (* from Astrobe library, modified *)
  (* Check if the value at 'stackAddr' on the stack is a link register address.
  If yes, it will point to a code address (+1 for thumb mode) which
  is preceded by a BL or BLX instruction. *)
    VAR nextInstr: INTEGER;
  BEGIN
.   168  0000015A8      0B507  push      { r0, r1, r2, lr }
.   170  0000015AA      0B081  sub       sp,#4
    res := StackTraceNotLR;
.   172  0000015AC      02000  movs      r0,#0
.   174  0000015AE      09903  ldr       r1,[sp,#12]
.   176  0000015B0      06008  str       r0,[r1]
    SYSTEM.GET(stackAddr, lr);
.   178  0000015B2      09801  ldr       r0,[sp,#4]
.   180  0000015B4      06801  ldr       r1,[r0]
.   182  0000015B6      09A02  ldr       r2,[sp,#8]
.   184  0000015B8      06011  str       r1,[r2]
    (* must be Thumb mode *)
    IF ODD(lr) THEN
.   186  0000015BA      09802  ldr       r0,[sp,#8]
.   188  0000015BC      06800  ldr       r0,[r0]
.   190  0000015BE  0F0100F01  tst.w     r0,#1
.   194  0000015C2  0F0008040  beq.w     128 -> 326
      DEC(lr, 1);
.   198  0000015C6      09802  ldr       r0,[sp,#8]
.   200  0000015C8      06801  ldr       r1,[r0]
.   202  0000015CA      03901  subs      r1,#1
.   204  0000015CC      06001  str       r1,[r0]
      IF (lr >= Config.CodeMem.start + 100H) & (lr < Config.CodeMem.end) THEN
.   206  0000015CE  0F8DF007C  ldr.w     r0,[pc,#124] -> 332
.   210  0000015D2      06800  ldr       r0,[r0]
.   212  0000015D4  0F5007080  add.w     r0,r0,#256
.   216  0000015D8      09902  ldr       r1,[sp,#8]
.   218  0000015DA      06809  ldr       r1,[r1]
.   220  0000015DC      04281  cmp       r1,r0
.   222  0000015DE  0F2C08032  blt.w     100 -> 326
.   226  0000015E2  0F8DF0068  ldr.w     r0,[pc,#104] -> 332
.   230  0000015E6      09902  ldr       r1,[sp,#8]
.   232  0000015E8      06809  ldr       r1,[r1]
.   234  0000015EA      06840  ldr       r0,[r0,#4]
.   236  0000015EC      04281  cmp       r1,r0
.   238  0000015EE  0F280802A  bge.w     84 -> 326
        IF isBL(lr - 4) OR isBLX(lr - 2) THEN
.   242  0000015F2      09802  ldr       r0,[sp,#8]
.   244  0000015F4      06800  ldr       r0,[r0]
.   246  0000015F6      03804  subs      r0,#4
.   248  0000015F8  0F7FFFFAA  bl.w      -172 -> 80
.   252  0000015FC      0E000  b         0 -> 256
.   254  0000015FE      00089  <LineNo: 137>
.   256  000001600  0F0100F01  tst.w     r0,#1
.   260  000001604  0F040800B  bne.w     22 -> 286
.   264  000001608      09802  ldr       r0,[sp,#8]
.   266  00000160A      06800  ldr       r0,[r0]
.   268  00000160C      03802  subs      r0,#2
.   270  00000160E  0F7FFFFB3  bl.w      -154 -> 120
.   274  000001612      0E000  b         0 -> 278
.   276  000001614      00089  <LineNo: 137>
.   278  000001616  0F0100F01  tst.w     r0,#1
.   282  00000161A  0F0008014  beq.w     40 -> 326
          getHalfWord(lr, nextInstr);
.   286  00000161E      09802  ldr       r0,[sp,#8]
.   288  000001620      06800  ldr       r0,[r0]
.   290  000001622      04669  mov       r1,sp
.   292  000001624  0F7FFFF8C  bl.w      -232 -> 64
.   296  000001628      0E000  b         0 -> 300
.   298  00000162A      0008A  <LineNo: 138>
          (* if stack trace is enabled there is a B,0 instruction (0E0000H)
          that skips the line number after the BL or BLX instruction *)
          IF nextInstr = 0E000H THEN
.   300  00000162C      09800  ldr       r0,[sp]
.   302  00000162E  0F5B04F60  cmp.w     r0,#000E000H
.   306  000001632  0F0408005  bne.w     10 -> 320
            res := StackTraceLineNo
          ELSE
.   310  000001636      02001  movs      r0,#1
.   312  000001638      09903  ldr       r1,[sp,#12]
.   314  00000163A      06008  str       r0,[r1]
            res := StackTraceNoLineNo
.   316  00000163C  0F000B803  b.w       6 -> 326
          END
.   320  000001640      02002  movs      r0,#2
.   322  000001642      09903  ldr       r1,[sp,#12]
.   324  000001644      06008  str       r0,[r1]
        END
      END
    END
  END getLR;
.   326  000001646      0B004  add       sp,#16
.   328  000001648      0BD00  pop       { pc }
.   330  00000164A      0BF00  nop       
.   332  00000164C  020027FA8  <Global: Config data>

  (* --- Astrobe code end --- *)

  PROCEDURE* traceStart(stackframeBase, excRetVal: INTEGER): INTEGER;
    CONST StackAlign = 9; (* in stacked PSR *)
    VAR startAddr: INTEGER;
  BEGIN
.   336  000001650      0B500  push      { lr }
    startAddr := stackframeBase + StateContextSize;
.   338  000001652  0F1000220  add.w     r2,r0,#32
    IF ~(EXC_RET_FType IN BITS(excRetVal)) THEN (* FP context *)
.   342  000001656  0F0110F10  tst.w     r1,#16
.   346  00000165A  0F0408002  bne.w     4 -> 354
      startAddr := startAddr + FPcontextSize
    END;
.   350  00000165E  0F1020248  add.w     r2,r2,#72
    IF SYSTEM.BIT(stackframeBase + PSRoffset, StackAlign) THEN
.   354  000001662  0F100031C  add.w     r3,r0,#28
.   358  000001666      0681C  ldr       r4,[r3]
.   360  000001668      005A4  lsls      r4,r4,#22
.   362  00000166A  0F1408001  bpl.w     2 -> 368
      INC(startAddr, 4)
    END
.   366  00000166E      03204  adds      r2,#4
    RETURN startAddr
  END traceStart;
.   368  000001670      04610  mov       r0,r2
.   370  000001672      0BD00  pop       { pc }


  PROCEDURE getAddr(VAR stackAddr, excRetVal: INTEGER; VAR isStackFrame: BOOLEAN);
    CONST R11 = 11;
    VAR stackVal, lr, res: INTEGER;
  BEGIN
.   372  000001674      0B507  push      { r0, r1, r2, lr }
.   374  000001676      0B083  sub       sp,#12
    isStackFrame := FALSE;
.   376  000001678      02000  movs      r0,#0
.   378  00000167A      09905  ldr       r1,[sp,#20]
.   380  00000167C      07008  strb      r0,[r1]
    SYSTEM.GET(stackAddr, stackVal);
.   382  00000167E      09803  ldr       r0,[sp,#12]
.   384  000001680      06800  ldr       r0,[r0]
.   386  000001682      06801  ldr       r1,[r0]
.   388  000001684      09100  str       r1,[sp]
    IF BITS(stackVal) * BITS(ExcRetMask) = BITS(ExcRetVal) THEN
.   390  000001686      09800  ldr       r0,[sp]
.   392  000001688  0F06F011C  mvn.w     r1,#28
.   396  00000168C      04008  ands      r0,r1
.   398  00000168E  0F06F015F  mvn.w     r1,#95
.   402  000001692  0EA900F01  teq.w     r0,r1
.   406  000001696  0F040804A  bne.w     148 -> 558
      (* if a potential EXC_RETURN value *)
      excRetVal := stackVal; (* only valid if 'isStackFrame' *)
.   410  00000169A      09800  ldr       r0,[sp]
.   412  00000169C      09904  ldr       r1,[sp,#16]
.   414  00000169E      06008  str       r0,[r1]
      SYSTEM.GET(stackAddr + 4, stackVal);
.   416  0000016A0      09803  ldr       r0,[sp,#12]
.   418  0000016A2      06800  ldr       r0,[r0]
.   420  0000016A4      03004  adds      r0,#4
.   422  0000016A6      06801  ldr       r1,[r0]
.   424  0000016A8      09100  str       r1,[sp]
      IF stackVal = StackSeal THEN
.   426  0000016AA      09800  ldr       r0,[sp]
.   428  0000016AC  0F8DF1084  ldr.w     r1,[pc,#132] -> 564
.   432  0000016B0      042C8  cmn       r0,r1
.   434  0000016B2  0F040800A  bne.w     20 -> 458
        (* at top of main stack: we have an EXC_RETURN value with 'PSP used for stacking' *)
        (* switch stacks, point to stacked regs on process stack *)
        SYSTEM.EMIT(MCU.MRS_R11_PSP);
.   438  0000016B6  0F3EF8B09  .word     0x8B09F3EF /* EMIT */
        stackAddr := SYSTEM.REG(R11);
.   442  0000016BA      04658  mov       r0,r11
.   444  0000016BC      09903  ldr       r1,[sp,#12]
.   446  0000016BE      06008  str       r0,[r1]
        isStackFrame := TRUE
      ELSE
.   448  0000016C0      02001  movs      r0,#1
.   450  0000016C2      09905  ldr       r1,[sp,#20]
.   452  0000016C4      07008  strb      r0,[r1]
        (* point to potential stack frame on main stack*)
        INC(stackAddr, 4);
.   454  0000016C6  0F000B832  b.w       100 -> 558
.   458  0000016CA      09803  ldr       r0,[sp,#12]
.   460  0000016CC      06801  ldr       r1,[r0]
.   462  0000016CE      03104  adds      r1,#4
.   464  0000016D0      06001  str       r1,[r0]
        (* stacked value at LRoffset must be either a valid LR value... *)
        getLR(stackAddr + LRoffset, lr, res);
.   466  0000016D2      09803  ldr       r0,[sp,#12]
.   468  0000016D4      06800  ldr       r0,[r0]
.   470  0000016D6      03014  adds      r0,#20
.   472  0000016D8  0F11D0104  adds.w    r1,sp,#4
.   476  0000016DC  0F11D0208  adds.w    r2,sp,#8
.   480  0000016E0  0F7FFFF62  bl.w      -316 -> 168
.   484  0000016E4      0E000  b         0 -> 488
.   486  0000016E6      000BC  <LineNo: 188>
        isStackFrame := res > StackTraceNotLR;
.   488  0000016E8      09802  ldr       r0,[sp,#8]
.   490  0000016EA      02800  cmp       r0,#0
.   492  0000016EC      0BFCC  ite       gt
.   494  0000016EE  0F04F0001  movgt.w   r0,#1
.   498  0000016F2  0F04F0000  movle.w   r0,#0
.   502  0000016F6      09905  ldr       r1,[sp,#20]
.   504  0000016F8      07008  strb      r0,[r1]
        (* ... or an EXC_RETURN value *)
        IF ~isStackFrame THEN
.   506  0000016FA      09805  ldr       r0,[sp,#20]
.   508  0000016FC      07800  ldrb      r0,[r0]
.   510  0000016FE  0F0100F01  tst.w     r0,#1
.   514  000001702  0F0408014  bne.w     40 -> 558
          SYSTEM.GET(stackAddr + LRoffset, stackVal);
.   518  000001706      09803  ldr       r0,[sp,#12]
.   520  000001708      06800  ldr       r0,[r0]
.   522  00000170A      03014  adds      r0,#20
.   524  00000170C      06801  ldr       r1,[r0]
.   526  00000170E      09100  str       r1,[sp]
          isStackFrame := BITS(stackVal) * BITS(ExcRetMask) = BITS(ExcRetVal)
.   528  000001710      09800  ldr       r0,[sp]
.   530  000001712  0F06F011C  mvn.w     r1,#28
.   534  000001716      04008  ands      r0,r1
        END
.   536  000001718  0F06F015F  mvn.w     r1,#95
.   540  00000171C  0EA900F01  teq.w     r0,r1
.   544  000001720      0BF0C  ite       eq
.   546  000001722  0F04F0001  moveq.w   r0,#1
.   550  000001726  0F04F0000  movne.w   r0,#0
.   554  00000172A      09905  ldr       r1,[sp,#20]
.   556  00000172C      07008  strb      r0,[r1]
      END
    END;

  END getAddr;
.   558  00000172E      0B006  add       sp,#24
.   560  000001730      0BD00  pop       { pc }
.   562  000001732      0BF00  nop       
.   564  000001734  0010A125B  <Const:  17437275>


  PROCEDURE stacktrace(stackAddr: INTEGER; VAR trace: Trace);
    VAR
      stackVal, retAddr, excRetVal, res, lr, traceDepth: INTEGER;
      (*addr, val: INTEGER; (* debug *)*)
      tp: TracePoint; isStackFrame: BOOLEAN;
  BEGIN
.   568  000001738      0B507  push      { r0, r1, r2, lr }
.   570  00000173A      0B08B  sub       sp,#44
    CLEAR(tp);
.   572  00000173C  0F11D0018  adds.w    r0,sp,#24
.   576  000001740      02100  movs      r1,#0
.   578  000001742      02204  movs      r2,#4
.   580  000001744  0F8401B04  str.w     r1,[r0],#4
.   584  000001748      03A01  subs      r2,#1
.   586  00000174A      0DCFB  bgt.n     -10 -> 580
    traceDepth := LEN(trace.tp);
.   588  00000174C      02010  movs      r0,#16
.   590  00000174E      09005  str       r0,[sp,#20]
    SYSTEM.GET(stackAddr, stackVal);
.   592  000001750      0980B  ldr       r0,[sp,#44]
.   594  000001752      06801  ldr       r1,[r0]
.   596  000001754      09100  str       r1,[sp]
    WHILE (stackVal # StackSeal) & (trace.count <= traceDepth) DO
.   598  000001756      09800  ldr       r0,[sp]
.   600  000001758  0F8DF1114  ldr.w     r1,[pc,#276] -> 880
.   604  00000175C      042C8  cmn       r0,r1
.   606  00000175E  0F0008084  beq.w     264 -> 874
.   610  000001762      0980C  ldr       r0,[sp,#48]
.   612  000001764  0F8D00100  ldr.w     r0,[r0,#256]
.   616  000001768      09905  ldr       r1,[sp,#20]
.   618  00000176A      04288  cmp       r0,r1
.   620  00000176C  0F300807D  bgt.w     250 -> 874
      (* debug *)
      (*
      Out.Hex(stackAddr, 13); Out.Hex(stackVal, 13); Out.Ln;
      *)
      (* debug end *)
      getAddr(stackAddr, excRetVal, isStackFrame);
.   624  000001770  0F11D002C  adds.w    r0,sp,#44
.   628  000001774  0F11D0108  adds.w    r1,sp,#8
.   632  000001778  0F11D0228  adds.w    r2,sp,#40
.   636  00000177C  0F7FFFF7A  bl.w      -268 -> 372
.   640  000001780      0E000  b         0 -> 644
.   642  000001782      000D8  <LineNo: 216>
      IF isStackFrame THEN
.   644  000001784  0F89D0028  ldrb.w    r0,[sp,#40]
.   648  000001788  0F0100F01  tst.w     r0,#1
.   652  00000178C  0F0008014  beq.w     40 -> 696
        SYSTEM.GET(stackAddr + PCoffset, retAddr);
.   656  000001790      0980B  ldr       r0,[sp,#44]
.   658  000001792      03018  adds      r0,#24
.   660  000001794      06801  ldr       r1,[r0]
.   662  000001796      09101  str       r1,[sp,#4]
        tp.address := retAddr;
.   664  000001798      09801  ldr       r0,[sp,#4]
.   666  00000179A      09006  str       r0,[sp,#24]
        tp.annotation := AnnStackframe;
.   668  00000179C  0F8DF00D4  ldr.w     r0,[pc,#212] -> 884
.   672  0000017A0      09009  str       r0,[sp,#36]
        tp.stackAddr := stackAddr;
.   674  0000017A2      0980B  ldr       r0,[sp,#44]
.   676  0000017A4      09008  str       r0,[sp,#32]
        (* addr := stackAddr; (* debug *) *)
        stackAddr := traceStart(stackAddr, excRetVal);
.   678  0000017A6      0980B  ldr       r0,[sp,#44]
.   680  0000017A8      09902  ldr       r1,[sp,#8]
.   682  0000017AA  0F7FFFF51  bl.w      -350 -> 336
.   686  0000017AE      0E000  b         0 -> 690
.   688  0000017B0      000DF  <LineNo: 223>
.   690  0000017B2      0900B  str       r0,[sp,#44]
        (* debug: print stack dump *)
        (*
        WHILE addr < stackAddr DO
          SYSTEM.GET(addr, val);
          Out.String("> "); Out.Hex(addr, 13); Out.Hex(val, 13); Out.Ln;
          INC(addr, 4)
        END
        *)
        (* debug end *)
      ELSE
        getLR(stackAddr, lr, res);
.   692  0000017B4  0F000B821  b.w       66 -> 762
.   696  0000017B8      0980B  ldr       r0,[sp,#44]
.   698  0000017BA  0F11D0110  adds.w    r1,sp,#16
.   702  0000017BE  0F11D020C  adds.w    r2,sp,#12
.   706  0000017C2  0F7FFFEF1  bl.w      -542 -> 168
.   710  0000017C6      0E000  b         0 -> 714
.   712  0000017C8      000EA  <LineNo: 234>
        IF res > StackTraceNotLR THEN
.   714  0000017CA      09803  ldr       r0,[sp,#12]
.   716  0000017CC      02800  cmp       r0,#0
.   718  0000017CE  0F3408011  ble.w     34 -> 756
          tp.address := lr - 4;
.   722  0000017D2      09804  ldr       r0,[sp,#16]
.   724  0000017D4      03804  subs      r0,#4
.   726  0000017D6      09006  str       r0,[sp,#24]
          tp.stackAddr := stackAddr;
.   728  0000017D8      0980B  ldr       r0,[sp,#44]
.   730  0000017DA      09008  str       r0,[sp,#32]
          IF res = StackTraceLineNo THEN
.   732  0000017DC      09803  ldr       r0,[sp,#12]
.   734  0000017DE      02801  cmp       r0,#1
.   736  0000017E0  0F0408008  bne.w     16 -> 756
            getHalfWord(lr + 2, tp.lineNo)
.   740  0000017E4      09804  ldr       r0,[sp,#16]
.   742  0000017E6      03002  adds      r0,#2
.   744  0000017E8  0F11D011C  adds.w    r1,sp,#28
          END
.   748  0000017EC  0F7FFFEA8  bl.w      -688 -> 64
.   752  0000017F0      0E000  b         0 -> 756
.   754  0000017F2      000EF  <LineNo: 239>
        END;
        INC(stackAddr, 4)
      END;
.   756  0000017F4      0980B  ldr       r0,[sp,#44]
.   758  0000017F6      03004  adds      r0,#4
.   760  0000017F8      0900B  str       r0,[sp,#44]
      IF tp.address # 0 THEN (* tp is valid *)
.   762  0000017FA      09806  ldr       r0,[sp,#24]
.   764  0000017FC      02800  cmp       r0,#0
.   766  0000017FE  0F000802F  beq.w     94 -> 864
        IF trace.count < TraceDepth THEN
.   770  000001802      0980C  ldr       r0,[sp,#48]
.   772  000001804  0F8D00100  ldr.w     r0,[r0,#256]
.   776  000001808      02810  cmp       r0,#16
.   778  00000180A  0F2808025  bge.w     74 -> 856
          trace.tp[trace.count] := tp;
.   782  00000180E      0980C  ldr       r0,[sp,#48]
.   784  000001810  0F8D00100  ldr.w     r0,[r0,#256]
.   788  000001814      02810  cmp       r0,#16
.   790  000001816      0D301  bcc.n     2 -> 796
.   792  000001818      0DF01  svc       1
.   794  00000181A      000F6  <LineNo: 246>
.   796  00000181C      0990C  ldr       r1,[sp,#48]
.   798  00000181E      00102  lsls      r2,r0,#4
.   800  000001820  0EB020001  add.w     r0,r2,r1
.   804  000001824      02104  movs      r1,#4
.   806  000001826  0F11D0218  adds.w    r2,sp,#24
.   810  00000182A  0F8523B04  ldr.w     r3,[r2],#4
.   814  00000182E  0F8403B04  str.w     r3,[r0],#4
.   818  000001832      03901  subs      r1,#1
.   820  000001834      0D1F9  bne.n     -14 -> 810
          INC(trace.count);
.   822  000001836      0980C  ldr       r0,[sp,#48]
.   824  000001838  0F8D01100  ldr.w     r1,[r0,#256]
.   828  00000183C      03101  adds      r1,#1
.   830  00000183E  0F8C01100  str.w     r1,[r0,#256]
          CLEAR(tp)
        ELSE
.   834  000001842  0F11D0018  adds.w    r0,sp,#24
.   838  000001846      02100  movs      r1,#0
.   840  000001848      02204  movs      r2,#4
.   842  00000184A      0BF00  nop       
.   844  00000184C  0F8401B04  str.w     r1,[r0],#4
.   848  000001850      03A01  subs      r2,#1
.   850  000001852      0DCFB  bgt.n     -10 -> 844
          trace.more := TRUE
.   852  000001854  0F000B804  b.w       8 -> 864
        END
.   856  000001858      02001  movs      r0,#1
.   858  00000185A      0990C  ldr       r1,[sp,#48]
.   860  00000185C  0F8810104  strb.w    r0,[r1,#260]
      END;
      SYSTEM.GET(stackAddr, stackVal);
.   864  000001860      0980B  ldr       r0,[sp,#44]
.   866  000001862      06801  ldr       r1,[r0]
.   868  000001864      09100  str       r1,[sp]
    END
.   870  000001866  0F7FFBF76  b.w       -276 -> 598
  END stacktrace;
.   874  00000186A      0B00E  add       sp,#56
.   876  00000186C      0BD00  pop       { pc }
.   878  00000186E      0BF00  nop       
.   880  000001870  0010A125B  <Const:  17437275>
.   884  000001874  0FFFFFFFF  <Const:  -1>


  PROCEDURE CreateTrace*(er: RuntimeErrors.ErrorDesc; VAR tr: Trace);
    VAR tp: TracePoint;
  BEGIN
.   888  000001878      0B50F  push      { r0, r1, r2, r3, lr }
.   890  00000187A      0B084  sub       sp,#16
    tp.address := er.errAddr;
.   892  00000187C      09804  ldr       r0,[sp,#16]
.   894  00000187E      06840  ldr       r0,[r0,#4]
.   896  000001880      09000  str       r0,[sp]
    tp.lineNo := er.errLineNo;
.   898  000001882      09804  ldr       r0,[sp,#16]
.   900  000001884      06880  ldr       r0,[r0,#8]
.   902  000001886      09001  str       r0,[sp,#4]
    tp.stackAddr := 0;
.   904  000001888      02000  movs      r0,#0
.   906  00000188A      09002  str       r0,[sp,#8]
    tp.annotation := 0;
.   908  00000188C      02000  movs      r0,#0
.   910  00000188E      09003  str       r0,[sp,#12]
    tr.tp[0] := tp;
.   912  000001890      02004  movs      r0,#4
.   914  000001892      09906  ldr       r1,[sp,#24]
.   916  000001894      0466A  mov       r2,sp
.   918  000001896  0F8523B04  ldr.w     r3,[r2],#4
.   922  00000189A  0F8413B04  str.w     r3,[r1],#4
.   926  00000189E      03801  subs      r0,#1
.   928  0000018A0      0D1F9  bne.n     -14 -> 918
    tr.count := 1;
.   930  0000018A2      02001  movs      r0,#1
.   932  0000018A4      09906  ldr       r1,[sp,#24]
.   934  0000018A6  0F8C10100  str.w     r0,[r1,#256]
    tr.more := FALSE;
.   938  0000018AA      02000  movs      r0,#0
.   940  0000018AC      09906  ldr       r1,[sp,#24]
.   942  0000018AE  0F8810104  strb.w    r0,[r1,#260]
    stacktrace(traceStart(er.stackframeBase, er.excRetVal), tr)
.   946  0000018B2      09804  ldr       r0,[sp,#16]
.   948  0000018B4      068C0  ldr       r0,[r0,#12]
.   950  0000018B6      09904  ldr       r1,[sp,#16]
.   952  0000018B8      06909  ldr       r1,[r1,#16]
.   954  0000018BA  0F7FFFEC9  bl.w      -622 -> 336
.   958  0000018BE      0E000  b         0 -> 962
.   960  0000018C0      0010C  <LineNo: 268>
.   962  0000018C2      09906  ldr       r1,[sp,#24]
.   964  0000018C4      09A07  ldr       r2,[sp,#28]
  END CreateTrace;
.   966  0000018C6  0F7FFFF37  bl.w      -402 -> 568
.   970  0000018CA      0E000  b         0 -> 974
.   972  0000018CC      0010C  <LineNo: 268>
.   974  0000018CE      0B008  add       sp,#32
.   976  0000018D0      0BD00  pop       { pc }
.   978  0000018D2      0BF00  nop       


  PROCEDURE ReadRegisters*(er: RuntimeErrors.ErrorDesc; VAR sr: StackedRegs);
    VAR stackframeBase: INTEGER;
  BEGIN
.   980  0000018D4      0B50F  push      { r0, r1, r2, r3, lr }
.   982  0000018D6      0B081  sub       sp,#4
    stackframeBase := er.stackframeBase;
.   984  0000018D8      09801  ldr       r0,[sp,#4]
.   986  0000018DA      068C0  ldr       r0,[r0,#12]
.   988  0000018DC      09000  str       r0,[sp]
    SYSTEM.GET(stackframeBase, sr.r0);
.   990  0000018DE      09800  ldr       r0,[sp]
.   992  0000018E0      06801  ldr       r1,[r0]
.   994  0000018E2      09A03  ldr       r2,[sp,#12]
.   996  0000018E4      06011  str       r1,[r2]
    SYSTEM.GET(stackframeBase + 4, sr.r1);
.   998  0000018E6      09800  ldr       r0,[sp]
.  1000  0000018E8      03004  adds      r0,#4
.  1002  0000018EA      06801  ldr       r1,[r0]
.  1004  0000018EC      09A03  ldr       r2,[sp,#12]
.  1006  0000018EE      06051  str       r1,[r2,#4]
    SYSTEM.GET(stackframeBase + 8, sr.r2);
.  1008  0000018F0      09800  ldr       r0,[sp]
.  1010  0000018F2      03008  adds      r0,#8
.  1012  0000018F4      06801  ldr       r1,[r0]
.  1014  0000018F6      09A03  ldr       r2,[sp,#12]
.  1016  0000018F8      06091  str       r1,[r2,#8]
    SYSTEM.GET(stackframeBase + 12, sr.r3);
.  1018  0000018FA      09800  ldr       r0,[sp]
.  1020  0000018FC      0300C  adds      r0,#12
.  1022  0000018FE      06801  ldr       r1,[r0]
.  1024  000001900      09A03  ldr       r2,[sp,#12]
.  1026  000001902      060D1  str       r1,[r2,#12]
    SYSTEM.GET(stackframeBase + 16, sr.r12);
.  1028  000001904      09800  ldr       r0,[sp]
.  1030  000001906      03010  adds      r0,#16
.  1032  000001908      06801  ldr       r1,[r0]
.  1034  00000190A      09A03  ldr       r2,[sp,#12]
.  1036  00000190C      06111  str       r1,[r2,#16]
    SYSTEM.GET(stackframeBase + 20, sr.lr);
.  1038  00000190E      09800  ldr       r0,[sp]
.  1040  000001910      03014  adds      r0,#20
.  1042  000001912      06801  ldr       r1,[r0]
.  1044  000001914      09A03  ldr       r2,[sp,#12]
.  1046  000001916      06151  str       r1,[r2,#20]
    SYSTEM.GET(stackframeBase + 24, sr.pc);
.  1048  000001918      09800  ldr       r0,[sp]
.  1050  00000191A      03018  adds      r0,#24
.  1052  00000191C      06801  ldr       r1,[r0]
.  1054  00000191E      09A03  ldr       r2,[sp,#12]
.  1056  000001920      06191  str       r1,[r2,#24]
    SYSTEM.GET(stackframeBase + 28, sr.xpsr);
.  1058  000001922      09800  ldr       r0,[sp]
.  1060  000001924      0301C  adds      r0,#28
.  1062  000001926      06801  ldr       r1,[r0]
.  1064  000001928      09A03  ldr       r2,[sp,#12]
.  1066  00000192A      061D1  str       r1,[r2,#28]
    sr.sp := stackframeBase
  END ReadRegisters;
.  1068  00000192C      09800  ldr       r0,[sp]
.  1070  00000192E      09903  ldr       r1,[sp,#12]
.  1072  000001930      06208  str       r0,[r1,#32]
.  1074  000001932      0B005  add       sp,#20
.  1076  000001934      0BD00  pop       { pc }
.  1078  000001936      0BF00  nop       

END Stacktrace.
.  1080  000001938      0B500  push      { lr }
.  1082  00000193A      0BD00  pop       { pc }
 