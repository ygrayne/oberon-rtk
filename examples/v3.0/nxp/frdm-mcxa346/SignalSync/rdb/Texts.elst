. <tool: Astrobe for RP2350>
. <prog: C:\Users\gray\Projects\oberon\dev\oberon-rtk\examples\v3.0\nxp\frdm-mcxa346\SignalSync\SignalSync.mod>

.     0  0000023C0              <Pad: 0>
MODULE Texts;
(**
  Oberon RTK Framework
  Version: v3.0
  --
  Formatted output to a "channel", using a 'TextIO.Writer'
  Formatted input from a "channel", using a 'TextIO.Reader'
  --
  The behaviour of the procedures depends on the write string and read
  procedures allocated to 'W' and 'R' parameters:
  * blocking
  * non-blocking (using the kernel)
  --
  Copyright (c) 2020-2025 Gray gray@grayraven.org
  https://oberon-rtk.org/licences/
**)

  IMPORT TextIO, Errors;

  CONST
    CR = 0DX;
    LF = 0AX;
    Blanks = "                                "; (* 32 blanks *)
.     4  0000023C4  020202020  <String: "    ">
.     8  0000023C8  020202020  <String: "    ">
.    12  0000023CC  020202020  <String: "    ">
.    16  0000023D0  020202020  <String: "    ">
.    20  0000023D4  020202020  <String: "    ">
.    24  0000023D8  020202020  <String: "    ">
.    28  0000023DC  020202020  <String: "    ">
.    32  0000023E0  020202020  <String: "    ">
.    36  0000023E4  000000000  <String: "....">
    MaxBlanks = 32;

    (* conversion constants *)
    MaxInt* = 07FFFFFFFH; (*  2,147,483,647 *)
    MinInt* = 080000000H; (* -2,147,483,648 *)
    MaxIntDigits* = 10;   (* sans sign, sans leading zeros *)

    (* read results *)
    NoError* = TextIO.NoError;
    BufferOverflow* = TextIO.BufferOverflow; (* a tool small buffer was provided or used *)
    SyntaxError* = TextIO.SyntaxError;      (* zero length or non-numerical chars *)
    OutOfLimits* = TextIO.OutOfLimits;    (* bigger than MaxInt, smaller than MinInt *)
    NoInput* = TextIO.NoInput;
    FifoOverrun* = TextIO.FifoOverrun;

  VAR eol: ARRAY 2 OF CHAR;

  (* write conversions *)

  PROCEDURE IntToString*(int: INTEGER; VAR str: ARRAY OF CHAR; VAR slen: INTEGER);
    VAR spos, dpos: INTEGER; digits: ARRAY 10 OF CHAR;
  BEGIN
.    40  0000023E8      0B50F  push      { r0, r1, r2, r3, lr }
.    42  0000023EA      0B085  sub       sp,#20
    ASSERT(LEN(str) >= 12, Errors.PreCond); (* 10 digits, minus sign, 0X *)
.    44  0000023EC      09807  ldr       r0,[sp,#28]
.    46  0000023EE      0280C  cmp       r0,#12
.    48  0000023F0      0DA01  bge.n     2 -> 54
.    50  0000023F2      0DF22  svc       34
.    52  0000023F4      0002E  <LineNo: 46>
    IF int = 080000000H THEN
.    54  0000023F6      09805  ldr       r0,[sp,#20]
.    56  0000023F8  0F1104F00  cmn.w     r0,#080000000H
.    60  0000023FC  0F0408027  bne.w     78 -> 142
      str := "-2147483648";
.    64  000002400      0200C  movs      r0,#12
.    66  000002402      09907  ldr       r1,[sp,#28]
.    68  000002404      04281  cmp       r1,r0
.    70  000002406      0DA01  bge.n     2 -> 76
.    72  000002408      0DF06  svc       6
.    74  00000240A      00030  <LineNo: 48>
.    76  00000240C      09806  ldr       r0,[sp,#24]
.    78  00000240E      0BF00  nop       
.    80  000002410      0A100  adr       r1,pc,#0 -> 84
.    82  000002412      0E005  b         10 -> 96
.    84  000002414  03431322D  <String: "-214">
.    88  000002418  033383437  <String: "7483">
.    92  00000241C  000383436  <String: "648.">
.    96  000002420  0F8512B04  ldr.w     r2,[r1],#4
.   100  000002424  0F8402B04  str.w     r2,[r0],#4
.   104  000002428  0F012427F  ands.w    r2,r2,#0FF000000H
.   108  00000242C      0D1F8  bne.n     -16 -> 96
      str[11] := 0X;
.   110  00000242E      0200B  movs      r0,#11
.   112  000002430      09907  ldr       r1,[sp,#28]
.   114  000002432      04288  cmp       r0,r1
.   116  000002434      0D301  bcc.n     2 -> 122
.   118  000002436      0DF01  svc       1
.   120  000002438      00031  <LineNo: 49>
.   122  00000243A      09906  ldr       r1,[sp,#24]
.   124  00000243C  0EB100001  adds.w    r0,r0,r1
.   128  000002440      02100  movs      r1,#0
.   130  000002442      07001  strb      r1,[r0]
      slen := 11
    ELSE
.   132  000002444      0200B  movs      r0,#11
.   134  000002446      09908  ldr       r1,[sp,#32]
.   136  000002448      06008  str       r0,[r1]
      spos := 0;
.   138  00000244A  0F000B86D  b.w       218 -> 360
.   142  00000244E      02000  movs      r0,#0
.   144  000002450      09000  str       r0,[sp]
      IF int < 0 THEN
.   146  000002452      09805  ldr       r0,[sp,#20]
.   148  000002454      02800  cmp       r0,#0
.   150  000002456  0F2808012  bge.w     36 -> 190
        int := -int;
.   154  00000245A      09805  ldr       r0,[sp,#20]
.   156  00000245C  0F1D00000  rsbs.w    r0,r0,#0
.   160  000002460      09005  str       r0,[sp,#20]
        str[spos] := "-";
.   162  000002462      09800  ldr       r0,[sp]
.   164  000002464      09907  ldr       r1,[sp,#28]
.   166  000002466      04288  cmp       r0,r1
.   168  000002468      0D301  bcc.n     2 -> 174
.   170  00000246A      0DF01  svc       1
.   172  00000246C      00037  <LineNo: 55>
.   174  00000246E      09906  ldr       r1,[sp,#24]
.   176  000002470  0EB100001  adds.w    r0,r0,r1
.   180  000002474      0212D  movs      r1,#45
.   182  000002476      07001  strb      r1,[r0]
        INC(spos)
      END;
.   184  000002478      09800  ldr       r0,[sp]
.   186  00000247A      03001  adds      r0,#1
.   188  00000247C      09000  str       r0,[sp]
      dpos := 0;
.   190  00000247E      02000  movs      r0,#0
.   192  000002480      09001  str       r0,[sp,#4]
      REPEAT
        digits[dpos] := CHR(int MOD 10 + ORD("0"));
.   194  000002482      09801  ldr       r0,[sp,#4]
.   196  000002484      0280A  cmp       r0,#10
.   198  000002486      0D301  bcc.n     2 -> 204
.   200  000002488      0DF01  svc       1
.   202  00000248A      0003C  <LineNo: 60>
.   204  00000248C  0EB1D0000  adds.w    r0,sp,r0
.   208  000002490      09905  ldr       r1,[sp,#20]
.   210  000002492      0220A  movs      r2,#10
.   212  000002494  0FB91F3F2  sdiv.w    r3,r1,r2
.   216  000002498  0FB031112  mls.w     r1,r3,r2,r1
.   220  00000249C  0F1B10F00  cmp.w     r1,#0
.   224  0000024A0      0BF48  it        mi
.   226  0000024A2  0EB010102  addmi.w   r1,r1,r2
.   230  0000024A6      03130  adds      r1,#48
.   232  0000024A8      07201  strb      r1,[r0,#8]
        int := int DIV 10;
.   234  0000024AA      09805  ldr       r0,[sp,#20]
.   236  0000024AC      0210A  movs      r1,#10
.   238  0000024AE  0FB90F2F1  sdiv.w    r2,r0,r1
.   242  0000024B2  0FB020011  mls.w     r0,r2,r1,r0
.   246  0000024B6  0EBA270D0  sub.w     r0,r2,r0,lsr 31
.   250  0000024BA      09005  str       r0,[sp,#20]
        INC(dpos)
      UNTIL int = 0;
.   252  0000024BC      09801  ldr       r0,[sp,#4]
.   254  0000024BE      03001  adds      r0,#1
.   256  0000024C0      09001  str       r0,[sp,#4]
.   258  0000024C2      09805  ldr       r0,[sp,#20]
.   260  0000024C4      02800  cmp       r0,#0
.   262  0000024C6  0F47FAFDC  bne.w     -72 -> 194
      DEC(dpos);
.   266  0000024CA      09801  ldr       r0,[sp,#4]
.   268  0000024CC      03801  subs      r0,#1
.   270  0000024CE      09001  str       r0,[sp,#4]
      WHILE dpos >= 0 DO
.   272  0000024D0      09801  ldr       r0,[sp,#4]
.   274  0000024D2      02800  cmp       r0,#0
.   276  0000024D4  0F2C0801A  blt.w     52 -> 332
        str[spos] := digits[dpos];
.   280  0000024D8      09800  ldr       r0,[sp]
.   282  0000024DA      09907  ldr       r1,[sp,#28]
.   284  0000024DC      04288  cmp       r0,r1
.   286  0000024DE      0D301  bcc.n     2 -> 292
.   288  0000024E0      0DF01  svc       1
.   290  0000024E2      00042  <LineNo: 66>
.   292  0000024E4      09906  ldr       r1,[sp,#24]
.   294  0000024E6  0EB100001  adds.w    r0,r0,r1
.   298  0000024EA      09901  ldr       r1,[sp,#4]
.   300  0000024EC      0290A  cmp       r1,#10
.   302  0000024EE      0D301  bcc.n     2 -> 308
.   304  0000024F0      0DF01  svc       1
.   306  0000024F2      00042  <LineNo: 66>
.   308  0000024F4  0EB1D0101  adds.w    r1,sp,r1
.   312  0000024F8      07A09  ldrb      r1,[r1,#8]
.   314  0000024FA      07001  strb      r1,[r0]
        DEC(dpos); INC(spos)
.   316  0000024FC      09801  ldr       r0,[sp,#4]
.   318  0000024FE      03801  subs      r0,#1
.   320  000002500      09001  str       r0,[sp,#4]
      END;
.   322  000002502      09800  ldr       r0,[sp]
.   324  000002504      03001  adds      r0,#1
.   326  000002506      09000  str       r0,[sp]
.   328  000002508  0F7FFBFE2  b.w       -60 -> 272
      str[spos] := 0X;
.   332  00000250C      09800  ldr       r0,[sp]
.   334  00000250E      09907  ldr       r1,[sp,#28]
.   336  000002510      04288  cmp       r0,r1
.   338  000002512      0D301  bcc.n     2 -> 344
.   340  000002514      0DF01  svc       1
.   342  000002516      00045  <LineNo: 69>
.   344  000002518      09906  ldr       r1,[sp,#24]
.   346  00000251A  0EB100001  adds.w    r0,r0,r1
.   350  00000251E      02100  movs      r1,#0
.   352  000002520      07001  strb      r1,[r0]
      slen := spos
    END
.   354  000002522      09800  ldr       r0,[sp]
.   356  000002524      09908  ldr       r1,[sp,#32]
.   358  000002526      06008  str       r0,[r1]
  END IntToString;
.   360  000002528      0B009  add       sp,#36
.   362  00000252A      0BD00  pop       { pc }


  PROCEDURE IntToHexString*(int: INTEGER; VAR str: ARRAY OF CHAR; VAR slen: INTEGER);
    VAR dpos, spos, d: INTEGER; digits: ARRAY 10 OF CHAR;
  BEGIN
.   364  00000252C      0B50F  push      { r0, r1, r2, r3, lr }
.   366  00000252E      0B086  sub       sp,#24
    ASSERT(LEN(str) >= 10, Errors.PreCond);
.   368  000002530      09808  ldr       r0,[sp,#32]
.   370  000002532      0280A  cmp       r0,#10
.   372  000002534      0DA01  bge.n     2 -> 378
.   374  000002536      0DF22  svc       34
.   376  000002538      0004E  <LineNo: 78>
    dpos := 0;
.   378  00000253A      02000  movs      r0,#0
.   380  00000253C      09000  str       r0,[sp]
    REPEAT
      d := int MOD 010H;
.   382  00000253E      09806  ldr       r0,[sp,#24]
.   384  000002540  0F000000F  and.w     r0,r0,#15
.   388  000002544      09002  str       r0,[sp,#8]
      IF d < 10 THEN
.   390  000002546      09802  ldr       r0,[sp,#8]
.   392  000002548      0280A  cmp       r0,#10
.   394  00000254A  0F280800C  bge.w     24 -> 422
        digits[dpos] := CHR(d + ORD("0"))
.   398  00000254E      09800  ldr       r0,[sp]
.   400  000002550      0280A  cmp       r0,#10
.   402  000002552      0D301  bcc.n     2 -> 408
.   404  000002554      0DF01  svc       1
.   406  000002556      00053  <LineNo: 83>
.   408  000002558  0EB1D0000  adds.w    r0,sp,r0
.   412  00000255C      09902  ldr       r1,[sp,#8]
.   414  00000255E      03130  adds      r1,#48
      ELSE
.   416  000002560      07301  strb      r1,[r0,#12]
        digits[dpos] := CHR(d - 10 + ORD("A"))
.   418  000002562  0F000B80B  b.w       22 -> 444
.   422  000002566      09800  ldr       r0,[sp]
.   424  000002568      0280A  cmp       r0,#10
.   426  00000256A      0D301  bcc.n     2 -> 432
.   428  00000256C      0DF01  svc       1
.   430  00000256E      00055  <LineNo: 85>
.   432  000002570  0EB1D0000  adds.w    r0,sp,r0
.   436  000002574      09902  ldr       r1,[sp,#8]
.   438  000002576      0390A  subs      r1,#10
.   440  000002578      03141  adds      r1,#65
      END;
.   442  00000257A      07301  strb      r1,[r0,#12]
      int := int DIV 010H;
.   444  00000257C      09806  ldr       r0,[sp,#24]
.   446  00000257E      01100  asrs      r0,r0,#4
.   448  000002580      09006  str       r0,[sp,#24]
      INC(dpos)
    UNTIL dpos = 8;
.   450  000002582      09800  ldr       r0,[sp]
.   452  000002584      03001  adds      r0,#1
.   454  000002586      09000  str       r0,[sp]
.   456  000002588      09800  ldr       r0,[sp]
.   458  00000258A      02808  cmp       r0,#8
.   460  00000258C  0F47FAFD7  bne.w     -82 -> 382
    DEC(dpos); spos := 0;
.   464  000002590      09800  ldr       r0,[sp]
.   466  000002592      03801  subs      r0,#1
.   468  000002594      09000  str       r0,[sp]
.   470  000002596      02000  movs      r0,#0
.   472  000002598      09001  str       r0,[sp,#4]
    WHILE dpos >= 0 DO
.   474  00000259A      09800  ldr       r0,[sp]
.   476  00000259C      02800  cmp       r0,#0
.   478  00000259E  0F2C0801A  blt.w     52 -> 534
      str[spos] := digits[dpos];
.   482  0000025A2      09801  ldr       r0,[sp,#4]
.   484  0000025A4      09908  ldr       r1,[sp,#32]
.   486  0000025A6      04288  cmp       r0,r1
.   488  0000025A8      0D301  bcc.n     2 -> 494
.   490  0000025AA      0DF01  svc       1
.   492  0000025AC      0005C  <LineNo: 92>
.   494  0000025AE      09907  ldr       r1,[sp,#28]
.   496  0000025B0  0EB100001  adds.w    r0,r0,r1
.   500  0000025B4      09900  ldr       r1,[sp]
.   502  0000025B6      0290A  cmp       r1,#10
.   504  0000025B8      0D301  bcc.n     2 -> 510
.   506  0000025BA      0DF01  svc       1
.   508  0000025BC      0005C  <LineNo: 92>
.   510  0000025BE  0EB1D0101  adds.w    r1,sp,r1
.   514  0000025C2      07B09  ldrb      r1,[r1,#12]
.   516  0000025C4      07001  strb      r1,[r0]
      DEC(dpos); INC(spos)
.   518  0000025C6      09800  ldr       r0,[sp]
.   520  0000025C8      03801  subs      r0,#1
.   522  0000025CA      09000  str       r0,[sp]
    END;
.   524  0000025CC      09801  ldr       r0,[sp,#4]
.   526  0000025CE      03001  adds      r0,#1
.   528  0000025D0      09001  str       r0,[sp,#4]
.   530  0000025D2  0F7FFBFE2  b.w       -60 -> 474
    str[8] := "H";
.   534  0000025D6      02008  movs      r0,#8
.   536  0000025D8      09908  ldr       r1,[sp,#32]
.   538  0000025DA      04288  cmp       r0,r1
.   540  0000025DC      0D301  bcc.n     2 -> 546
.   542  0000025DE      0DF01  svc       1
.   544  0000025E0      0005F  <LineNo: 95>
.   546  0000025E2      09907  ldr       r1,[sp,#28]
.   548  0000025E4  0EB100001  adds.w    r0,r0,r1
.   552  0000025E8      02148  movs      r1,#72
.   554  0000025EA      07001  strb      r1,[r0]
    str[9] := 0X;
.   556  0000025EC      02009  movs      r0,#9
.   558  0000025EE      09908  ldr       r1,[sp,#32]
.   560  0000025F0      04288  cmp       r0,r1
.   562  0000025F2      0D301  bcc.n     2 -> 568
.   564  0000025F4      0DF01  svc       1
.   566  0000025F6      00060  <LineNo: 96>
.   568  0000025F8      09907  ldr       r1,[sp,#28]
.   570  0000025FA  0EB100001  adds.w    r0,r0,r1
.   574  0000025FE      02100  movs      r1,#0
.   576  000002600      07001  strb      r1,[r0]
    slen := 9
  END IntToHexString;
.   578  000002602      02009  movs      r0,#9
.   580  000002604      09909  ldr       r1,[sp,#36]
.   582  000002606      06008  str       r0,[r1]
.   584  000002608      0B00A  add       sp,#40
.   586  00000260A      0BD00  pop       { pc }


  PROCEDURE IntToBinString*(int: INTEGER; VAR str: ARRAY OF CHAR; VAR slen: INTEGER);
    VAR
      i, j, k: INTEGER;
      bits: SET;
  BEGIN
.   588  00000260C      0B50F  push      { r0, r1, r2, r3, lr }
.   590  00000260E      0B084  sub       sp,#16
    ASSERT(LEN(str) >= 36, Errors.PreCond);
.   592  000002610      09806  ldr       r0,[sp,#24]
.   594  000002612      02824  cmp       r0,#36
.   596  000002614      0DA01  bge.n     2 -> 602
.   598  000002616      0DF22  svc       34
.   600  000002618      0006A  <LineNo: 106>
    k := 0;
.   602  00000261A      02000  movs      r0,#0
.   604  00000261C      09002  str       r0,[sp,#8]
    FOR i := 0 TO 3 DO
.   606  00000261E      02000  movs      r0,#0
.   608  000002620      09000  str       r0,[sp]
      bits := BITS(BFX(int, 31, 24));
.   610  000002622      09800  ldr       r0,[sp]
.   612  000002624      02803  cmp       r0,#3
.   614  000002626  0F3008048  bgt.w     144 -> 762
.   618  00000262A      09804  ldr       r0,[sp,#16]
.   620  00000262C  0F3C06007  ubfx      r0,r0,24,8
.   624  000002630      09003  str       r0,[sp,#12]
      int := LSL(int, 8);
.   626  000002632      09804  ldr       r0,[sp,#16]
.   628  000002634      00200  lsls      r0,r0,#8
.   630  000002636      09004  str       r0,[sp,#16]
      FOR j := 7 TO 0 BY -1 DO
.   632  000002638      02007  movs      r0,#7
.   634  00000263A      09001  str       r0,[sp,#4]
        IF j IN bits THEN str[k] := "1" ELSE str[k] := "0" END;
.   636  00000263C      09801  ldr       r0,[sp,#4]
.   638  00000263E      02800  cmp       r0,#0
.   640  000002640  0F2C08028  blt.w     80 -> 724
.   644  000002644      09803  ldr       r0,[sp,#12]
.   646  000002646      09901  ldr       r1,[sp,#4]
.   648  000002648      02201  movs      r2,#1
.   650  00000264A      0408A  lsls      r2,r1
.   652  00000264C  0EA100F02  tst.w     r0,r2
.   656  000002650  0F000800D  beq.w     26 -> 686
.   660  000002654      09802  ldr       r0,[sp,#8]
.   662  000002656      09906  ldr       r1,[sp,#24]
.   664  000002658      04288  cmp       r0,r1
.   666  00000265A      0D301  bcc.n     2 -> 672
.   668  00000265C      0DF01  svc       1
.   670  00000265E      00070  <LineNo: 112>
.   672  000002660      09905  ldr       r1,[sp,#20]
.   674  000002662  0EB100001  adds.w    r0,r0,r1
.   678  000002666      02131  movs      r1,#49
.   680  000002668      07001  strb      r1,[r0]
.   682  00000266A  0F000B80B  b.w       22 -> 708
.   686  00000266E      09802  ldr       r0,[sp,#8]
.   688  000002670      09906  ldr       r1,[sp,#24]
.   690  000002672      04288  cmp       r0,r1
.   692  000002674      0D301  bcc.n     2 -> 698
.   694  000002676      0DF01  svc       1
.   696  000002678      00070  <LineNo: 112>
.   698  00000267A      09905  ldr       r1,[sp,#20]
.   700  00000267C  0EB100001  adds.w    r0,r0,r1
.   704  000002680      02130  movs      r1,#48
.   706  000002682      07001  strb      r1,[r0]
        INC(k)
      END;
.   708  000002684      09802  ldr       r0,[sp,#8]
.   710  000002686      03001  adds      r0,#1
.   712  000002688      09002  str       r0,[sp,#8]
.   714  00000268A      09801  ldr       r0,[sp,#4]
.   716  00000268C      03801  subs      r0,#1
.   718  00000268E      09001  str       r0,[sp,#4]
.   720  000002690  0F7FFBFD4  b.w       -88 -> 636
      str[k] := " ";
.   724  000002694      09802  ldr       r0,[sp,#8]
.   726  000002696      09906  ldr       r1,[sp,#24]
.   728  000002698      04288  cmp       r0,r1
.   730  00000269A      0D301  bcc.n     2 -> 736
.   732  00000269C      0DF01  svc       1
.   734  00000269E      00073  <LineNo: 115>
.   736  0000026A0      09905  ldr       r1,[sp,#20]
.   738  0000026A2  0EB100001  adds.w    r0,r0,r1
.   742  0000026A6      02120  movs      r1,#32
.   744  0000026A8      07001  strb      r1,[r0]
      INC(k)
    END;
.   746  0000026AA      09802  ldr       r0,[sp,#8]
.   748  0000026AC      03001  adds      r0,#1
.   750  0000026AE      09002  str       r0,[sp,#8]
.   752  0000026B0      09800  ldr       r0,[sp]
.   754  0000026B2      03001  adds      r0,#1
.   756  0000026B4      09000  str       r0,[sp]
.   758  0000026B6  0F7FFBFB4  b.w       -152 -> 610
    str[35] := 0X;
.   762  0000026BA      02023  movs      r0,#35
.   764  0000026BC      09906  ldr       r1,[sp,#24]
.   766  0000026BE      04288  cmp       r0,r1
.   768  0000026C0      0D301  bcc.n     2 -> 774
.   770  0000026C2      0DF01  svc       1
.   772  0000026C4      00076  <LineNo: 118>
.   774  0000026C6      09905  ldr       r1,[sp,#20]
.   776  0000026C8  0EB100001  adds.w    r0,r0,r1
.   780  0000026CC      02100  movs      r1,#0
.   782  0000026CE      07001  strb      r1,[r0]
    slen := 35
  END IntToBinString;
.   784  0000026D0      02023  movs      r0,#35
.   786  0000026D2      09907  ldr       r1,[sp,#28]
.   788  0000026D4      06008  str       r0,[r1]
.   790  0000026D6      0B008  add       sp,#32
.   792  0000026D8      0BD00  pop       { pc }
.   794  0000026DA      0BF00  nop       

  (* write *)

  PROCEDURE Write*(W: TextIO.Writer; ch: CHAR);
    VAR s: ARRAY 1 OF CHAR;
  BEGIN
.   796  0000026DC      0B503  push      { r0, r1, lr }
.   798  0000026DE      0B081  sub       sp,#4
    s[0] := ch;
.   800  0000026E0  0F89D0008  ldrb.w    r0,[sp,#8]
.   804  0000026E4  0F88D0000  strb.w    r0,[sp]
    W.putString(W.dev, s, 1)
.   808  0000026E8      09801  ldr       r0,[sp,#4]
.   810  0000026EA      06800  ldr       r0,[r0]
.   812  0000026EC      04669  mov       r1,sp
.   814  0000026EE      02201  movs      r2,#1
.   816  0000026F0      02301  movs      r3,#1
  END Write;
.   818  0000026F2      09C01  ldr       r4,[sp,#4]
.   820  0000026F4      06864  ldr       r4,[r4,#4]
.   822  0000026F6  0F1B40F00  cmp.w     r4,#0
.   826  0000026FA      0D101  bne.n     2 -> 832
.   828  0000026FC      0DF05  svc       5
.   830  0000026FE      00080  <LineNo: 128>
.   832  000002700      03401  adds      r4,#1
.   834  000002702      047A0  blx       r4
.   836  000002704      0E000  b         0 -> 840
.   838  000002706      00080  <LineNo: 128>
.   840  000002708      0B003  add       sp,#12
.   842  00000270A      0BD00  pop       { pc }


  PROCEDURE WriteString*(W: TextIO.Writer; str: ARRAY OF CHAR);
    VAR i: INTEGER;
  BEGIN
.   844  00000270C      0B507  push      { r0, r1, r2, lr }
.   846  00000270E      0B081  sub       sp,#4
    i := 0;
.   848  000002710      02000  movs      r0,#0
.   850  000002712      09000  str       r0,[sp]
    WHILE (i < LEN(str)) & (str[i] # 0X) DO INC(i) END;
.   852  000002714      09800  ldr       r0,[sp]
.   854  000002716      09903  ldr       r1,[sp,#12]
.   856  000002718      04288  cmp       r0,r1
.   858  00000271A  0F2808012  bge.w     36 -> 898
.   862  00000271E      09800  ldr       r0,[sp]
.   864  000002720      09903  ldr       r1,[sp,#12]
.   866  000002722      04288  cmp       r0,r1
.   868  000002724      0D301  bcc.n     2 -> 874
.   870  000002726      0DF01  svc       1
.   872  000002728      00088  <LineNo: 136>
.   874  00000272A      09902  ldr       r1,[sp,#8]
.   876  00000272C  0EB100001  adds.w    r0,r0,r1
.   880  000002730      07800  ldrb      r0,[r0]
.   882  000002732      02800  cmp       r0,#0
.   884  000002734  0F0008005  beq.w     10 -> 898
.   888  000002738      09800  ldr       r0,[sp]
.   890  00000273A      03001  adds      r0,#1
.   892  00000273C      09000  str       r0,[sp]
.   894  00000273E  0F7FFBFE9  b.w       -46 -> 852
    W.putString(W.dev, str, i)
.   898  000002742      09801  ldr       r0,[sp,#4]
.   900  000002744      06800  ldr       r0,[r0]
.   902  000002746      09902  ldr       r1,[sp,#8]
.   904  000002748      09A03  ldr       r2,[sp,#12]
.   906  00000274A      09B00  ldr       r3,[sp]
  END WriteString;
.   908  00000274C      09C01  ldr       r4,[sp,#4]
.   910  00000274E      06864  ldr       r4,[r4,#4]
.   912  000002750  0F1B40F00  cmp.w     r4,#0
.   916  000002754      0D101  bne.n     2 -> 922
.   918  000002756      0DF05  svc       5
.   920  000002758      00089  <LineNo: 137>
.   922  00000275A      03401  adds      r4,#1
.   924  00000275C      047A0  blx       r4
.   926  00000275E      0E000  b         0 -> 930
.   928  000002760      00089  <LineNo: 137>
.   930  000002762      0B004  add       sp,#16
.   932  000002764      0BD00  pop       { pc }
.   934  000002766      0BF00  nop       


  PROCEDURE WriteLn*(W: TextIO.Writer);
  BEGIN
.   936  000002768      0B501  push      { r0, lr }
    W.putString(W.dev, eol, 2)
.   938  00000276A      09800  ldr       r0,[sp]
.   940  00000276C      06800  ldr       r0,[r0]
.   942  00000276E  0F8DF1020  ldr.w     r1,[pc,#32] -> 976
.   946  000002772      02202  movs      r2,#2
.   948  000002774      02302  movs      r3,#2
  END WriteLn;
.   950  000002776      09C00  ldr       r4,[sp]
.   952  000002778      06864  ldr       r4,[r4,#4]
.   954  00000277A  0F1B40F00  cmp.w     r4,#0
.   958  00000277E      0D101  bne.n     2 -> 964
.   960  000002780      0DF05  svc       5
.   962  000002782      0008F  <LineNo: 143>
.   964  000002784      03401  adds      r4,#1
.   966  000002786      047A0  blx       r4
.   968  000002788      0E000  b         0 -> 972
.   970  00000278A      0008F  <LineNo: 143>
.   972  00000278C      0B001  add       sp,#4
.   974  00000278E      0BD00  pop       { pc }
.   976  000002790  020027ED0  <Global: Texts data>


  PROCEDURE writeNumString(W: TextIO.Writer; str: ARRAY OF CHAR; numChars, leftPadding: INTEGER);
  BEGIN
.   980  000002794      0B51F  push      { r0, r1, r2, r3, r4, lr }
    IF leftPadding > MaxBlanks THEN leftPadding := MaxBlanks END;
.   982  000002796      09804  ldr       r0,[sp,#16]
.   984  000002798      02820  cmp       r0,#32
.   986  00000279A  0F3408002  ble.w     4 -> 994
.   990  00000279E      02020  movs      r0,#32
.   992  0000027A0      09004  str       r0,[sp,#16]
    IF leftPadding > 0 THEN
.   994  0000027A2      09804  ldr       r0,[sp,#16]
.   996  0000027A4      02800  cmp       r0,#0
.   998  0000027A6  0F3408013  ble.w     38 -> 1040
      W.putString(W.dev, Blanks, leftPadding)
.  1002  0000027AA      09800  ldr       r0,[sp]
.  1004  0000027AC      06800  ldr       r0,[r0]
.  1006  0000027AE      0BF00  nop       
.  1008  0000027B0      0467A  mov       r2,pc
.  1010  0000027B2  0F5B2717C  subs.w    r1,r2,#1008
.  1014  0000027B6      02221  movs      r2,#33
.  1016  0000027B8      09B04  ldr       r3,[sp,#16]
    END;
.  1018  0000027BA      09C00  ldr       r4,[sp]
.  1020  0000027BC      06864  ldr       r4,[r4,#4]
.  1022  0000027BE  0F1B40F00  cmp.w     r4,#0
.  1026  0000027C2      0D101  bne.n     2 -> 1032
.  1028  0000027C4      0DF05  svc       5
.  1030  0000027C6      00097  <LineNo: 151>
.  1032  0000027C8      03401  adds      r4,#1
.  1034  0000027CA      047A0  blx       r4
.  1036  0000027CC      0E000  b         0 -> 1040
.  1038  0000027CE      00097  <LineNo: 151>
    W.putString(W.dev, str, numChars)
.  1040  0000027D0      09800  ldr       r0,[sp]
.  1042  0000027D2      06800  ldr       r0,[r0]
.  1044  0000027D4      09901  ldr       r1,[sp,#4]
.  1046  0000027D6      09A02  ldr       r2,[sp,#8]
.  1048  0000027D8      09B03  ldr       r3,[sp,#12]
  END writeNumString;
.  1050  0000027DA      09C00  ldr       r4,[sp]
.  1052  0000027DC      06864  ldr       r4,[r4,#4]
.  1054  0000027DE  0F1B40F00  cmp.w     r4,#0
.  1058  0000027E2      0D101  bne.n     2 -> 1064
.  1060  0000027E4      0DF05  svc       5
.  1062  0000027E6      00099  <LineNo: 153>
.  1064  0000027E8      03401  adds      r4,#1
.  1066  0000027EA      047A0  blx       r4
.  1068  0000027EC      0E000  b         0 -> 1072
.  1070  0000027EE      00099  <LineNo: 153>
.  1072  0000027F0      0B005  add       sp,#20
.  1074  0000027F2      0BD00  pop       { pc }


  PROCEDURE WriteInt*(W: TextIO.Writer; int, width: INTEGER);
    VAR buffer: ARRAY 12 OF CHAR; strLen: INTEGER;
  BEGIN
.  1076  0000027F4      0B507  push      { r0, r1, r2, lr }
.  1078  0000027F6      0B084  sub       sp,#16
    IntToString(int, buffer, strLen);
.  1080  0000027F8      09805  ldr       r0,[sp,#20]
.  1082  0000027FA      04669  mov       r1,sp
.  1084  0000027FC      0220C  movs      r2,#12
.  1086  0000027FE  0F11D030C  adds.w    r3,sp,#12
.  1090  000002802  0F7FFFDF1  bl.w      -1054 -> 40
.  1094  000002806      0E000  b         0 -> 1098
.  1096  000002808      000A0  <LineNo: 160>
    writeNumString(W, buffer, strLen, width - strLen)
.  1098  00000280A      09804  ldr       r0,[sp,#16]
.  1100  00000280C      04669  mov       r1,sp
.  1102  00000280E      0220C  movs      r2,#12
.  1104  000002810      09B03  ldr       r3,[sp,#12]
.  1106  000002812      09C06  ldr       r4,[sp,#24]
.  1108  000002814      09D03  ldr       r5,[sp,#12]
.  1110  000002816  0EBA40405  sub.w     r4,r4,r5
  END WriteInt;
.  1114  00000281A  0F7FFFFBB  bl.w      -138 -> 980
.  1118  00000281E      0E000  b         0 -> 1122
.  1120  000002820      000A1  <LineNo: 161>
.  1122  000002822      0B007  add       sp,#28
.  1124  000002824      0BD00  pop       { pc }
.  1126  000002826      0BF00  nop       


  PROCEDURE WriteHex*(W: TextIO.Writer; int, width: INTEGER);
    VAR buffer: ARRAY 12 OF CHAR; strLen: INTEGER;
  BEGIN
.  1128  000002828      0B507  push      { r0, r1, r2, lr }
.  1130  00000282A      0B084  sub       sp,#16
    IntToHexString(int, buffer, strLen);
.  1132  00000282C      09805  ldr       r0,[sp,#20]
.  1134  00000282E      04669  mov       r1,sp
.  1136  000002830      0220C  movs      r2,#12
.  1138  000002832  0F11D030C  adds.w    r3,sp,#12
.  1142  000002836  0F7FFFE79  bl.w      -782 -> 364
.  1146  00000283A      0E000  b         0 -> 1150
.  1148  00000283C      000A8  <LineNo: 168>
    writeNumString(W, buffer, strLen, width - strLen)
.  1150  00000283E      09804  ldr       r0,[sp,#16]
.  1152  000002840      04669  mov       r1,sp
.  1154  000002842      0220C  movs      r2,#12
.  1156  000002844      09B03  ldr       r3,[sp,#12]
.  1158  000002846      09C06  ldr       r4,[sp,#24]
.  1160  000002848      09D03  ldr       r5,[sp,#12]
.  1162  00000284A  0EBA40405  sub.w     r4,r4,r5
  END WriteHex;
.  1166  00000284E  0F7FFFFA1  bl.w      -190 -> 980
.  1170  000002852      0E000  b         0 -> 1174
.  1172  000002854      000A9  <LineNo: 169>
.  1174  000002856      0B007  add       sp,#28
.  1176  000002858      0BD00  pop       { pc }
.  1178  00000285A      0BF00  nop       


  PROCEDURE WriteBin*(W: TextIO.Writer; int, width: INTEGER);
    VAR buffer: ARRAY 36 OF CHAR; strLen: INTEGER;
  BEGIN
.  1180  00000285C      0B507  push      { r0, r1, r2, lr }
.  1182  00000285E      0B08A  sub       sp,#40
    IntToBinString(int, buffer, strLen);
.  1184  000002860      0980B  ldr       r0,[sp,#44]
.  1186  000002862      04669  mov       r1,sp
.  1188  000002864      02224  movs      r2,#36
.  1190  000002866  0F11D0324  adds.w    r3,sp,#36
.  1194  00000286A  0F7FFFECF  bl.w      -610 -> 588
.  1198  00000286E      0E000  b         0 -> 1202
.  1200  000002870      000B0  <LineNo: 176>
    writeNumString(W, buffer, strLen, width - strLen)
.  1202  000002872      0980A  ldr       r0,[sp,#40]
.  1204  000002874      04669  mov       r1,sp
.  1206  000002876      02224  movs      r2,#36
.  1208  000002878      09B09  ldr       r3,[sp,#36]
.  1210  00000287A      09C0C  ldr       r4,[sp,#48]
.  1212  00000287C      09D09  ldr       r5,[sp,#36]
.  1214  00000287E  0EBA40405  sub.w     r4,r4,r5
  END WriteBin;
.  1218  000002882  0F7FFFF87  bl.w      -242 -> 980
.  1222  000002886      0E000  b         0 -> 1226
.  1224  000002888      000B1  <LineNo: 177>
.  1226  00000288A      0B00D  add       sp,#52
.  1228  00000288C      0BD00  pop       { pc }
.  1230  00000288E      0BF00  nop       

  (* read conversions *)

  PROCEDURE cleanLeft(str: ARRAY OF CHAR; VAR first: INTEGER; VAR neg: BOOLEAN);
    VAR ch: CHAR;
  BEGIN
.  1232  000002890      0B50F  push      { r0, r1, r2, r3, lr }
.  1234  000002892      0B081  sub       sp,#4
    first := 0;
.  1236  000002894      02000  movs      r0,#0
.  1238  000002896      09903  ldr       r1,[sp,#12]
.  1240  000002898      06008  str       r0,[r1]
    WHILE str[first] = " " DO INC(first) END;
.  1242  00000289A      09803  ldr       r0,[sp,#12]
.  1244  00000289C      06800  ldr       r0,[r0]
.  1246  00000289E      09902  ldr       r1,[sp,#8]
.  1248  0000028A0      04288  cmp       r0,r1
.  1250  0000028A2      0D301  bcc.n     2 -> 1256
.  1252  0000028A4      0DF01  svc       1
.  1254  0000028A6      000BA  <LineNo: 186>
.  1256  0000028A8      09901  ldr       r1,[sp,#4]
.  1258  0000028AA  0EB100001  adds.w    r0,r0,r1
.  1262  0000028AE      07800  ldrb      r0,[r0]
.  1264  0000028B0      02820  cmp       r0,#32
.  1266  0000028B2  0F0408006  bne.w     12 -> 1282
.  1270  0000028B6      09803  ldr       r0,[sp,#12]
.  1272  0000028B8      06801  ldr       r1,[r0]
.  1274  0000028BA      03101  adds      r1,#1
.  1276  0000028BC      06001  str       r1,[r0]
.  1278  0000028BE  0F7FFBFEC  b.w       -40 -> 1242
    ch := str[first];
.  1282  0000028C2      09803  ldr       r0,[sp,#12]
.  1284  0000028C4      06800  ldr       r0,[r0]
.  1286  0000028C6      09902  ldr       r1,[sp,#8]
.  1288  0000028C8      04288  cmp       r0,r1
.  1290  0000028CA      0D301  bcc.n     2 -> 1296
.  1292  0000028CC      0DF01  svc       1
.  1294  0000028CE      000BB  <LineNo: 187>
.  1296  0000028D0      09901  ldr       r1,[sp,#4]
.  1298  0000028D2  0EB100001  adds.w    r0,r0,r1
.  1302  0000028D6      07800  ldrb      r0,[r0]
.  1304  0000028D8  0F88D0000  strb.w    r0,[sp]
    neg := ch = "-";
.  1308  0000028DC  0F89D0000  ldrb.w    r0,[sp]
.  1312  0000028E0      0282D  cmp       r0,#45
.  1314  0000028E2      0BF0C  ite       eq
.  1316  0000028E4  0F04F0001  moveq.w   r0,#1
.  1320  0000028E8  0F04F0000  movne.w   r0,#0
.  1324  0000028EC      09904  ldr       r1,[sp,#16]
.  1326  0000028EE      07008  strb      r0,[r1]
    IF (ch = "-") OR (ch = "+") THEN INC(first) END;
.  1328  0000028F0  0F89D0000  ldrb.w    r0,[sp]
.  1332  0000028F4      0282D  cmp       r0,#45
.  1334  0000028F6  0F0008005  beq.w     10 -> 1348
.  1338  0000028FA  0F89D0000  ldrb.w    r0,[sp]
.  1342  0000028FE      0282B  cmp       r0,#43
.  1344  000002900  0F0408004  bne.w     8 -> 1356
.  1348  000002904      09803  ldr       r0,[sp,#12]
.  1350  000002906      06801  ldr       r1,[r0]
.  1352  000002908      03101  adds      r1,#1
.  1354  00000290A      06001  str       r1,[r0]
    WHILE str[first] = " " DO INC(first) END;
.  1356  00000290C      09803  ldr       r0,[sp,#12]
.  1358  00000290E      06800  ldr       r0,[r0]
.  1360  000002910      09902  ldr       r1,[sp,#8]
.  1362  000002912      04288  cmp       r0,r1
.  1364  000002914      0D301  bcc.n     2 -> 1370
.  1366  000002916      0DF01  svc       1
.  1368  000002918      000BE  <LineNo: 190>
.  1370  00000291A      09901  ldr       r1,[sp,#4]
.  1372  00000291C  0EB100001  adds.w    r0,r0,r1
.  1376  000002920      07800  ldrb      r0,[r0]
.  1378  000002922      02820  cmp       r0,#32
.  1380  000002924  0F0408006  bne.w     12 -> 1396
.  1384  000002928      09803  ldr       r0,[sp,#12]
.  1386  00000292A      06801  ldr       r1,[r0]
.  1388  00000292C      03101  adds      r1,#1
.  1390  00000292E      06001  str       r1,[r0]
.  1392  000002930  0F7FFBFEC  b.w       -40 -> 1356
    WHILE str[first] = "0" DO INC(first) END;
.  1396  000002934      09803  ldr       r0,[sp,#12]
.  1398  000002936      06800  ldr       r0,[r0]
.  1400  000002938      09902  ldr       r1,[sp,#8]
.  1402  00000293A      04288  cmp       r0,r1
.  1404  00000293C      0D301  bcc.n     2 -> 1410
.  1406  00000293E      0DF01  svc       1
.  1408  000002940      000BF  <LineNo: 191>
.  1410  000002942      09901  ldr       r1,[sp,#4]
.  1412  000002944  0EB100001  adds.w    r0,r0,r1
.  1416  000002948      07800  ldrb      r0,[r0]
.  1418  00000294A      02830  cmp       r0,#48
.  1420  00000294C  0F0408006  bne.w     12 -> 1436
.  1424  000002950      09803  ldr       r0,[sp,#12]
.  1426  000002952      06801  ldr       r1,[r0]
.  1428  000002954      03101  adds      r1,#1
.  1430  000002956      06001  str       r1,[r0]
.  1432  000002958  0F7FFBFEC  b.w       -40 -> 1396
  END cleanLeft;
.  1436  00000295C      0B005  add       sp,#20
.  1438  00000295E      0BD00  pop       { pc }

  PROCEDURE cleanRight(str: ARRAY OF CHAR; numCh: INTEGER; VAR last: INTEGER);
  BEGIN
.  1440  000002960      0B50F  push      { r0, r1, r2, r3, lr }
    last := numCh - 1;
.  1442  000002962      09802  ldr       r0,[sp,#8]
.  1444  000002964      03801  subs      r0,#1
.  1446  000002966      09903  ldr       r1,[sp,#12]
.  1448  000002968      06008  str       r0,[r1]
    WHILE str[last] = " " DO
.  1450  00000296A      09803  ldr       r0,[sp,#12]
.  1452  00000296C      06800  ldr       r0,[r0]
.  1454  00000296E      09901  ldr       r1,[sp,#4]
.  1456  000002970      04288  cmp       r0,r1
.  1458  000002972      0D301  bcc.n     2 -> 1464
.  1460  000002974      0DF01  svc       1
.  1462  000002976      000C5  <LineNo: 197>
.  1464  000002978      09900  ldr       r1,[sp]
.  1466  00000297A  0EB100001  adds.w    r0,r0,r1
.  1470  00000297E      07800  ldrb      r0,[r0]
.  1472  000002980      02820  cmp       r0,#32
.  1474  000002982  0F0408006  bne.w     12 -> 1490
      DEC(last)
    END
.  1478  000002986      09803  ldr       r0,[sp,#12]
.  1480  000002988      06801  ldr       r1,[r0]
.  1482  00000298A      03901  subs      r1,#1
.  1484  00000298C      06001  str       r1,[r0]
.  1486  00000298E  0F7FFBFEC  b.w       -40 -> 1450
  END cleanRight;
.  1490  000002992      0B004  add       sp,#16
.  1492  000002994      0BD00  pop       { pc }
.  1494  000002996      0BF00  nop       


  PROCEDURE StrToInt*(str: ARRAY OF CHAR; numCh: INTEGER; VAR int: INTEGER; VAR res: INTEGER);
  (* rolls over at 0100000000H = 2^32 *)
    VAR first, last, digit: INTEGER; neg: BOOLEAN; ch: CHAR;
  BEGIN
.  1496  000002998      0B51F  push      { r0, r1, r2, r3, r4, lr }
.  1498  00000299A      0B084  sub       sp,#16
    res := NoError;
.  1500  00000299C      02000  movs      r0,#0
.  1502  00000299E      09908  ldr       r1,[sp,#32]
.  1504  0000029A0      06008  str       r0,[r1]
    cleanLeft(str, first, neg);
.  1506  0000029A2      09804  ldr       r0,[sp,#16]
.  1508  0000029A4      09905  ldr       r1,[sp,#20]
.  1510  0000029A6      0466A  mov       r2,sp
.  1512  0000029A8  0F11D030C  adds.w    r3,sp,#12
.  1516  0000029AC  0F7FFFF70  bl.w      -288 -> 1232
.  1520  0000029B0      0E000  b         0 -> 1524
.  1522  0000029B2      000D0  <LineNo: 208>
    IF numCh - first > MaxIntDigits THEN
.  1524  0000029B4      09806  ldr       r0,[sp,#24]
.  1526  0000029B6      09900  ldr       r1,[sp]
.  1528  0000029B8  0EBA00001  sub.w     r0,r0,r1
.  1532  0000029BC      0280A  cmp       r0,#10
.  1534  0000029BE  0F3408003  ble.w     6 -> 1544
      res := OutOfLimits;
.  1538  0000029C2      02003  movs      r0,#3
.  1540  0000029C4      09908  ldr       r1,[sp,#32]
.  1542  0000029C6      06008  str       r0,[r1]
    END;
    IF res = NoError THEN
.  1544  0000029C8      09808  ldr       r0,[sp,#32]
.  1546  0000029CA      06800  ldr       r0,[r0]
.  1548  0000029CC      02800  cmp       r0,#0
.  1550  0000029CE  0F0408060  bne.w     192 -> 1746
      cleanRight(str, numCh, last);
.  1554  0000029D2      09804  ldr       r0,[sp,#16]
.  1556  0000029D4      09905  ldr       r1,[sp,#20]
.  1558  0000029D6      09A06  ldr       r2,[sp,#24]
.  1560  0000029D8  0F11D0304  adds.w    r3,sp,#4
.  1564  0000029DC  0F7FFFFC0  bl.w      -128 -> 1440
.  1568  0000029E0      0E000  b         0 -> 1572
.  1570  0000029E2      000D5  <LineNo: 213>
      int := 0;
.  1572  0000029E4      02000  movs      r0,#0
.  1574  0000029E6      09907  ldr       r1,[sp,#28]
.  1576  0000029E8      06008  str       r0,[r1]
      WHILE (first <= last) & (res = NoError) DO
.  1578  0000029EA      09800  ldr       r0,[sp]
.  1580  0000029EC      09901  ldr       r1,[sp,#4]
.  1582  0000029EE      04288  cmp       r0,r1
.  1584  0000029F0  0F300804F  bgt.w     158 -> 1746
.  1588  0000029F4      09808  ldr       r0,[sp,#32]
.  1590  0000029F6      06800  ldr       r0,[r0]
.  1592  0000029F8      02800  cmp       r0,#0
.  1594  0000029FA  0F040804A  bne.w     148 -> 1746
        ch := str[first];
.  1598  0000029FE      09800  ldr       r0,[sp]
.  1600  000002A00      09905  ldr       r1,[sp,#20]
.  1602  000002A02      04288  cmp       r0,r1
.  1604  000002A04      0D301  bcc.n     2 -> 1610
.  1606  000002A06      0DF01  svc       1
.  1608  000002A08      000D8  <LineNo: 216>
.  1610  000002A0A      09904  ldr       r1,[sp,#16]
.  1612  000002A0C  0EB100001  adds.w    r0,r0,r1
.  1616  000002A10      07800  ldrb      r0,[r0]
.  1618  000002A12  0F88D000D  strb.w    r0,[sp,#13]
        IF (ch < "0") OR (ch > "9") THEN
.  1622  000002A16  0F89D000D  ldrb.w    r0,[sp,#13]
.  1626  000002A1A      02830  cmp       r0,#48
.  1628  000002A1C  0F2C08005  blt.w     10 -> 1642
.  1632  000002A20  0F89D000D  ldrb.w    r0,[sp,#13]
.  1636  000002A24      02839  cmp       r0,#57
.  1638  000002A26  0F3408005  ble.w     10 -> 1652
          res := SyntaxError;
.  1642  000002A2A      02002  movs      r0,#2
.  1644  000002A2C      09908  ldr       r1,[sp,#32]
.  1646  000002A2E      06008  str       r0,[r1]
        ELSE
          digit := ORD(ch) - ORD("0");
.  1648  000002A30  0F000B82D  b.w       90 -> 1742
.  1652  000002A34  0F89D000D  ldrb.w    r0,[sp,#13]
.  1656  000002A38      03830  subs      r0,#48
.  1658  000002A3A      09002  str       r0,[sp,#8]
          int := (int * 10) + digit;
.  1660  000002A3C      09807  ldr       r0,[sp,#28]
.  1662  000002A3E      06800  ldr       r0,[r0]
.  1664  000002A40      0210A  movs      r1,#10
.  1666  000002A42  0FB00F001  mul.w     r0,r0,r1
.  1670  000002A46      09902  ldr       r1,[sp,#8]
.  1672  000002A48      04408  add       r0,r1
.  1674  000002A4A      09907  ldr       r1,[sp,#28]
.  1676  000002A4C      06008  str       r0,[r1]
          IF MaxInt - int < 0 THEN  (* works across overflow *)
.  1678  000002A4E      09807  ldr       r0,[sp,#28]
.  1680  000002A50      06800  ldr       r0,[r0]
.  1682  000002A52  0F8DF1064  ldr.w     r1,[pc,#100] -> 1784
.  1686  000002A56  0EBC00001  rsb.w     r0,r0,r1
.  1690  000002A5A      02800  cmp       r0,#0
.  1692  000002A5C  0F2808014  bge.w     40 -> 1736
            IF neg & (int = MinInt) THEN
.  1696  000002A60  0F89D000C  ldrb.w    r0,[sp,#12]
.  1700  000002A64  0F0100F01  tst.w     r0,#1
.  1704  000002A68  0F000800B  beq.w     22 -> 1730
.  1708  000002A6C      09807  ldr       r0,[sp,#28]
.  1710  000002A6E      06800  ldr       r0,[r0]
.  1712  000002A70  0F1104F00  cmn.w     r0,#080000000H
.  1716  000002A74  0F0408005  bne.w     10 -> 1730
              neg := FALSE
            ELSE
.  1720  000002A78      02000  movs      r0,#0
.  1722  000002A7A  0F88D000C  strb.w    r0,[sp,#12]
              res := OutOfLimits
.  1726  000002A7E  0F000B803  b.w       6 -> 1736
            END
.  1730  000002A82      02003  movs      r0,#3
.  1732  000002A84      09908  ldr       r1,[sp,#32]
.  1734  000002A86      06008  str       r0,[r1]
          END;
          INC(first)
        END
.  1736  000002A88      09800  ldr       r0,[sp]
.  1738  000002A8A      03001  adds      r0,#1
.  1740  000002A8C      09000  str       r0,[sp]
      END
.  1742  000002A8E  0F7FFBFAC  b.w       -168 -> 1578
    END;
    IF res = NoError THEN
.  1746  000002A92      09808  ldr       r0,[sp,#32]
.  1748  000002A94      06800  ldr       r0,[r0]
.  1750  000002A96      02800  cmp       r0,#0
.  1752  000002A98  0F040800C  bne.w     24 -> 1780
      IF neg THEN int := -int END
.  1756  000002A9C  0F89D000C  ldrb.w    r0,[sp,#12]
.  1760  000002AA0  0F0100F01  tst.w     r0,#1
.  1764  000002AA4  0F0008006  beq.w     12 -> 1780
.  1768  000002AA8      09807  ldr       r0,[sp,#28]
.  1770  000002AAA      06800  ldr       r0,[r0]
.  1772  000002AAC  0F1D00000  rsbs.w    r0,r0,#0
.  1776  000002AB0      09907  ldr       r1,[sp,#28]
.  1778  000002AB2      06008  str       r0,[r1]
    END
  END StrToInt;
.  1780  000002AB4      0B009  add       sp,#36
.  1782  000002AB6      0BD00  pop       { pc }
.  1784  000002AB8  07FFFFFFF  <Const:  2147483647>

  (* read *)

  PROCEDURE ReadString*(R: TextIO.Reader; VAR s: ARRAY OF CHAR; VAR res: INTEGER);
  (**
    Read a string via 'R', terminated by 'TextIO.EOL'.
    Flush the rest of the input in case of buffer overflow.
    The string is truncated to the buffer length, terminated by 0X.
  **)
    VAR numCh: INTEGER;
  BEGIN
.  1788  000002ABC      0B50F  push      { r0, r1, r2, r3, lr }
.  1790  000002ABE      0B081  sub       sp,#4
    R.getString(R.dev, s, numCh, res);
.  1792  000002AC0      09801  ldr       r0,[sp,#4]
.  1794  000002AC2      06800  ldr       r0,[r0]
.  1796  000002AC4      09902  ldr       r1,[sp,#8]
.  1798  000002AC6      09A03  ldr       r2,[sp,#12]
.  1800  000002AC8      0466B  mov       r3,sp
.  1802  000002ACA      09C04  ldr       r4,[sp,#16]
.  1804  000002ACC      09D01  ldr       r5,[sp,#4]
.  1806  000002ACE      0686D  ldr       r5,[r5,#4]
.  1808  000002AD0  0F1B50F00  cmp.w     r5,#0
.  1812  000002AD4      0D101  bne.n     2 -> 1818
.  1814  000002AD6      0DF05  svc       5
.  1816  000002AD8      000F8  <LineNo: 248>
.  1818  000002ADA      03501  adds      r5,#1
.  1820  000002ADC      047A8  blx       r5
.  1822  000002ADE      0E000  b         0 -> 1826
.  1824  000002AE0      000F8  <LineNo: 248>
    IF res = NoError THEN
.  1826  000002AE2      09804  ldr       r0,[sp,#16]
.  1828  000002AE4      06800  ldr       r0,[r0]
.  1830  000002AE6      02800  cmp       r0,#0
.  1832  000002AE8  0F0408007  bne.w     14 -> 1850
      IF numCh = 0 THEN
.  1836  000002AEC      09800  ldr       r0,[sp]
.  1838  000002AEE      02800  cmp       r0,#0
.  1840  000002AF0  0F0408003  bne.w     6 -> 1850
        res := NoInput
      END
.  1844  000002AF4      02004  movs      r0,#4
.  1846  000002AF6      09904  ldr       r1,[sp,#16]
.  1848  000002AF8      06008  str       r0,[r1]
    END
  END ReadString;
.  1850  000002AFA      0B005  add       sp,#20
.  1852  000002AFC      0BD00  pop       { pc }
.  1854  000002AFE      0BF00  nop       


  PROCEDURE ReadInt*(R: TextIO.Reader; VAR int, res: INTEGER);
  (**
    Read an integer in decimal form via 'R', terminated by 'TextIO.EOL'.
    Flush the rest of the input in case of buffer overflow.
    The number is not valid in case of any error.
    As long as there's no buffer overflow or fifo overrrun, any number of leading
    blanks, blanks after the sign, leading zeros, and trailing blanks are permitted.
  **)
    VAR numCh: INTEGER; buf: ARRAY 32 OF CHAR;
  BEGIN
.  1856  000002B00      0B507  push      { r0, r1, r2, lr }
.  1858  000002B02      0B089  sub       sp,#36
    R.getString(R.dev, buf, numCh, res);
.  1860  000002B04      09809  ldr       r0,[sp,#36]
.  1862  000002B06      06800  ldr       r0,[r0]
.  1864  000002B08  0F11D0104  adds.w    r1,sp,#4
.  1868  000002B0C      02220  movs      r2,#32
.  1870  000002B0E      0466B  mov       r3,sp
.  1872  000002B10      09C0B  ldr       r4,[sp,#44]
.  1874  000002B12      09D09  ldr       r5,[sp,#36]
.  1876  000002B14      0686D  ldr       r5,[r5,#4]
.  1878  000002B16  0F1B50F00  cmp.w     r5,#0
.  1882  000002B1A      0D101  bne.n     2 -> 1888
.  1884  000002B1C      0DF05  svc       5
.  1886  000002B1E      0010B  <LineNo: 267>
.  1888  000002B20      03501  adds      r5,#1
.  1890  000002B22      047A8  blx       r5
.  1892  000002B24      0E000  b         0 -> 1896
.  1894  000002B26      0010B  <LineNo: 267>
    IF res = NoError THEN
.  1896  000002B28      0980B  ldr       r0,[sp,#44]
.  1898  000002B2A      06800  ldr       r0,[r0]
.  1900  000002B2C      02800  cmp       r0,#0
.  1902  000002B2E  0F0408013  bne.w     38 -> 1944
      IF numCh > 0 THEN
.  1906  000002B32      09800  ldr       r0,[sp]
.  1908  000002B34      02800  cmp       r0,#0
.  1910  000002B36  0F340800C  ble.w     24 -> 1938
        StrToInt(buf, numCh, int, res)
.  1914  000002B3A  0F11D0004  adds.w    r0,sp,#4
.  1918  000002B3E      02120  movs      r1,#32
.  1920  000002B40      09A00  ldr       r2,[sp]
.  1922  000002B42      09B0A  ldr       r3,[sp,#40]
.  1924  000002B44      09C0B  ldr       r4,[sp,#44]
      ELSE
.  1926  000002B46  0F7FFFF27  bl.w      -434 -> 1496
.  1930  000002B4A      0E000  b         0 -> 1934
.  1932  000002B4C      0010E  <LineNo: 270>
        res := NoInput
.  1934  000002B4E  0F000B803  b.w       6 -> 1944
      END
.  1938  000002B52      02004  movs      r0,#4
.  1940  000002B54      0990B  ldr       r1,[sp,#44]
.  1942  000002B56      06008  str       r0,[r1]
    END
  END ReadInt;
.  1944  000002B58      0B00C  add       sp,#48
.  1946  000002B5A      0BD00  pop       { pc }


  PROCEDURE FlushOut*(W: TextIO.Writer);
  (**
    Allow flushing on writers that don't need it to keep
    program code independent of output channel if needed.
  **)
  BEGIN
.  1948  000002B5C      0B501  push      { r0, lr }
    IF W.flush # NIL THEN
.  1950  000002B5E      09800  ldr       r0,[sp]
.  1952  000002B60      06880  ldr       r0,[r0,#8]
.  1954  000002B62      02800  cmp       r0,#0
.  1956  000002B64  0F000800D  beq.w     26 -> 1986
      W.flush(W.dev)
.  1960  000002B68      09800  ldr       r0,[sp]
.  1962  000002B6A      06800  ldr       r0,[r0]
    END
.  1964  000002B6C      09900  ldr       r1,[sp]
.  1966  000002B6E      06889  ldr       r1,[r1,#8]
.  1968  000002B70  0F1B10F00  cmp.w     r1,#0
.  1972  000002B74      0D101  bne.n     2 -> 1978
.  1974  000002B76      0DF05  svc       5
.  1976  000002B78      0011D  <LineNo: 285>
.  1978  000002B7A      03101  adds      r1,#1
.  1980  000002B7C      04788  blx       r1
.  1982  000002B7E      0E000  b         0 -> 1986
.  1984  000002B80      0011D  <LineNo: 285>
  END FlushOut;
.  1986  000002B82      0B001  add       sp,#4
.  1988  000002B84      0BD00  pop       { pc }
.  1990  000002B86      0BF00  nop       

BEGIN
.  1992  000002B88      0B500  push      { lr }
  eol[0] := CR; eol[1] := LF
.  1994  000002B8A  0F8DF0010  ldr.w     r0,[pc,#16] -> 2012
.  1998  000002B8E      0210D  movs      r1,#13
.  2000  000002B90      07001  strb      r1,[r0]
.  2002  000002B92  0F8DF0008  ldr.w     r0,[pc,#8] -> 2012
END Texts.
.  2006  000002B96      0210A  movs      r1,#10
.  2008  000002B98      07041  strb      r1,[r0,#1]
.  2010  000002B9A      0BD00  pop       { pc }
.  2012  000002B9C  020027ED0  <Global: Texts data>
 