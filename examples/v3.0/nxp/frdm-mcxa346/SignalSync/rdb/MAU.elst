. <tool: Astrobe for RP2350>
. <prog: C:\Users\gray\Projects\oberon\dev\oberon-rtk\examples\v3.0\nxp\frdm-mcxa346\SignalSync\SignalSync.mod>

.     0  0000008E0              <Pad: 0>
MODULE MAU;
  (* =========================================================================
   Astrobe Library Functions for Memory Usage

   Memory Allocation Unit; NW 15.12.2007
   The first two procedures must remain in that order!

  (c) 2012-2024 CFB Software
  https://www.astrobe.com

  ========================================================================= *)

IMPORT LinkOptions, SYSTEM;

TYPE
  Proc* = PROCEDURE (VAR p: INTEGER; T: INTEGER);

VAR
  allocate, deallocate: Proc;
  heapTop, heapLimit: INTEGER;

(* Must be 1st procedure *)
PROCEDURE New*(VAR p: INTEGER; T: INTEGER);
BEGIN
.     4  0000008E4      0B503  push      { r0, r1, lr }
  allocate(p, T)
.     6  0000008E6      09800  ldr       r0,[sp]
.     8  0000008E8      09901  ldr       r1,[sp,#4]
END New;
.    10  0000008EA  0F8DF201C  ldr.w     r2,[pc,#28] -> 40
.    14  0000008EE      06812  ldr       r2,[r2]
.    16  0000008F0  0F1B20F00  cmp.w     r2,#0
.    20  0000008F4      0D101  bne.n     2 -> 26
.    22  0000008F6      0DF05  svc       5
.    24  0000008F8      00019  <LineNo: 25>
.    26  0000008FA      03201  adds      r2,#1
.    28  0000008FC      04790  blx       r2
.    30  0000008FE      0E000  b         0 -> 34
.    32  000000900      00019  <LineNo: 25>
.    34  000000902      0B002  add       sp,#8
.    36  000000904      0BD00  pop       { pc }
.    38  000000906      0BF00  nop       
.    40  000000908  020027FA0  <Global: MAU data>

(* Must be 2nd procedure *)
PROCEDURE Dispose*(VAR p: INTEGER; T: INTEGER);
BEGIN
.    44  00000090C      0B503  push      { r0, r1, lr }
  deallocate(p, T)
.    46  00000090E      09800  ldr       r0,[sp]
.    48  000000910      09901  ldr       r1,[sp,#4]
END Dispose;
.    50  000000912  0F8DF201C  ldr.w     r2,[pc,#28] -> 80
.    54  000000916      06812  ldr       r2,[r2]
.    56  000000918  0F1B20F00  cmp.w     r2,#0
.    60  00000091C      0D101  bne.n     2 -> 66
.    62  00000091E      0DF05  svc       5
.    64  000000920      0001F  <LineNo: 31>
.    66  000000922      03201  adds      r2,#1
.    68  000000924      04790  blx       r2
.    70  000000926      0E000  b         0 -> 74
.    72  000000928      0001F  <LineNo: 31>
.    74  00000092A      0B002  add       sp,#8
.    76  00000092C      0BD00  pop       { pc }
.    78  00000092E      0BF00  nop       
.    80  000000930  020027F9C  <Global: MAU data>

PROCEDURE SetNew*(p: Proc);
BEGIN
.    84  000000934      0B501  push      { r0, lr }
  allocate := p
END SetNew;
.    86  000000936      09800  ldr       r0,[sp]
.    88  000000938  0F8DF1008  ldr.w     r1,[pc,#8] -> 100
.    92  00000093C      06008  str       r0,[r1]
.    94  00000093E      0B001  add       sp,#4
.    96  000000940      0BD00  pop       { pc }
.    98  000000942      0BF00  nop       
.   100  000000944  020027FA0  <Global: MAU data>

PROCEDURE SetDispose*(p: Proc);
BEGIN
.   104  000000948      0B501  push      { r0, lr }
  deallocate := p
END SetDispose;
.   106  00000094A      09800  ldr       r0,[sp]
.   108  00000094C  0F8DF1008  ldr.w     r1,[pc,#8] -> 120
.   112  000000950      06008  str       r0,[r1]
.   114  000000952      0B001  add       sp,#4
.   116  000000954      0BD00  pop       { pc }
.   118  000000956      0BF00  nop       
.   120  000000958  020027F9C  <Global: MAU data>

PROCEDURE Allocate*(VAR p: INTEGER; typeDesc: INTEGER);
(* Allocate record, prefix with typeDesc field of 1 word with offset -4 *)
CONST 
  SP = 13;
VAR
  h, size, limit: INTEGER;
BEGIN
.   124  00000095C      0B503  push      { r0, r1, lr }
.   126  00000095E      0B083  sub       sp,#12
  IF heapLimit = 0 THEN
.   128  000000960  0F8DF0064  ldr.w     r0,[pc,#100] -> 232
.   132  000000964      06800  ldr       r0,[r0]
.   134  000000966      02800  cmp       r0,#0
.   136  000000968  0F0408004  bne.w     8 -> 148
    limit := SYSTEM.REG(SP)
  ELSE
.   140  00000096C      04668  mov       r0,sp
.   142  00000096E      09002  str       r0,[sp,#8]
    limit := heapLimit
.   144  000000970  0F000B804  b.w       8 -> 156
  END;
.   148  000000974  0F8DF0050  ldr.w     r0,[pc,#80] -> 232
.   152  000000978      06800  ldr       r0,[r0]
.   154  00000097A      09002  str       r0,[sp,#8]
  (*obtain record size from type descriptor*)
  SYSTEM.GET(typeDesc, size);
.   156  00000097C      09804  ldr       r0,[sp,#16]
.   158  00000097E      06801  ldr       r1,[r0]
.   160  000000980      09101  str       r1,[sp,#4]
  h := heapTop + 4 + size;
.   162  000000982  0F8DF0048  ldr.w     r0,[pc,#72] -> 236
.   166  000000986      06800  ldr       r0,[r0]
.   168  000000988      03004  adds      r0,#4
.   170  00000098A      09901  ldr       r1,[sp,#4]
.   172  00000098C      04408  add       r0,r1
.   174  00000098E      09000  str       r0,[sp]
  IF h > limit THEN
.   176  000000990      09800  ldr       r0,[sp]
.   178  000000992      09902  ldr       r1,[sp,#8]
.   180  000000994      04288  cmp       r0,r1
.   182  000000996  0F3408005  ble.w     10 -> 196
    p := 0
  ELSE
.   186  00000099A      02000  movs      r0,#0
.   188  00000099C      09903  ldr       r1,[sp,#12]
.   190  00000099E      06008  str       r0,[r1]
    p := heapTop + 4;
.   192  0000009A0  0F000B80F  b.w       30 -> 226
.   196  0000009A4  0F8DF0024  ldr.w     r0,[pc,#36] -> 236
.   200  0000009A8      06800  ldr       r0,[r0]
.   202  0000009AA      03004  adds      r0,#4
.   204  0000009AC      09903  ldr       r1,[sp,#12]
.   206  0000009AE      06008  str       r0,[r1]
    (* Address of type descriptor to tagfield of new record *)
    SYSTEM.PUT(heapTop, typeDesc);
.   208  0000009B0  0F8DF0018  ldr.w     r0,[pc,#24] -> 236
.   212  0000009B4      06800  ldr       r0,[r0]
.   214  0000009B6      09904  ldr       r1,[sp,#16]
.   216  0000009B8      06001  str       r1,[r0]
    heapTop := h
  END
.   218  0000009BA      09800  ldr       r0,[sp]
.   220  0000009BC  0F8DF100C  ldr.w     r1,[pc,#12] -> 236
.   224  0000009C0      06008  str       r0,[r1]
END Allocate;
.   226  0000009C2      0B005  add       sp,#20
.   228  0000009C4      0BD00  pop       { pc }
.   230  0000009C6      0BF00  nop       
.   232  0000009C8  020027F94  <Global: MAU data>
.   236  0000009CC  020027F98  <Global: MAU data>

PROCEDURE Deallocate*(VAR p: INTEGER; typeDesc: INTEGER);
(* Assign NIL to the pointer. Reclaim the space if this was the most
   recent allocation otherwise do nothing. *)
VAR
  h, size: INTEGER;
BEGIN
.   240  0000009D0      0B503  push      { r0, r1, lr }
.   242  0000009D2      0B082  sub       sp,#8
  ASSERT(p # 0, 12);
.   244  0000009D4      09802  ldr       r0,[sp,#8]
.   246  0000009D6      06800  ldr       r0,[r0]
.   248  0000009D8      02800  cmp       r0,#0
.   250  0000009DA      0D101  bne.n     2 -> 256
.   252  0000009DC      0DF0C  svc       12
.   254  0000009DE      0004B  <LineNo: 75>
  (*obtain record size from type descriptor*)
  SYSTEM.GET(typeDesc, size);
.   256  0000009E0      09803  ldr       r0,[sp,#12]
.   258  0000009E2      06801  ldr       r1,[r0]
.   260  0000009E4      09101  str       r1,[sp,#4]
  h := heapTop - size;
.   262  0000009E6  0F8DF002C  ldr.w     r0,[pc,#44] -> 308
.   266  0000009EA      06800  ldr       r0,[r0]
.   268  0000009EC      09901  ldr       r1,[sp,#4]
.   270  0000009EE  0EBA00001  sub.w     r0,r0,r1
.   274  0000009F2      09000  str       r0,[sp]
  IF h = p THEN heapTop := h - 4 END;
.   276  0000009F4      09800  ldr       r0,[sp]
.   278  0000009F6      09902  ldr       r1,[sp,#8]
.   280  0000009F8      06809  ldr       r1,[r1]
.   282  0000009FA      04288  cmp       r0,r1
.   284  0000009FC  0F0408005  bne.w     10 -> 298
.   288  000000A00      09800  ldr       r0,[sp]
.   290  000000A02      03804  subs      r0,#4
.   292  000000A04  0F8DF100C  ldr.w     r1,[pc,#12] -> 308
.   296  000000A08      06008  str       r0,[r1]
  p := 0
END Deallocate;
.   298  000000A0A      02000  movs      r0,#0
.   300  000000A0C      09902  ldr       r1,[sp,#8]
.   302  000000A0E      06008  str       r0,[r1]
.   304  000000A10      0B004  add       sp,#16
.   306  000000A12      0BD00  pop       { pc }
.   308  000000A14  020027F98  <Global: MAU data>

BEGIN
.   312  000000A18      0B500  push      { lr }
  SetNew(Allocate);
.   314  000000A1A      0BF00  nop       
.   316  000000A1C  0F2AF00C4  adr.w     r0,pc,#-196 -> 124
.   320  000000A20  0F7FFFF88  bl.w      -240 -> 84
.   324  000000A24      0E000  b         0 -> 328
.   326  000000A26      00054  <LineNo: 84>
  SetDispose(Deallocate);
.   328  000000A28  0F2AF005C  adr.w     r0,pc,#-92 -> 240
.   332  000000A2C  0F7FFFF8C  bl.w      -232 -> 104
.   336  000000A30      0E000  b         0 -> 340
.   338  000000A32      00055  <LineNo: 85>
  heapTop := LinkOptions.HeapStart;
.   340  000000A34  0F8DF0018  ldr.w     r0,[pc,#24] -> 368
.   344  000000A38      06800  ldr       r0,[r0]
.   346  000000A3A  0F8DF101C  ldr.w     r1,[pc,#28] -> 376
.   350  000000A3E      06008  str       r0,[r1]
  heapLimit := LinkOptions.HeapLimit
END MAU.
.   352  000000A40  0F8DF0010  ldr.w     r0,[pc,#16] -> 372
.   356  000000A44      06800  ldr       r0,[r0]
.   358  000000A46  0F8DF1014  ldr.w     r1,[pc,#20] -> 380
.   362  000000A4A      06008  str       r0,[r1]
.   364  000000A4C      0BD00  pop       { pc }
.   366  000000A4E      0BF00  nop       
.   368  000000A50  020027FF4  <Global: LinkOptions data>
.   372  000000A54  020027FF0  <Global: LinkOptions data>
.   376  000000A58  020027F98  <Global: MAU data>
.   380  000000A5C  020027F94  <Global: MAU data>
 