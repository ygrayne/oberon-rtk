. <tool: Astrobe for RP2350>
. <prog: C:\Users\gray\Projects\oberon\dev\oberon-rtk\examples\v3.0\nxp\frdm-mcxa346\SignalSync\SignalSync.mod>

.     0  000000334              <Pad: 0>
MODULE MCU2;
(**
  Oberon RTK Framework
  Version: v3.0
  --
  MCU register and memory addresses, bits, values, assembly instructions
  --
  MCU: MCX-A346
  --
  Copyright (c) 2025 Gray gray@grayraven.org
  https://oberon-rtk.org/licences/
**)

  CONST
    NumCores*         = 1;
    NumUART*          = 6;
    NumSPI*           = 2;
    NumI2C*           = 2;
    NumCounterTimers* = 5;
    NumPorts*         = 5;
    NumGPIO*          = NumPorts * 32; (* not all functional/connected *)
    NumInterrupts*    = 122; (* not all used/connected *)

    (* atomic registers *)
    ASET* = 004H;
    ACLR* = 008H;
    AXOR* = 0C0H;


(* === base addresses === *)
    (* -- AHB -- *)
    FLASH_BASE*     = 000000000H; (* port T0 *)
    FLASH_Size*     = 0100000H;   (* 1M *)
    ROM_BASE*       = 003000000H; (* 24k, port T1 *)
    SRAM_X0_BASE*   = 004000000H; (* port T2 *)
    SRAM_X0_Size*   = 02000H;     (* 8k *)
    SRAM_X1_BASE*   = 004002000H; (* port T2 *)
    SRAM_X1_Size*   = 02000H;     (* 8k *)

    SRAM_A0_BASE*   = 020000000H; (* port T3 *)
    SRAM_A0_Size*   = 02000H;     (* 8k *)
    SRAM_A1_BASE*   = 020002000H; (* port T3, PKC RAM 0 *)
    SRAM_A1_Size*   = 01000H;     (* 4k *)
    SRAM_A2_BASE*   = 020003000H; (* port T3, PKC RAM 1 *)
    SRAM_A2_Size*   = 01000H;     (* 4k *)
    SRAM_A3_BASE*   = 020004000H; (* port T3 *)
    SRAM_A3_Size*   = 04000H;     (* 16k *)
    SRAM_A4_BASE*   = 020008000H; (* port T3 *)
    SRAM_A4_Size*   = 08000H;     (* 32k *)
    SRAM_A_BASE*    = SRAM_A0_BASE;
    SRAM_A_Size*    = SRAM_A0_Size + SRAM_A1_Size + SRAM_A2_Size + SRAM_A3_Size + SRAM_A4_Size;

    SRAM_B0_BASE*   = 020010000H; (* port T4 *)
    SRAM_B0_Size*   = 08000H;     (* 32k *)
    SRAM_B1_BASE*   = 020018000H; (* port T4 *)
    SRAM_B1_Size*   = 08000H;     (* 32k *)
    SRAM_B_BASE*    = SRAM_B0_BASE;
    SRAM_B_Size*    = SRAM_B0_Size + SRAM_B1_Size;

    SRAM_C0_BASE*   = 020020000H; (* port T5 *)
    SRAM_C0_Size*   = 08000H;     (* 32k *)
    SRAM_C1_BASE*   = 020028000H; (* port T5 *)
    SRAM_C1_Size*   = 08000H;     (* 32k *)
    SRAM_C2_BASE*   = 020030000H; (* port T5 *)
    SRAM_C2_Size*   = 08000H;     (* 32k *)
    SRAM_C3_BASE*   = 020038000H; (* port T5 *)
    SRAM_C3_Size*   = 04000H;     (* 16k *)
    SRAM_C_BASE*    = SRAM_C0_BASE;
    SRAM_C_Size*    = SRAM_C0_Size + SRAM_C1_Size + SRAM_C2_Size + SRAM_C3_Size;

    SRAM_X0_ALIAS*  = 02003C000H; (* 8k, port T2 *)

    (* -- APB peripheral bridge 0 port T6-- *)
    INPUTMUX0_BASE* = 040001000H;
    CTIMER0_BASE*   = 040004000H;
    CTIMER1_BASE*   = 040005000H;
    CTIMER2_BASE*   = 040006000H;
    CTIMER3_BASE*   = 040007000H;
    CTIMER4_BASE*   = 040008000H;
    FREQME0_BASE*   = 040009000H;
    UTICK0_BASE*    = 04000B000H;
    WWDT0_BASE*     = 04000C000H;
    SmartDMA0_BASE* = 04000E000H;

    (* -- APB peripheral bridge 1 port T6 -- *)
    CMC_BASE*       = 04008B000H;
    ERM0_BASE*      = 04008D000H;
    MBC0_BASE*      = 04008E000H;
    SCG0_BASE*      = 04008F000H;
    SPC0_BASE*      = 040090000H;
    SYSCON_BASE*    = 040091000H;
    WUU0_BASE*      = 040092000H;
    VBAT0_BASE*     = 040093000H;
    FMC0_BASE*      = 040094000H;
    FMU0_BASE*      = 040095000H;
    LPI2C0_BASE*    = 04009A000H;
    LPI2C1_BASE*    = 04009B000H;
    LPSPI0_BASE*    = 04009C000H;
    LPSPI1_BASE*    = 04009D000H;
    LPUART0_BASE*   = 04009F000H;
    LPUART1_BASE*   = 0400A0000H;
    LPUART2_BASE*   = 0400A1000H;
    LPUART3_BASE*   = 0400A2000H;
    LPUART4_BASE*   = 0400A3000H;
    QDC0_BASE*      = 0400A7000H;
    QDC1_BASE*      = 0400A8000H;
    FlexPWM0_BASE*  = 0400A9000H;
    FlexPWM1_BASE*  = 0400AA000H;
    LPTMR0_BASE*    = 0400AB000H;
    OSTIMER0_BASE*  = 0400AD000H;
    WAKETIMER0_BASE* = 0400AE000H;
    HSADC0_BASE*    = 0400AF000H;
    HSADC1_BASE*    = 0400B0000H;
    CMP0_BASE*      = 0400B1000H;
    CMP1_BASE*      = 0400B2000H;
    CMP2_BASE*      = 0400B3000H;
    DAC0_BASE*      = 0400B4000H;
    OPAMP0_BASE*    = 0400B7000H;
    OPAMP1_BASE*    = 0400B8000H;
    OPAMP2_BASE*    = 0400B9000H;
    OPAMP3_BASE*    = 0400BA000H;
    PORT0_BASE*     = 0400BC000H;
    PORT1_BASE*     = 0400BD000H;
    PORT2_BASE*     = 0400BE000H;
    PORT3_BASE*     = 0400BF000H;
    PORT4_BASE*     = 0400C0000H;
    CAN0_BASE*      = 0400CC000H;
    CAN1_BASE*      = 0400D0000H;
    LPI2C2_BASE*    = 0400D4000H;
    LPI2C3_BASE*    = 0400D5000H;
    LPUART5_BASE*   = 0400DA000H;
    TDET0_BASE*     = 0400E9000H;
    PKC0_BASE*      = 0400EA000H;
    SGI0_BASE*      = 0400EB000H;
    TRNG0_BASE*     = 0400EC000H;
    UDF0_BASE*      = 0400ED000H;
    RTC0_BASE*      = 0400EE000H;
    HSADC2_BASE*    = 0400F0000H;
    HSADC3_BASE*    = 0400F1000H;

    (* -- AHB fast peripherals port T6-- *)
    CDOG0_BASE*     = 040100000H;
    RGPIO0_BASE*    = 040102000H;
    RGPIO1_BASE*    = 040103000H;
    RGPIO2_BASE*    = 040104000H;
    RGPIO3_BASE*    = 040105000H;
    RGPIO4_BASE*    = 040106000H;
    CDOG1_BASE*     = 040107000H;
    MAU_BASE*       = 040108000H;

    (* -- PPB base addresses -- *)
    PPB_BASE*       = 0E0000000H;

(* == APB peripheral bridge 0 == *)
    CTIMER_Offset* = CTIMER1_BASE - CTIMER0_BASE;
    CTIMER_IR_Offset*     = 000H;
    CTIMER_TCR_Offset*    = 004H;
    CTIMER_TC_Offset*     = 008H;
    CTIMER_PR_Offset*     = 00CH;
    CTIMER_PC_Offset*     = 010H;
    CTIMER_MCR_Offset*    = 014H;
    CTIMER_MR0_Offset*    = 018H;
    CTIMER_MR1_Offset*    = 01CH;
    CTIMER_MR2_Offset*    = 020H;
    CTIMER_MR3_Offset*    = 024H;
    CTIMER_CCR_Offset*    = 028H;
    CTIMER_CR0_Offset*    = 02CH;
    CTIMER_CR1_Offset*    = 030H;
    CTIMER_CR2_Offset*    = 034H;
    CTIMER_CR3_Offset*    = 038H;
    CTIMER_EMR_Offset*    = 03CH;
    CTIMER_CTCR_Offset*   = 070H;
    CTIMER_PWMC_Offset*   = 074H;
    CTIMER_MSR0_Offset*   = 078H;
    CTIMER_MSR1_Offset*   = 07CH;
    CTIMER_MSR2_Offset*   = 080H;
    CTIMER_MSR3_Offset*   = 084H;

(* == APB peripheral bridge 1 == *)

    (* == MBC memory block checker == *)
    (* ref manual 48, p1762 *)
    MBC_MEM0_GLBCFG* = MBC0_BASE;
    MBC_MEM1_GLBCFG* = MBC0_BASE + 0004H;
    MBC_MEM2_GLBCFG* = MBC0_BASE + 0008H;
    MBC_MEM3_GLBCFG* = MBC0_BASE + 000CH;
    MBC_MEMN_GLBAC0* = MBC0_BASE + 0020H;
    MBC_MEMN_GLBAC1* = MBC0_BASE + 0024H;
    MBC_MEMN_GLBAC2* = MBC0_BASE + 0028H;
    MBC_MEMN_GLBAC3* = MBC0_BASE + 002CH;
    MBC_MEMN_GLBAC4* = MBC0_BASE + 0030H;
    MBC_MEMN_GLBAC5* = MBC0_BASE + 0034H;
    MBC_MEMN_GLBAC6* = MBC0_BASE + 0038H;
    MBC_MEMN_GLBAC7* = MBC0_BASE + 003CH;

    MBC_DOM0_MEM0_BLK_CFG_W0* = MBC0_BASE + 0040H;

    (* == SCG system clock generator == *)
    (* ref manual 23.7.1, p912 *)
    SCG_VERID*      = SCG0_BASE;
    SCG_PARAM*      = SCG0_BASE + 0004H;
    SCG_TRIM_LOCK*  = SCG0_BASE + 0008H;
    SCG_CSR*        = SCG0_BASE + 0010H;
    SCG_RCCR*       = SCG0_BASE + 0014H;
    SCG_SOSCCSR*    = SCG0_BASE + 0100H;
    SCG_SOSCCFG*    = SCG0_BASE + 0108H;
    SCG_SIRCCSR*    = SCG0_BASE + 0200H;
    SCG_SIRCTCFG*   = SCG0_BASE + 020CH;
    SCG_SIRCTRIM*   = SCG0_BASE + 0210H;
    SCG_SIRCSTAT*   = SCG0_BASE + 0218H;
    SCG_FIRCCSR*    = SCG0_BASE + 0300H;
    SCG_FIRCCFG*    = SCG0_BASE + 0308H;
    SCG_FIRCTRIM*   = SCG0_BASE + 0310H;
    SCG_ROSCCSR*    = SCG0_BASE + 0400H;
    SCG_SPLLCSR*    = SCG0_BASE + 0600H;
    SCG_SPLLCTRL*   = SCG0_BASE + 0604H;
    SCG_SPLLSTAT*   = SCG0_BASE + 0608H;
    SCG_SPLLNDIV*   = SCG0_BASE + 060CH;
    SCG_SPLLMDIV*   = SCG0_BASE + 0610H;
    SCG_SPLLPDIV*   = SCG0_BASE + 0614H;
    SCG_SPLLLOCK_CNFG*  = SCG0_BASE + 0618H;
    SCG_SPLLSSCG*   = SCG0_BASE + 0620H;
    SCG_SPLLSSCG0*  = SCG0_BASE + 0624H;
    SCG_SPLLSSCG1*  = SCG0_BASE + 0628H;
    SCG_LDOCSR*     = SCG0_BASE + 0800H;

    (* == SPC system power controller == *)
    (* ref manual 26.7.1, p981 *)
    SPC_SC*         = SPC0_BASE + 0010H;
    SPC_SRAMCTL*    = SPC0_BASE + 0040H;
    SPC_ACTIVE_CFG* = SPC0_BASE + 0100H;

    (* == SYSCON == *)
    (* ref manual 14.5.1, p483 *)
    SYSCON_AHBMATPRIO*  = SYSCON_BASE + 0210H;
    SYSCON_SLOWCLKDIV*  = SYSCON_BASE + 0378H;
    SYSCON_BUSCLKDIV*   = SYSCON_BASE + 037CH;
    SYSCON_AHBCLKDIV*   = SYSCON_BASE + 0380H;
    SYSCON_FROHFDIV*    = SYSCON_BASE + 0388H;
    SYSCON_FROLFDIV*    = SYSCON_BASE + 038CH;
    SYSCON_CLKUNLOCK*   = SYSCON_BASE + 03FCH;
    SYSCON_LPCAC_CTRL*  = SYSCON_BASE + 0824H;

    SYSCON_RAM_CTRL*    = SYSCON_BASE + 0944H;

    (* == MRCC == *)
    (* ref manual 14.5.2, p520 *)
    (* device reset control *)
    MRCC_GLB_RST0*     = SYSCON_BASE;
    MRCC_GLB_RST0_SET* = MRCC_GLB_RST0 + ASET;
    MRCC_GLB_RST0_CLR* = MRCC_GLB_RST0 + ACLR;
    MRCC_GLB_RST1*     = SYSCON_BASE + 010H;
    MRCC_GLB_RST1_SET* = MRCC_GLB_RST1 + ASET;
    MRCC_GLB_RST1_CLR* = MRCC_GLB_RST1 + ACLR;
    MRCC_GLB_RST2*     = SYSCON_BASE + 020H;
    MRCC_GLB_RST2_SET* = MRCC_GLB_RST2 + ASET;
    MRCC_GLB_RST2_CLR* = MRCC_GLB_RST2 + ACLR;
      MRCC_GLB_RST_Offset* = 010H;

    (* device AHB bus clock control *)
    MRCC_GLB_CC0*      = SYSCON_BASE + 040H;
    MRCC_GLB_CC0_SET*  = MRCC_GLB_CC0 + ASET;
    MRCC_GLB_CC0_CLR*  = MRCC_GLB_CC0 + ACLR;
    MRCC_GLB_CC1*      = SYSCON_BASE + 050H;
    MRCC_GLB_CC1_SET*  = MRCC_GLB_CC1 + ASET;
    MRCC_GLB_CC1_CLR*  = MRCC_GLB_CC1 + ACLR;
    MRCC_GLB_CC2*      = SYSCON_BASE + 060H;
    MRCC_GLB_CC2_SET*  = MRCC_GLB_CC2 + ASET;
    MRCC_GLB_CC2_CLR*  = MRCC_GLB_CC2 + ACLR;
      MRCC_GLB_CC_Offset* = 010H;

    (* functional clock selection & divider *)
    (* USE CLK_* device numbers to calculate offset *)
    MRCC_CLKSEL* = SYSCON_BASE + 0A0H;
    MRCC_CLKDIV* = SYSCON_BASE + 0A4H;
      MRCC_CLK_Offset* = 8;

    (* device numbers *)
    (* MRCC_GLB_RST0, MRCC_GLB_CC0, MRCC_GLB_ACC0 *)
    DEV_INPUTMUX0*  = 0;
    DEV_CTIMER0*    = 2;
    DEV_CTIMER1*    = 3;
    DEV_CTIMER2*    = 4;
    DEV_CTIMER3*    = 5;
    DEV_CTIMER4*    = 6;
    DEV_UART0*      = 23;
    DEV_UART1*      = 24;
    DEV_UART2*      = 25;
    DEV_UART3*      = 26;
    DEV_UART4*      = 27;
    DEV_QDC1*       = 30;
    DEV_FLEXPWM0*   = 31;

    (* MRCC_GLB_RST1, MRCC_GLB_CC1, MRCC_GLB_ACC1 *)
    DEV_PORT0*      = 32 + 12;
    DEV_PORT1*      = 32 + 13;
    DEV_PORT2*      = 32 + 14;
    DEV_PORT3*      = 32 + 15;
    DEV_PORT4*      = 32 + 16;
    DEV_UART5*      = 32 + 26;

    (* MRCC_GLB_RST2, MRCC_GLB_CC2, MRCC_GLB_ACC2 *)
    DEV_GPIO0*      = 64 + 4;
    DEV_GPIO1*      = 64 + 5;
    DEV_GPIO2*      = 64 + 6;
    DEV_GPIO3*      = 64 + 7;
    DEV_GPIO4*      = 64 + 8;

    (* MRCC_CLKSEL, MRCC_CLKDIV *)
    CLK_CTIMER0*    = 1;
    CLK_CTIMER1*    = 2;
    CLK_CTIMER2*    = 3;
    CLK_CTIMER3*    = 4;
    CLK_CTIMER4*    = 5;
    CLK_FLXIO0*     = 7;
    CLK_I2C0*       = 8;
    CLK_I2C1*       = 9;
    CLK_SPI0*       = 10;
    CLK_SPI1*       = 11;
    CLK_UART0*      = 12;
    CLK_UART1*      = 13;
    CLK_UART2*      = 14;
    CLK_UART3*      = 15;
    CLK_UART4*      = 16;
    CLK_UART5*      = 32;
    CLK_CLKOUT*     = 34;
    CLK_SYSTICK*    = 35;

    (* == FMU flash management unit == *)
    FMU_FCTRL*      = FMU0_BASE + 008H;


    (* == (LP)UART0 .. UART5 == *)
    (* ref manual 39, p1519 *)
    (* UART_Offset valid for UART0 to UART4 *)
    UART_Offset*        = LPUART1_BASE - LPUART0_BASE;
    UART_VERID_Offset*  = 000H;
    UART_PARAM_Offset*  = 004H;
    UART_GLOBAL_Offset* = 008H;
    UART_PINCFG_Offset* = 00CH;
    UART_BAUD_Offset*   = 010H;
    UART_STAT_Offset*   = 014H;
    UART_CTRL_Offset*   = 018H;
    UART_DATA_Offset*   = 01CH;
    UART_MATCH_Offset*  = 020H;
    UART_MODIR_Offset*  = 024H;
    UART_FIFO_Offset*   = 028H;
    UART_WATER_Offset*  = 02CH;
    UART_DATARO_Offset* = 030H;


    (* == PORT0 .. PORT4 == *)
    (* ref manual 11.6.1, p138 *)
    PORT_Offset* = PORT1_BASE - PORT0_BASE;
    PORT_VERID_Offset*  = 000H;
    PORT_GPCLR_Offset*  = 010H;
    PORT_GPCHR_Offset*  = 014H;
    PORT_CONFIG_Offset* = 020H;
    PORT_CALIB0_Offset* = 060H;
    PORT_CALIB1_Offset* = 064H;
    PORT_PCR_Offset*    = 080H;

    (* supported/implemented pins *)
    PORT0_pins* = {0 .. 7,          12 .. 19, 20 .. 26, 27,     29 .. 31};
    PORT1_pins* = {0 .. 7, 8 .. 11, 12 .. 19};
    PORT2_pins* = {0 .. 7, 8 .. 11, 12 .. 19, 20 .. 26 };
    PORT3_pins* = {0 .. 7, 8 .. 11, 12 .. 19, 20 .. 26, 27, 28, 29 .. 31};
    PORT4_pins* = {0 .. 7};

    (* PCR non-zero resets *)
    P0_PCR0reset*  = 000001143H; (* TMS/SWDIO: ibe, mux = 1, dse, pe, ps = up *)
    P0_PCR1reset*  = 000001102H; (* TCK/SWCLK: ibe, mux = 1, pe, ps = down *)
    P0_PCR2reset*  = 000000140H; (* TDO/SWO: mux = 1, dse *)
    P0_PCR3reset*  = 000001103H; (* TDI: ibe, mux = 1, pe, ps = up *)
    P0_PCR6reset*  = 000001103H; (* ISPMODE: ibe, mux = 1, pe, ps = up *)
    P1_PCR29reset* = 000000133H; (* RESET: mux = 1, ode, pfe, pe, ps = up *)
    P3_PCR29reset* = 000000103H; (* mux = 1, pe, ps = up *)

    (* ports with non-zero resets *)
    PORT_reset* = {0, 1, 3};

    (* pin number = PORTx + pin index within port *)
    PORT0* = 0;
    PORT1* = 32;
    PORT2* = 64;
    PORT3* = 96;
    PORT4* = 128;

(* == AHB fast peripherals == *)

    (* == GPIO == *)
    RGPIO_Offset* = RGPIO1_BASE - RGPIO0_BASE;
    RGPIO_PDOR_Offset* = 040H;  (* data output value *)
    RGPIO_PSOR_Offset* = 044H;  (* data output set masked *)
    RGPIO_PCOR_Offset* = 048H;  (* data output clear masked *)
    RGPIO_PTOR_Offset* = 04CH;  (* data output toggle masked *)
    RGPIO_PDIR_Offset* = 050H;  (* data input *)
    RGPIO_PDDR_Offset* = 054H;  (* data direction, reset = input [0] *)
    RGPIO_PIDR_Offset* = 058H;  (* input disable, reset = enabled [0] *)

    (* use for parameter 'gpio' in GPIO.Set and friends *)
    GPIO0* = RGPIO0_BASE;
    GPIO1* = RGPIO1_BASE;
    GPIO2* = RGPIO2_BASE;
    GPIO3* = RGPIO3_BASE;
    GPIO4* = RGPIO4_BASE;

    (* RPx-ish aliases *)
    GPIO0_OUT_SET*  = RGPIO0_BASE + RGPIO_PSOR_Offset;
    GPIO0_OUT_CLR*  = RGPIO0_BASE + RGPIO_PCOR_Offset;
    GPIO0_OUT_XOR*  = RGPIO0_BASE + RGPIO_PTOR_Offset;

    GPIO1_OUT_SET*  = RGPIO1_BASE + RGPIO_PSOR_Offset;
    GPIO1_OUT_CLR*  = RGPIO1_BASE + RGPIO_PCOR_Offset;
    GPIO1_OUT_XOR*  = RGPIO1_BASE + RGPIO_PTOR_Offset;

    GPIO2_OUT_SET*  = RGPIO2_BASE + RGPIO_PSOR_Offset;
    GPIO2_OUT_CLR*  = RGPIO2_BASE + RGPIO_PCOR_Offset;
    GPIO2_OUT_XOR*  = RGPIO2_BASE + RGPIO_PTOR_Offset;

    GPIO3_OUT_SET*  = RGPIO3_BASE + RGPIO_PSOR_Offset;
    GPIO3_OUT_CLR*  = RGPIO3_BASE + RGPIO_PCOR_Offset;
    GPIO3_OUT_XOR*  = RGPIO3_BASE + RGPIO_PTOR_Offset;

    GPIO4_OUT_SET*  = RGPIO3_BASE + RGPIO_PSOR_Offset;
    GPIO4_OUT_CLR*  = RGPIO3_BASE + RGPIO_PCOR_Offset;
    GPIO4_OUT_XOR*  = RGPIO3_BASE + RGPIO_PTOR_Offset;


(* == PPB: private peripheral bus == *)

    (* begin of SCS: System Control Space *)

    (* -- implementation control block -- *)
    PPB_ICTR*         = PPB_BASE + 0E004H;
    PPB_ACTLR*        = PPB_BASE + 0E008H;

    (* -- SysTick -- *)
    PPB_SYST_CSR*     = PPB_BASE + 0E010H;
    PPB_SYST_RVR*     = PPB_BASE + 0E014H;
    PPB_SYST_CVR*     = PPB_BASE + 0E018H;
    PPB_SYST_CALIB*   = PPB_BASE + 0E01CH;

    (* -- NVIC -- *)
    PPB_NVIC_ISER0*   = PPB_BASE + 0E100H;
    PPB_NVIC_ICER0*   = PPB_BASE + 0E180H;
    PPB_NVIC_ISPR0*   = PPB_BASE + 0E200H;
    PPB_NVIC_ICPR0*   = PPB_BASE + 0E280H;
    PPB_NVIC_IABR0*   = PPB_BASE + 0E300H;
    PPB_NVIC_ITNS0*   = PPB_BASE + 0E380H;
    PPB_NVIC_IPR0*    = PPB_BASE + 0E400H;

    (* -- IRQ numbers -- *)
    IRQ_BASE*           = 16; (* exc no = IRQ_BASE + IRQ number *)
    IRQ_OR_ALL*         = 0;
    IRQ_Reserved_0*     = 0;
    IRQ_CMC0*           = 1;
    IRQ_DMA0_CH0*       = 2;
    IRQ_DMA0_CH1*       = 3;
    IRQ_DMA0_CH2*       = 4;
    IRQ_DMA0_CH3*       = 5;
    IRQ_DMA0_CH4*       = 6;
    IRQ_DMA0_CH5*       = 7;
    IRQ_DMA0_CH6*       = 8;
    IRQ_DMA0_CH7*       = 9;
    IRQ_ERM0_SBIT_ERR*  = 10;
    IRQ_ERM0_MBIT_ERR*  = 11;
    IRQ_FMU0*           = 12;
    IRQ_GLIKEY0*        = 13;
    IRQ_MBC0*           = 14;
    IRQ_SCG0*           = 15;
    IRQ_SPC0*           = 16;
    IRQ_TDET0*          = 17;
    IRQ_WUU0*           = 18;
    IRQ_CAN0*           = 19;
    IRQ_CAN1*           = 20;
    IRQ_Reserved_21*    = 21;
    IRQ_Reserved_22*    = 22;
    IRQ_Reserved_23*    = 23;
    IRQ_Reserved_24*    = 24;
    IRQ_Reserved_25*    = 25;
    IRQ_LPI2C0*         = 26;
    IRQ_LPI2C1*         = 27;
    IRQ_LPSPI0*         = 28;
    IRQ_LPSPI1*         = 29;
    IRQ_Reserved*       = 30;
    IRQ_LPUART0*        = 31;
    IRQ_LPUART1*        = 32;
    IRQ_LPUART2*        = 33;
    IRQ_LPUART3*        = 34;
    IRQ_LPUART4*        = 35;
    IRQ_Reserved_36*    = 36;
    IRQ_Reserved_37*    = 37;
    IRQ_CDOG0*          = 38;
    IRQ_CTIMER0*        = 39;
    IRQ_CTIMER1*        = 40;
    IRQ_CTIMER2*        = 41;
    IRQ_CTIMER3*        = 42;
    IRQ_CTIMER4*        = 43;
    IRQ_PWM0_RLDERR*    = 44;
    IRQ_PWM0_FLT*       = 45;
    IRQ_PWM0_SUB0*      = 46;
    IRQ_PWM0_SUB1*      = 47;
    IRQ_PWM0_SUB2*      = 48;
    IRQ_PWM0_SUB3*      = 49;
    IRQ_QDC0_CMP*       = 50;
    IRQ_QDC0_HOME*      = 51;
    IRQ_QDC0_WD*        = 52;
    IRQ_QDC0_ROLL*      = 53;
    IRQ_FREQME0*        = 54;
    IRQ_LPTMR0*         = 55;
    IRQ_Reserved_56*    = 56;
    IRQ_OSTIMER0*       = 57;
    IRQ_WAKETIMER0*     = 58;
    IRQ_UTICK0*         = 59;
    IRQ_WWDT0*          = 60;
    IRQ_Reserved_61*    = 61;
    IRQ_ADC0*           = 62;
    IRQ_ADC1*           = 63;
    IRQ_CMP0*           = 64;
    IRQ_CMP1*           = 65;
    IRQ_CMP2*           = 66;
    IRQ_DAC0*           = 67;
    IRQ_Reserved_68*    = 68;
    IRQ_Reserved_69*    = 69;
    IRQ_Reserved_70*    = 70;
    IRQ_GPIO0*          = 71;
    IRQ_GPIO1*          = 72;
    IRQ_GPIO2*          = 73;
    IRQ_GPIO3*          = 74;
    IRQ_GPIO4*          = 75;
    IRQ_Reserved_76*    = 76;
    IRQ_LPI2C2*         = 77;
    IRQ_LPI2C3*         = 78;
    IRQ_PWM1_RLDERR*    = 79;
    IRQ_PWM1_FLT*       = 80;
    IRQ_PWM1_SUB0*      = 81;
    IRQ_PWM1_SUB1*      = 82;
    IRQ_PWM1_SUB2*      = 83;
    IRQ_PWM1_SUB3*      = 84;
    IRQ_QDC1_CMP*       = 85;
    IRQ_QDC1_HOME*      = 86;
    IRQ_QDC1_WD*        = 87;
    IRQ_QDC1_ROLL*      = 88;
    IRQ_Reserved_89*    = 89;
    IRQ_Reserved_90*    = 90;
    IRQ_Reserved_91*    = 91;
    IRQ_Reserved_92*    = 92;
    IRQ_Reserved_93*    = 93;
    IRQ_Reserved_94*    = 94;
    IRQ_LPUART5*        = 95;
    IRQ_Reserved_96*    = 96;
    IRQ_Reserved_97*    = 97;
    IRQ_Reserved_98*    = 98;
    IRQ_Reserved_99*    = 99;
    IRQ_Reserved_100*   = 100;
    IRQ_Reserved_101*   = 101;
    IRQ_Reserved_102*   = 102;
    IRQ_Reserved_103*   = 103;
    IRQ_Reserved_104*   = 104;
    IRQ_Reserved_105*   = 105;
    IRQ_Reserved_106*   = 106;
    IRQ_MAU0*           = 107;
    IRQ_SmartDMA0*      = 108;
    IRQ_CDOG1*          = 109;
    IRQ_PKC0*           = 110;
    IRQ_SGI0*           = 111;
    IRQ_Reserved_112*   = 112;
    IRQ_TRNG0*          = 113;
    IRQ_SECURE_ERR*     = 114;
    IRQ_Reserved_115*   = 115;
    IRQ_ADC2*           = 116;
    IRQ_ADC3*           = 117;
    IRQ_Reserved_118*   = 118;
    IRQ_RTC0_ALARM*     = 119;
    IRQ_RTC0_1KHZ*      = 120;
    IRQ_Reserved_121*   = 121;

    (* IRQ for SW use *)
    IRQ_SW_0*   = IRQ_Reserved_89;
    IRQ_SW_1*   = IRQ_Reserved_90;
    IRQ_SW_2*   = IRQ_Reserved_91;
    IRQ_SW_3*   = IRQ_Reserved_92;
    IRQ_SW_4*   = IRQ_Reserved_93;
    IRQ_SW_5*   = IRQ_Reserved_94;


    (* -- system exception numbers -- *)
    EXC_NMI*          = 2;
    EXC_HardFault*    = 3;
    EXC_MemMgmtFault* = 4; (* not implemented *)
    EXC_BusFault*     = 5;
    EXC_UsageFault*   = 6;
    EXC_SecureFault*  = 7; (* not implemented *)
    EXC_SVC*          = 11;
    EXC_DebugMon*     = 12;
    EXC_PendSV*       = 14;
    EXC_SysTick*      = 15;

    SysExc*  = {3, 5, 6, 11, 14, 15};

    (* -- exception priorities *)
    ExcPrio0* = 000H; (* 0000 0000 *)
    ExcPrio1* = 020H; (* 0010 0000 *)
    ExcPrio2* = 040H; (* 0100 0000 *)
    ExcPrio3* = 060H; (* 0110 0000 *)
    ExcPrio4* = 080H; (* 1000 0000 *)
    ExcPrio5* = 0A0H; (* 1010 0000 *)
    ExcPrio6* = 0C0H; (* 1100 0000 *)
    ExcPrio7* = 0E0H; (* 1110 0000 *)

    NumExcPrio* = 8;

    ExcPrioTop*    = ExcPrio0;
    ExcPrioHigh*   = ExcPrio1;
    ExcPrioMedium* = ExcPrio4;
    ExcPrioLow*    = ExcPrio7;

    (* -- vector table -- *)
    VectorTableSize*        = 548; (* bytes: 16 sys exceptions + 121 interrupts, one word each *)
    EXC_Reset_Offset*       = 004H;
    EXC_NMI_Offset*         = 008H;
    EXC_HardFault_Offset*   = 00CH;
    EXC_BusFault_Offset*    = 014H;
    EXC_UsageFault_Offset*  = 018H;
    EXC_SVC_Offset*         = 02CH;
    EXC_DebugMon_Offset*    = 030H;
    EXC_PendSV_Offset*      = 038H;
    EXC_SysTick_Offset*     = 03CH;

    (* -- SCB system control block -- *)
    PPB_ICSR*         = PPB_BASE + 0ED04H;
    PPB_VTOR*         = PPB_BASE + 0ED08H;
    PPB_AIRCR*        = PPB_BASE + 0ED0CH;
    PPB_SCR*          = PPB_BASE + 0ED10H;
    PPB_CCR*          = PPB_BASE + 0ED14H;

    PPB_SHPR1*        = PPB_BASE + 0ED18H;
    PPB_SHPR2*        = PPB_BASE + 0ED1CH;
    PPB_SHPR3*        = PPB_BASE + 0ED20H;

    PPB_SHCSR*        = PPB_BASE + 0ED24H;

    PPB_CFSR*         = PPB_BASE + 0ED28H; (* UFSR [31:16], BFSR [15:8], MMFSR [7:0] *)
    PPB_HFSR*         = PPB_BASE + 0ED2CH;
    PPB_DFSR*         = PPB_BASE + 0ED30H;
    PPB_MMFAR*        = PPB_BASE + 0ED34H;
    PPB_BFAR*         = PPB_BASE + 0ED38H;
    PPB_AFSR*         = PPB_BASE + 0ED3CH;
    PPB_CPACR*        = PPB_BASE + 0ED88H;

    (* -- sw interrupt generation -- *)
    PPB_STIR*         = PPB_BASE + 0EF00H;

(* ===== CPU registers ===== *)
    (* CONTROL special register *)
    CONTROL_SPSEL* = 1; (* enable PSP *)


(* ===== assembly instructions ===== *)

    NOP* = 046C0H;

    (* read specical regs MRS *)
    (* 0F3EF8 B 09H r11(B) PSP(09) *)
    (* [11:8] = register Rn *)
    (* [7:0] = special reg SYSm *)
    MRS_R11_IPSR* = 0F3EF8B05H;  (* move IPSR to r11 *)
    MRS_R03_IPSR* = 0F3EF8305H;  (* move IPSR to r3 *)
    MRS_R00_IPSR* = 0F3EF8005H;  (* move IPSR to r0 *)

    MRS_R11_XPSR* = 0F3EF8B03H;  (* move XPSR to r11 *)
    MRS_R03_XPSR* = 0F3EF8303H;  (* move XPSR to r3 *)

    MRS_R11_MSP*  = 0F3EF8B08H;  (* move MSP to r11 *)
    MRS_R03_MSP*  = 0F3EF8308H;  (* move MSP to r3 *)
    MRS_R00_MSP*  = 0F3EF8008H;  (* move MSP to r0 *)

    MRS_R11_PSP*  = 0F3EF8B09H;  (* move PSP to r11 *)
    MRS_R03_PSP*  = 0F3EF8309H;  (* move PSP to r3 *)
    MRS_R00_PSP*  = 0F3EF8009H;  (* move PSP to r0 *)

    MRS_R11_CTL*  = 0F3EF8B14H;  (* move CONTROL = 14H to r11 *)
    MRS_R03_CTL*  = 0F3EF8314H;  (* move CONTROL = 14H to r3 *)

    MRS_R03_BASEPRI* = 0F3EF8311H; (* move BASEPRI = 11H to r3 *)
    MRS_R07_BASEPRI* = 0F3EF8711H; (* move BASEPRI = 11H to r7 *)
    MRS_R11_BASEPRI* = 0F3EF8B11H; (* move BASEPRI = 11H to r11 *)

    (* write special regs MSR *)
    (* 0F38 B 88 09H r11(B) PSP(09) *)
    (* [19:16] = register Rn *)
    (* [7:0] = special register SYSm *)
    MSR_PSP_R11* = 0F38B8809H;  (* move r11 to PSP *)
    MSR_MSP_R11* = 0F38B8808H;  (* move r11 to MSP *)
    MSR_CTL_R11* = 0F38B8814H;  (* move r11 to CONTROL *)

    MSR_BASEPRI_R02* = 0F3828811H; (* move r02 to BASEPRI *)
    MSR_BASEPRI_R03* = 0F3838811H; (* move r03 to BASEPRI *)
    MSR_BASEPRI_R06* = 0F3868811H; (* move r06 to BASEPRI *)
    MSR_BASEPRI_R07* = 0F3878811H; (* move r07 to BASEPRI *)
    MSR_BASEPRI_R11* = 0F38B8811H; (* move r11 to BASEPRI *)

    (* instruction & data sync *)
    ISB* = 0F3BF8F6FH;
    DSB* = 0F3BF8F4FH;

    (* raise execution prio to 0 via PRIMASK *)
    CPSIE_I* = 0B662H; (* enable:  1011 0110 0110 0010 *)
    CPSID_I* = 0B672H; (* disable: 1011 0110 0111 0010 *)
    (* raise execution prio to -1 = HardFault via FAULTMASK *)
    (* clears on handler exit *)
    CPSIE_F* = 0B662H; (* enable:  1011 0110 0110 0001 *)
    CPSID_F* = 0B672H; (* disable: 1011 0110 0111 0001 *)

    (* wait for event *)
    WFE* = 0BF20H;

    (* SVC *)
    (* SVCinstr = 'SVC' + SVCvalue *)
    SVC* = 0DF00H;


END MCU2.
.     4  000000338      0B500  push      { lr }
.     6  00000033A      0BD00  pop       { pc }
 