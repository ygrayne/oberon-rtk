. <tool: Astrobe for RP2350>
. <prog: C:\Users\gray\Projects\oberon\dev\oberon-rtk\examples\v3.0\nxp\any\SignalSync\SignalSync.mod>

.     0  0000046C4              <Pad: 0>
MODULE Kernel;
(**
  Oberon RTK Framework
  Version: v3.0
  --
  Multi-threading kernel v1
  --
  Based on coroutines
  Multi-core
  Time-driven scheduler
  Cooperative scheduling
  No support for interrupts
  --
  MCU: MCXA346, MCXN947
  --
  Copyright (c) 2020-2025 Gray gray@grayraven.org
  https://oberon-rtk.org/licences/
**)

  IMPORT SYSTEM, Config, Coroutines, Memory, SysTick, Cores, MCU := MCU2, Errors, Out;

  CONST
    MaxNumThreads* = 16;
    NumCores = Config.NumCoresUsed;

    (* result codes *)
    OK* = 0;
    NoError* = 0;
    Failed* = 1;

    DefaultPrio* = 7;

    (* thread states *)
    StateEnabled = 0;    (* triggered: queued at next trigger event; queued at next scheduler run *)
    StateSuspended = 1;  (* must be (re-) enabled before it can run *)

    (* thread trigger modes *)
    TrigNone* = 0;
    TrigPeriod* = 1;
    TrigDelay* = 2;
    TrigDevice* = 3;


    (* loop *)
    LoopStackSize = 256; (* bytes *)
    LoopCorId = -1;

    (* scheduler slow motion factor (debugging) *)
    SloMo = 1;


  TYPE
    (* one thread *)
    PROC* = PROCEDURE; (* Modula-2 vibes *)
    Thread* = POINTER TO ThreadDesc;
    ThreadDesc* = RECORD
      prio, tid: INTEGER;
      state: INTEGER;
      period, ticker: INTEGER;
      delay: INTEGER;
      devAddr: INTEGER;
      devFlagsSet, devFlagsClr: SET;
      cor: Coroutines.Coroutine;
      trigCode: INTEGER;
      next*: Thread
    END;
.     4  0000046C8      046C8      00030  <Type:   48>
.     8  0000046CC      046CC      00000  <Type:   0>
.    12  0000046D0      046D0      00000  <Type:   0>
.    16  0000046D4      046D4      00000  <Type:   0>
.    20  0000046D8      046D8      00000  <Type:   0>

    (* core-specific data *)
    CoreContext = POINTER TO CoreContextDesc;
    CoreContextDesc = RECORD
      threads: ARRAY MaxNumThreads OF Thread;
      Ct, ct: Thread;
      queued: SET;
      numThreads: INTEGER;
      loopPeriod: INTEGER;
      loop, jump: Coroutines.Coroutine
    END;
.    24  0000046DC      046DC      0005C  <Type:   92>
.    28  0000046E0      046E0      00000  <Type:   0>
.    32  0000046E4      046E4      00000  <Type:   0>
.    36  0000046E8      046E8      00000  <Type:   0>
.    40  0000046EC      046EC      00000  <Type:   0>

  VAR
    coreCon: ARRAY NumCores OF CoreContext;

    Done*: PROCEDURE; (* alias for SuspendMe *)
    Yield*: PROCEDURE; (* alias for Next *)


  (* ready queue *)

  PROCEDURE* slotIn(t: Thread; ctx: CoreContext);
  (* put into ready queue, prio sorted *)
    VAR t0, t1: Thread;
  BEGIN
.    44  0000046F0      0B500  push      { lr }
.    46  0000046F2      0B082  sub       sp,#8
    IF ~(t.tid IN ctx.queued) THEN
.    48  0000046F4      06C8A  ldr       r2,[r1,#72]
.    50  0000046F6      06843  ldr       r3,[r0,#4]
.    52  0000046F8      02401  movs      r4,#1
.    54  0000046FA      0409C  lsls      r4,r3
.    56  0000046FC  0EA120F04  tst.w     r2,r4
.    60  000004700  0F0408029  bne.w     82 -> 146
      t0 := ctx.ct; t1 := t0;
.    64  000004704      06C4A  ldr       r2,[r1,#68]
.    66  000004706      09200  str       r2,[sp]
.    68  000004708      09A00  ldr       r2,[sp]
.    70  00000470A      09201  str       r2,[sp,#4]
      WHILE (t0 # NIL) & (t0.prio <= t.prio) DO
.    72  00000470C      09A00  ldr       r2,[sp]
.    74  00000470E      02A00  cmp       r2,#0
.    76  000004710  0F000800D  beq.w     26 -> 106
.    80  000004714      09A00  ldr       r2,[sp]
.    82  000004716      06812  ldr       r2,[r2]
.    84  000004718      06803  ldr       r3,[r0]
.    86  00000471A      0429A  cmp       r2,r3
.    88  00000471C  0F3008007  bgt.w     14 -> 106
        t1 := t0; t0 := t0.next
.    92  000004720      09A00  ldr       r2,[sp]
.    94  000004722      09201  str       r2,[sp,#4]
      END;
.    96  000004724      09A00  ldr       r2,[sp]
.    98  000004726      06AD2  ldr       r2,[r2,#44]
.   100  000004728      09200  str       r2,[sp]
.   102  00000472A  0F7FFBFEF  b.w       -34 -> 72
      IF t1 = t0 THEN ctx.ct := t ELSE t1.next := t END;
.   106  00000472E      09A01  ldr       r2,[sp,#4]
.   108  000004730      09B00  ldr       r3,[sp]
.   110  000004732      0429A  cmp       r2,r3
.   112  000004734  0F0408003  bne.w     6 -> 122
.   116  000004738      06448  str       r0,[r1,#68]
.   118  00000473A  0F000B802  b.w       4 -> 126
.   122  00000473E      09A01  ldr       r2,[sp,#4]
.   124  000004740      062D0  str       r0,[r2,#44]
      t.next := t0;
.   126  000004742      09A00  ldr       r2,[sp]
.   128  000004744      062C2  str       r2,[r0,#44]
      INCL(ctx.queued, t.tid)
    END
.   130  000004746      06842  ldr       r2,[r0,#4]
.   132  000004748      02301  movs      r3,#1
.   134  00000474A      04093  lsls      r3,r2
.   136  00000474C  0F1110448  adds.w    r4,r1,#72
.   140  000004750      06825  ldr       r5,[r4]
.   142  000004752      0431D  orrs      r5,r3
.   144  000004754      06025  str       r5,[r4]
  END slotIn;
.   146  000004756      0B002  add       sp,#8
.   148  000004758      0BD00  pop       { pc }
.   150  00000475A      0BF00  nop       

  (* manage threads *)

  PROCEDURE Allocate*(proc: PROC; stackSize: INTEGER; VAR t: Thread; VAR tid, res: INTEGER);
    VAR cid, stackAddr: INTEGER; ctx: CoreContext;
  BEGIN
.   152  00000475C      0B51F  push      { r0, r1, r2, r3, r4, lr }
.   154  00000475E      0B083  sub       sp,#12
    Cores.GetCoreId(cid);
.   156  000004760      04668  mov       r0,sp
.   158  000004762  0F7FCF859  bl.w      Ext Proc #2
.   162  000004766      0E000  b         0 -> 166
.   164  000004768      0006C  <LineNo: 108>
    ctx := coreCon[cid];
.   166  00000476A      09800  ldr       r0,[sp]
.   168  00000476C      02801  cmp       r0,#1
.   170  00000476E      0D301  bcc.n     2 -> 176
.   172  000004770      0DF01  svc       1
.   174  000004772      0006D  <LineNo: 109>
.   176  000004774  0F8DF10B8  ldr.w     r1,[pc,#184] -> 364
.   180  000004778      00082  lsls      r2,r0,#2
.   182  00000477A  0EB020001  add.w     r0,r2,r1
.   186  00000477E      06800  ldr       r0,[r0]
.   188  000004780      09002  str       r0,[sp,#8]
    res := Failed;
.   190  000004782      02001  movs      r0,#1
.   192  000004784      09907  ldr       r1,[sp,#28]
.   194  000004786      06008  str       r0,[r1]
    IF ctx.numThreads < MaxNumThreads THEN
.   196  000004788      09802  ldr       r0,[sp,#8]
.   198  00000478A      06CC0  ldr       r0,[r0,#76]
.   200  00000478C      02810  cmp       r0,#16
.   202  00000478E  0F280804C  bge.w     152 -> 358
      tid := ctx.numThreads;
.   206  000004792      09802  ldr       r0,[sp,#8]
.   208  000004794      06CC0  ldr       r0,[r0,#76]
.   210  000004796      09906  ldr       r1,[sp,#24]
.   212  000004798      06008  str       r0,[r1]
      t := ctx.threads[tid];
.   214  00000479A      09806  ldr       r0,[sp,#24]
.   216  00000479C      06800  ldr       r0,[r0]
.   218  00000479E      02810  cmp       r0,#16
.   220  0000047A0      0D301  bcc.n     2 -> 226
.   222  0000047A2      0DF01  svc       1
.   224  0000047A4      00071  <LineNo: 113>
.   226  0000047A6      09902  ldr       r1,[sp,#8]
.   228  0000047A8      00082  lsls      r2,r0,#2
.   230  0000047AA  0EB020001  add.w     r0,r2,r1
.   234  0000047AE      06800  ldr       r0,[r0]
.   236  0000047B0      09905  ldr       r1,[sp,#20]
.   238  0000047B2      06008  str       r0,[r1]
      INC(ctx.numThreads);
.   240  0000047B4      09802  ldr       r0,[sp,#8]
.   242  0000047B6      06CC1  ldr       r1,[r0,#76]
.   244  0000047B8      03101  adds      r1,#1
.   246  0000047BA      064C1  str       r1,[r0,#76]
      t.state := StateSuspended;
.   248  0000047BC      09805  ldr       r0,[sp,#20]
.   250  0000047BE      06800  ldr       r0,[r0]
.   252  0000047C0      02101  movs      r1,#1
.   254  0000047C2      06081  str       r1,[r0,#8]
      t.prio := DefaultPrio;
.   256  0000047C4      09805  ldr       r0,[sp,#20]
.   258  0000047C6      06800  ldr       r0,[r0]
.   260  0000047C8      02107  movs      r1,#7
.   262  0000047CA      06001  str       r1,[r0]
      t.period := 0; t.delay := 0; t.devAddr := 0;
.   264  0000047CC      09805  ldr       r0,[sp,#20]
.   266  0000047CE      06800  ldr       r0,[r0]
.   268  0000047D0      02100  movs      r1,#0
.   270  0000047D2      060C1  str       r1,[r0,#12]
.   272  0000047D4      09805  ldr       r0,[sp,#20]
.   274  0000047D6      06800  ldr       r0,[r0]
.   276  0000047D8      02100  movs      r1,#0
.   278  0000047DA      06141  str       r1,[r0,#20]
.   280  0000047DC      09805  ldr       r0,[sp,#20]
.   282  0000047DE      06800  ldr       r0,[r0]
.   284  0000047E0      02100  movs      r1,#0
.   286  0000047E2      06181  str       r1,[r0,#24]
      Memory.AllocThreadStack(stackAddr, tid, stackSize);
.   288  0000047E4  0F11D0004  adds.w    r0,sp,#4
.   292  0000047E8      09906  ldr       r1,[sp,#24]
.   294  0000047EA      06809  ldr       r1,[r1]
.   296  0000047EC      09A04  ldr       r2,[sp,#16]
.   298  0000047EE  0F7FCF9EF  bl.w      Ext Proc #6
.   302  0000047F2      0E000  b         0 -> 306
.   304  0000047F4      00076  <LineNo: 118>
      IF stackAddr # 0 THEN
.   306  0000047F6      09801  ldr       r0,[sp,#4]
.   308  0000047F8      02800  cmp       r0,#0
.   310  0000047FA  0F0008016  beq.w     44 -> 358
        Coroutines.Init(t.cor, stackAddr, stackSize, tid);
.   314  0000047FE      09805  ldr       r0,[sp,#20]
.   316  000004800      06800  ldr       r0,[r0]
.   318  000004802      06A40  ldr       r0,[r0,#36]
.   320  000004804      09901  ldr       r1,[sp,#4]
.   322  000004806      09A04  ldr       r2,[sp,#16]
.   324  000004808      09B06  ldr       r3,[sp,#24]
.   326  00000480A      0681B  ldr       r3,[r3]
.   328  00000480C  0F7FFFF0E  bl.w      Ext Proc #4
.   332  000004810      0E000  b         0 -> 336
.   334  000004812      00078  <LineNo: 120>
        Coroutines.Allocate(t.cor, proc);
.   336  000004814      09805  ldr       r0,[sp,#20]
.   338  000004816      06800  ldr       r0,[r0]
.   340  000004818      06A40  ldr       r0,[r0,#36]
.   342  00000481A      09903  ldr       r1,[sp,#12]
.   344  00000481C  0F7FFFEF6  bl.w      Ext Proc #3
.   348  000004820      0E000  b         0 -> 352
.   350  000004822      00079  <LineNo: 121>
        res := NoError
      END
.   352  000004824      02000  movs      r0,#0
.   354  000004826      09907  ldr       r1,[sp,#28]
.   356  000004828      06008  str       r0,[r1]
    END
  END Allocate;
.   358  00000482A      0B008  add       sp,#32
.   360  00000482C      0BD00  pop       { pc }
.   362  00000482E      0BF00  nop       
.   364  000004830  020027E88  <Global: Kernel data>


  PROCEDURE Reallocate*(t: Thread; proc: PROC; VAR res: INTEGER);
  BEGIN
.   368  000004834      0B507  push      { r0, r1, r2, lr }
    res := Failed;
.   370  000004836      02001  movs      r0,#1
.   372  000004838      09902  ldr       r1,[sp,#8]
.   374  00000483A      06008  str       r0,[r1]
    IF t.state = StateSuspended THEN
.   376  00000483C      09800  ldr       r0,[sp]
.   378  00000483E      06880  ldr       r0,[r0,#8]
.   380  000004840      02801  cmp       r0,#1
.   382  000004842  0F0408016  bne.w     44 -> 430
      t.prio := DefaultPrio;
.   386  000004846      02007  movs      r0,#7
.   388  000004848      09900  ldr       r1,[sp]
.   390  00000484A      06008  str       r0,[r1]
      t.period := 0; t.delay := 0;
.   392  00000484C      02000  movs      r0,#0
.   394  00000484E      09900  ldr       r1,[sp]
.   396  000004850      060C8  str       r0,[r1,#12]
.   398  000004852      02000  movs      r0,#0
.   400  000004854      09900  ldr       r1,[sp]
.   402  000004856      06148  str       r0,[r1,#20]
      t.devAddr := 0;
.   404  000004858      02000  movs      r0,#0
.   406  00000485A      09900  ldr       r1,[sp]
.   408  00000485C      06188  str       r0,[r1,#24]
      Coroutines.Allocate(t.cor, proc);
.   410  00000485E      09800  ldr       r0,[sp]
.   412  000004860      06A40  ldr       r0,[r0,#36]
.   414  000004862      09901  ldr       r1,[sp,#4]
.   416  000004864  0F7FFFED2  bl.w      Ext Proc #3
.   420  000004868      0E000  b         0 -> 424
.   422  00000486A      00087  <LineNo: 135>
      res := NoError
    END
.   424  00000486C      02000  movs      r0,#0
.   426  00000486E      09902  ldr       r1,[sp,#8]
.   428  000004870      06008  str       r0,[r1]
  END Reallocate;
.   430  000004872      0B003  add       sp,#12
.   432  000004874      0BD00  pop       { pc }
.   434  000004876      0BF00  nop       



  PROCEDURE* Enable*(t: Thread);
  BEGIN
.   436  000004878      0B500  push      { lr }
    ASSERT(t # NIL, Errors.PreCond);
.   438  00000487A      02800  cmp       r0,#0
.   440  00000487C      0D101  bne.n     2 -> 446
.   442  00000487E      0DF22  svc       34
.   444  000004880      00090  <LineNo: 144>
    t.state := StateEnabled
  END Enable;
.   446  000004882      02100  movs      r1,#0
.   448  000004884      06081  str       r1,[r0,#8]
.   450  000004886      0BD00  pop       { pc }


  (* in-process api *)

  PROCEDURE Next*;
    VAR cid: INTEGER; ctx: CoreContext;
  BEGIN
.   452  000004888      0B500  push      { lr }
.   454  00000488A      0B082  sub       sp,#8
    Cores.GetCoreId(cid);
.   456  00000488C      04668  mov       r0,sp
.   458  00000488E  0F7FBFFC3  bl.w      Ext Proc #2
.   462  000004892      0E000  b         0 -> 466
.   464  000004894      0009A  <LineNo: 154>
    ctx := coreCon[cid];
.   466  000004896      09800  ldr       r0,[sp]
.   468  000004898      02801  cmp       r0,#1
.   470  00000489A      0D301  bcc.n     2 -> 476
.   472  00000489C      0DF01  svc       1
.   474  00000489E      0009B  <LineNo: 155>
.   476  0000048A0  0F8DF1020  ldr.w     r1,[pc,#32] -> 512
.   480  0000048A4      00082  lsls      r2,r0,#2
.   482  0000048A6  0EB020001  add.w     r0,r2,r1
.   486  0000048AA      06800  ldr       r0,[r0]
.   488  0000048AC      09001  str       r0,[sp,#4]
    Coroutines.Transfer(ctx.Ct.cor, ctx.loop)
.   490  0000048AE      09801  ldr       r0,[sp,#4]
.   492  0000048B0      06C00  ldr       r0,[r0,#64]
.   494  0000048B2      06A40  ldr       r0,[r0,#36]
.   496  0000048B4      09901  ldr       r1,[sp,#4]
.   498  0000048B6      06D49  ldr       r1,[r1,#84]
  END Next;
.   500  0000048B8  0F7FFFEC2  bl.w      Ext Proc #5
.   504  0000048BC      0E000  b         0 -> 508
.   506  0000048BE      0009C  <LineNo: 156>
.   508  0000048C0      0B002  add       sp,#8
.   510  0000048C2      0BD00  pop       { pc }
.   512  0000048C4  020027E88  <Global: Kernel data>


  PROCEDURE NextQueued*(): Thread;
    VAR cid: INTEGER;
  BEGIN
.   516  0000048C8      0B500  push      { lr }
.   518  0000048CA      0B081  sub       sp,#4
    Cores.GetCoreId(cid);
.   520  0000048CC      04668  mov       r0,sp
.   522  0000048CE  0F7FBFFA3  bl.w      Ext Proc #2
.   526  0000048D2      0E000  b         0 -> 530
.   528  0000048D4      000A3  <LineNo: 163>
    RETURN coreCon[cid].ct
.   530  0000048D6      09800  ldr       r0,[sp]
.   532  0000048D8      02801  cmp       r0,#1
.   534  0000048DA      0D301  bcc.n     2 -> 540
.   536  0000048DC      0DF01  svc       1
.   538  0000048DE      000A3  <LineNo: 163>
.   540  0000048E0  0F8DF1010  ldr.w     r1,[pc,#16] -> 560
.   544  0000048E4      00082  lsls      r2,r0,#2
.   546  0000048E6  0EB020001  add.w     r0,r2,r1
.   550  0000048EA      06800  ldr       r0,[r0]
  END NextQueued;
.   552  0000048EC      06C40  ldr       r0,[r0,#68]
.   554  0000048EE      0B001  add       sp,#4
.   556  0000048F0      0BD00  pop       { pc }
.   558  0000048F2      0BF00  nop       
.   560  0000048F4  020027E88  <Global: Kernel data>


  PROCEDURE SuspendMe*;
    VAR cid: INTEGER; ctx: CoreContext;
  BEGIN
.   564  0000048F8      0B500  push      { lr }
.   566  0000048FA      0B082  sub       sp,#8
    Cores.GetCoreId(cid);
.   568  0000048FC      04668  mov       r0,sp
.   570  0000048FE  0F7FBFF8B  bl.w      Ext Proc #2
.   574  000004902      0E000  b         0 -> 578
.   576  000004904      000AB  <LineNo: 171>
    ctx := coreCon[cid];
.   578  000004906      09800  ldr       r0,[sp]
.   580  000004908      02801  cmp       r0,#1
.   582  00000490A      0D301  bcc.n     2 -> 588
.   584  00000490C      0DF01  svc       1
.   586  00000490E      000AC  <LineNo: 172>
.   588  000004910  0F8DF1028  ldr.w     r1,[pc,#40] -> 632
.   592  000004914      00082  lsls      r2,r0,#2
.   594  000004916  0EB020001  add.w     r0,r2,r1
.   598  00000491A      06800  ldr       r0,[r0]
.   600  00000491C      09001  str       r0,[sp,#4]
    ctx.Ct.state := StateSuspended;
.   602  00000491E      09801  ldr       r0,[sp,#4]
.   604  000004920      06C00  ldr       r0,[r0,#64]
.   606  000004922      02101  movs      r1,#1
.   608  000004924      06081  str       r1,[r0,#8]
    Coroutines.Transfer(ctx.Ct.cor, ctx.loop)
.   610  000004926      09801  ldr       r0,[sp,#4]
.   612  000004928      06C00  ldr       r0,[r0,#64]
.   614  00000492A      06A40  ldr       r0,[r0,#36]
.   616  00000492C      09901  ldr       r1,[sp,#4]
.   618  00000492E      06D49  ldr       r1,[r1,#84]
  END SuspendMe;
.   620  000004930  0F7FFFE86  bl.w      Ext Proc #5
.   624  000004934      0E000  b         0 -> 628
.   626  000004936      000AE  <LineNo: 174>
.   628  000004938      0B002  add       sp,#8
.   630  00000493A      0BD00  pop       { pc }
.   632  00000493C  020027E88  <Global: Kernel data>


  PROCEDURE DelayMe*(delay: INTEGER);
    VAR cid: INTEGER; ctx: CoreContext;
  BEGIN
.   636  000004940      0B501  push      { r0, lr }
.   638  000004942      0B082  sub       sp,#8
    Cores.GetCoreId(cid);
.   640  000004944      04668  mov       r0,sp
.   642  000004946  0F7FBFF67  bl.w      Ext Proc #2
.   646  00000494A      0E000  b         0 -> 650
.   648  00000494C      000B5  <LineNo: 181>
    ctx := coreCon[cid];
.   650  00000494E      09800  ldr       r0,[sp]
.   652  000004950      02801  cmp       r0,#1
.   654  000004952      0D301  bcc.n     2 -> 660
.   656  000004954      0DF01  svc       1
.   658  000004956      000B6  <LineNo: 182>
.   660  000004958  0F8DF1028  ldr.w     r1,[pc,#40] -> 704
.   664  00000495C      00082  lsls      r2,r0,#2
.   666  00000495E  0EB020001  add.w     r0,r2,r1
.   670  000004962      06800  ldr       r0,[r0]
.   672  000004964      09001  str       r0,[sp,#4]
    ctx.Ct.delay := delay;
.   674  000004966      09801  ldr       r0,[sp,#4]
.   676  000004968      06C00  ldr       r0,[r0,#64]
.   678  00000496A      09902  ldr       r1,[sp,#8]
.   680  00000496C      06141  str       r1,[r0,#20]
    Coroutines.Transfer(ctx.Ct.cor, ctx.loop)
.   682  00000496E      09801  ldr       r0,[sp,#4]
.   684  000004970      06C00  ldr       r0,[r0,#64]
.   686  000004972      06A40  ldr       r0,[r0,#36]
.   688  000004974      09901  ldr       r1,[sp,#4]
.   690  000004976      06D49  ldr       r1,[r1,#84]
  END DelayMe;
.   692  000004978  0F7FFFE62  bl.w      Ext Proc #5
.   696  00000497C      0E000  b         0 -> 700
.   698  00000497E      000B8  <LineNo: 184>
.   700  000004980      0B003  add       sp,#12
.   702  000004982      0BD00  pop       { pc }
.   704  000004984  020027E88  <Global: Kernel data>


  PROCEDURE StartTimeout*(timeout: INTEGER);
    VAR cid: INTEGER;
  BEGIN
.   708  000004988      0B501  push      { r0, lr }
.   710  00000498A      0B081  sub       sp,#4
    Cores.GetCoreId(cid);
.   712  00000498C      04668  mov       r0,sp
.   714  00000498E  0F7FBFF43  bl.w      Ext Proc #2
.   718  000004992      0E000  b         0 -> 722
.   720  000004994      000BF  <LineNo: 191>
    coreCon[cid].Ct.delay := timeout
.   722  000004996      09800  ldr       r0,[sp]
.   724  000004998      02801  cmp       r0,#1
.   726  00000499A      0D301  bcc.n     2 -> 732
.   728  00000499C      0DF01  svc       1
.   730  00000499E      000C0  <LineNo: 192>
.   732  0000049A0  0F8DF1014  ldr.w     r1,[pc,#20] -> 756
.   736  0000049A4      00082  lsls      r2,r0,#2
.   738  0000049A6  0EB020001  add.w     r0,r2,r1
.   742  0000049AA      06800  ldr       r0,[r0]
.   744  0000049AC      06C00  ldr       r0,[r0,#64]
  END StartTimeout;
.   746  0000049AE      09901  ldr       r1,[sp,#4]
.   748  0000049B0      06141  str       r1,[r0,#20]
.   750  0000049B2      0B002  add       sp,#8
.   752  0000049B4      0BD00  pop       { pc }
.   754  0000049B6      0BF00  nop       
.   756  0000049B8  020027E88  <Global: Kernel data>


  PROCEDURE CancelTimeout*;
  BEGIN
.   760  0000049BC      0B500  push      { lr }
    StartTimeout(0)
.   762  0000049BE      02000  movs      r0,#0
  END CancelTimeout;
.   764  0000049C0  0F7FFFFE2  bl.w      -60 -> 708
.   768  0000049C4      0E000  b         0 -> 772
.   770  0000049C6      000C6  <LineNo: 198>
.   772  0000049C8      0BD00  pop       { pc }
.   774  0000049CA      0BF00  nop       


  PROCEDURE AwaitDeviceFlags*(addr: INTEGER; setFlags, clrFlags: SET);
  (**
    Await any of the 'setFlags' to be set, or any of the 'clrFlags'
    to be set or cleared by the hardware, respectively.
    Any resetting of the flags must be done by the thread.
    Device flag awaiting takes precedence over period.
    Can be combined with a delay for timeout, though.
  **)
    VAR cid: INTEGER; ctx: CoreContext;
  BEGIN
.   776  0000049CC      0B507  push      { r0, r1, r2, lr }
.   778  0000049CE      0B082  sub       sp,#8
    Cores.GetCoreId(cid);
.   780  0000049D0      04668  mov       r0,sp
.   782  0000049D2  0F7FBFF21  bl.w      Ext Proc #2
.   786  0000049D6      0E000  b         0 -> 790
.   788  0000049D8      000D4  <LineNo: 212>
    ctx := coreCon[cid];
.   790  0000049DA      09800  ldr       r0,[sp]
.   792  0000049DC      02801  cmp       r0,#1
.   794  0000049DE      0D301  bcc.n     2 -> 800
.   796  0000049E0      0DF01  svc       1
.   798  0000049E2      000D5  <LineNo: 213>
.   800  0000049E4  0F8DF1038  ldr.w     r1,[pc,#56] -> 860
.   804  0000049E8      00082  lsls      r2,r0,#2
.   806  0000049EA  0EB020001  add.w     r0,r2,r1
.   810  0000049EE      06800  ldr       r0,[r0]
.   812  0000049F0      09001  str       r0,[sp,#4]
    ctx.Ct.devAddr := addr;
.   814  0000049F2      09801  ldr       r0,[sp,#4]
.   816  0000049F4      06C00  ldr       r0,[r0,#64]
.   818  0000049F6      09902  ldr       r1,[sp,#8]
.   820  0000049F8      06181  str       r1,[r0,#24]
    ctx.Ct.devFlagsSet := setFlags;
.   822  0000049FA      09801  ldr       r0,[sp,#4]
.   824  0000049FC      06C00  ldr       r0,[r0,#64]
.   826  0000049FE      09903  ldr       r1,[sp,#12]
.   828  000004A00      061C1  str       r1,[r0,#28]
    ctx.Ct.devFlagsClr := clrFlags;
.   830  000004A02      09801  ldr       r0,[sp,#4]
.   832  000004A04      06C00  ldr       r0,[r0,#64]
.   834  000004A06      09904  ldr       r1,[sp,#16]
.   836  000004A08      06201  str       r1,[r0,#32]
    Coroutines.Transfer(ctx.Ct.cor, ctx.loop)
.   838  000004A0A      09801  ldr       r0,[sp,#4]
.   840  000004A0C      06C00  ldr       r0,[r0,#64]
.   842  000004A0E      06A40  ldr       r0,[r0,#36]
.   844  000004A10      09901  ldr       r1,[sp,#4]
.   846  000004A12      06D49  ldr       r1,[r1,#84]
  END AwaitDeviceFlags;
.   848  000004A14  0F7FFFE14  bl.w      Ext Proc #5
.   852  000004A18      0E000  b         0 -> 856
.   854  000004A1A      000D9  <LineNo: 217>
.   856  000004A1C      0B005  add       sp,#20
.   858  000004A1E      0BD00  pop       { pc }
.   860  000004A20  020027E88  <Global: Kernel data>


  PROCEDURE CancelAwaitDeviceFlags*;
    VAR cid: INTEGER; ctx: CoreContext;
  BEGIN
.   864  000004A24      0B500  push      { lr }
.   866  000004A26      0B082  sub       sp,#8
    Cores.GetCoreId(cid);
.   868  000004A28      04668  mov       r0,sp
.   870  000004A2A  0F7FBFEF5  bl.w      Ext Proc #2
.   874  000004A2E      0E000  b         0 -> 878
.   876  000004A30      000E0  <LineNo: 224>
    ctx := coreCon[cid];
.   878  000004A32      09800  ldr       r0,[sp]
.   880  000004A34      02801  cmp       r0,#1
.   882  000004A36      0D301  bcc.n     2 -> 888
.   884  000004A38      0DF01  svc       1
.   886  000004A3A      000E1  <LineNo: 225>
.   888  000004A3C  0F8DF1018  ldr.w     r1,[pc,#24] -> 916
.   892  000004A40      00082  lsls      r2,r0,#2
.   894  000004A42  0EB020001  add.w     r0,r2,r1
.   898  000004A46      06800  ldr       r0,[r0]
.   900  000004A48      09001  str       r0,[sp,#4]
    ctx.Ct.devAddr := 0
.   902  000004A4A      09801  ldr       r0,[sp,#4]
.   904  000004A4C      06C00  ldr       r0,[r0,#64]
  END CancelAwaitDeviceFlags;
.   906  000004A4E      02100  movs      r1,#0
.   908  000004A50      06181  str       r1,[r0,#24]
.   910  000004A52      0B002  add       sp,#8
.   912  000004A54      0BD00  pop       { pc }
.   914  000004A56      0BF00  nop       
.   916  000004A58  020027E88  <Global: Kernel data>


  PROCEDURE SetPrio*(prio: INTEGER);
    VAR cid: INTEGER;
  BEGIN
.   920  000004A5C      0B501  push      { r0, lr }
.   922  000004A5E      0B081  sub       sp,#4
    Cores.GetCoreId(cid);
.   924  000004A60      04668  mov       r0,sp
.   926  000004A62  0F7FBFED9  bl.w      Ext Proc #2
.   930  000004A66      0E000  b         0 -> 934
.   932  000004A68      000E9  <LineNo: 233>
    coreCon[cid].Ct.prio := prio
.   934  000004A6A      09800  ldr       r0,[sp]
.   936  000004A6C      02801  cmp       r0,#1
.   938  000004A6E      0D301  bcc.n     2 -> 944
.   940  000004A70      0DF01  svc       1
.   942  000004A72      000EA  <LineNo: 234>
.   944  000004A74  0F8DF1014  ldr.w     r1,[pc,#20] -> 968
.   948  000004A78      00082  lsls      r2,r0,#2
.   950  000004A7A  0EB020001  add.w     r0,r2,r1
.   954  000004A7E      06800  ldr       r0,[r0]
.   956  000004A80      06C00  ldr       r0,[r0,#64]
  END SetPrio;
.   958  000004A82      09901  ldr       r1,[sp,#4]
.   960  000004A84      06001  str       r1,[r0]
.   962  000004A86      0B002  add       sp,#8
.   964  000004A88      0BD00  pop       { pc }
.   966  000004A8A      0BF00  nop       
.   968  000004A8C  020027E88  <Global: Kernel data>


  PROCEDURE SetPeriod*(period, startAfter: INTEGER); (* as number of ticks *)
     VAR cid: INTEGER; ctx: CoreContext;
  BEGIN
.   972  000004A90      0B503  push      { r0, r1, lr }
.   974  000004A92      0B082  sub       sp,#8
    Cores.GetCoreId(cid);
.   976  000004A94      04668  mov       r0,sp
.   978  000004A96  0F7FBFEBF  bl.w      Ext Proc #2
.   982  000004A9A      0E000  b         0 -> 986
.   984  000004A9C      000F1  <LineNo: 241>
    ctx := coreCon[cid];
.   986  000004A9E      09800  ldr       r0,[sp]
.   988  000004AA0      02801  cmp       r0,#1
.   990  000004AA2      0D301  bcc.n     2 -> 996
.   992  000004AA4      0DF01  svc       1
.   994  000004AA6      000F2  <LineNo: 242>
.   996  000004AA8  0F8DF1030  ldr.w     r1,[pc,#48] -> 1048
.  1000  000004AAC      00082  lsls      r2,r0,#2
.  1002  000004AAE  0EB020001  add.w     r0,r2,r1
.  1006  000004AB2      06800  ldr       r0,[r0]
.  1008  000004AB4      09001  str       r0,[sp,#4]
    ctx.Ct.period := period * ctx.loopPeriod;
.  1010  000004AB6      09801  ldr       r0,[sp,#4]
.  1012  000004AB8      06C00  ldr       r0,[r0,#64]
.  1014  000004ABA      09902  ldr       r1,[sp,#8]
.  1016  000004ABC      09A01  ldr       r2,[sp,#4]
.  1018  000004ABE      06D12  ldr       r2,[r2,#80]
.  1020  000004AC0  0FB01F102  mul.w     r1,r1,r2
.  1024  000004AC4      060C1  str       r1,[r0,#12]
    ctx.Ct.ticker := startAfter * ctx.loopPeriod
.  1026  000004AC6      09801  ldr       r0,[sp,#4]
.  1028  000004AC8      06C00  ldr       r0,[r0,#64]
  END SetPeriod;
.  1030  000004ACA      09903  ldr       r1,[sp,#12]
.  1032  000004ACC      09A01  ldr       r2,[sp,#4]
.  1034  000004ACE      06D12  ldr       r2,[r2,#80]
.  1036  000004AD0  0FB01F102  mul.w     r1,r1,r2
.  1040  000004AD4      06101  str       r1,[r0,#16]
.  1042  000004AD6      0B004  add       sp,#16
.  1044  000004AD8      0BD00  pop       { pc }
.  1046  000004ADA      0BF00  nop       
.  1048  000004ADC  020027E88  <Global: Kernel data>


  PROCEDURE Ct*(): Thread;
    VAR cid: INTEGER;
  BEGIN
.  1052  000004AE0      0B500  push      { lr }
.  1054  000004AE2      0B081  sub       sp,#4
    Cores.GetCoreId(cid);
.  1056  000004AE4      04668  mov       r0,sp
.  1058  000004AE6  0F7FBFE97  bl.w      Ext Proc #2
.  1062  000004AEA      0E000  b         0 -> 1066
.  1064  000004AEC      000FB  <LineNo: 251>
    RETURN coreCon[cid].Ct
.  1066  000004AEE      09800  ldr       r0,[sp]
.  1068  000004AF0      02801  cmp       r0,#1
.  1070  000004AF2      0D301  bcc.n     2 -> 1076
.  1072  000004AF4      0DF01  svc       1
.  1074  000004AF6      000FB  <LineNo: 251>
.  1076  000004AF8  0F8DF1010  ldr.w     r1,[pc,#16] -> 1096
.  1080  000004AFC      00082  lsls      r2,r0,#2
.  1082  000004AFE  0EB020001  add.w     r0,r2,r1
.  1086  000004B02      06800  ldr       r0,[r0]
  END Ct;
.  1088  000004B04      06C00  ldr       r0,[r0,#64]
.  1090  000004B06      0B001  add       sp,#4
.  1092  000004B08      0BD00  pop       { pc }
.  1094  000004B0A      0BF00  nop       
.  1096  000004B0C  020027E88  <Global: Kernel data>


  PROCEDURE Tid*(): INTEGER;
    VAR cid: INTEGER;
  BEGIN
.  1100  000004B10      0B500  push      { lr }
.  1102  000004B12      0B081  sub       sp,#4
    Cores.GetCoreId(cid);
.  1104  000004B14      04668  mov       r0,sp
.  1106  000004B16  0F7FBFE7F  bl.w      Ext Proc #2
.  1110  000004B1A      0E000  b         0 -> 1114
.  1112  000004B1C      00103  <LineNo: 259>
    RETURN coreCon[cid].Ct.tid
.  1114  000004B1E      09800  ldr       r0,[sp]
.  1116  000004B20      02801  cmp       r0,#1
.  1118  000004B22      0D301  bcc.n     2 -> 1124
.  1120  000004B24      0DF01  svc       1
.  1122  000004B26      00103  <LineNo: 259>
.  1124  000004B28  0F8DF1010  ldr.w     r1,[pc,#16] -> 1144
.  1128  000004B2C      00082  lsls      r2,r0,#2
.  1130  000004B2E  0EB020001  add.w     r0,r2,r1
.  1134  000004B32      06800  ldr       r0,[r0]
.  1136  000004B34      06C00  ldr       r0,[r0,#64]
  END Tid;
.  1138  000004B36      06840  ldr       r0,[r0,#4]
.  1140  000004B38      0B001  add       sp,#4
.  1142  000004B3A      0BD00  pop       { pc }
.  1144  000004B3C  020027E88  <Global: Kernel data>


  PROCEDURE Prio*(t: Thread): INTEGER;
    RETURN t.prio
.  1148  000004B40      0B501  push      { r0, lr }
  END Prio;
.  1150  000004B42      09800  ldr       r0,[sp]
.  1152  000004B44      06800  ldr       r0,[r0]
.  1154  000004B46      0B001  add       sp,#4
.  1156  000004B48      0BD00  pop       { pc }
.  1158  000004B4A      0BF00  nop       


  PROCEDURE Trigger*(): INTEGER;
    VAR cid: INTEGER;
  BEGIN
.  1160  000004B4C      0B500  push      { lr }
.  1162  000004B4E      0B081  sub       sp,#4
    Cores.GetCoreId(cid);
.  1164  000004B50      04668  mov       r0,sp
.  1166  000004B52  0F7FBFE61  bl.w      Ext Proc #2
.  1170  000004B56      0E000  b         0 -> 1174
.  1172  000004B58      00110  <LineNo: 272>
    RETURN coreCon[cid].Ct.trigCode
.  1174  000004B5A      09800  ldr       r0,[sp]
.  1176  000004B5C      02801  cmp       r0,#1
.  1178  000004B5E      0D301  bcc.n     2 -> 1184
.  1180  000004B60      0DF01  svc       1
.  1182  000004B62      00110  <LineNo: 272>
.  1184  000004B64  0F8DF1010  ldr.w     r1,[pc,#16] -> 1204
.  1188  000004B68      00082  lsls      r2,r0,#2
.  1190  000004B6A  0EB020001  add.w     r0,r2,r1
.  1194  000004B6E      06800  ldr       r0,[r0]
.  1196  000004B70      06C00  ldr       r0,[r0,#64]
  END Trigger;
.  1198  000004B72      06A80  ldr       r0,[r0,#40]
.  1200  000004B74      0B001  add       sp,#4
.  1202  000004B76      0BD00  pop       { pc }
.  1204  000004B78  020027E88  <Global: Kernel data>

  (* scheduler coroutine code *)

  PROCEDURE loopc;
    VAR tid, cid: INTEGER; t, t0: Thread; ctx: CoreContext; devFlags: SET;
  BEGIN
.  1208  000004B7C      0B500  push      { lr }
.  1210  000004B7E      0B086  sub       sp,#24
    Cores.GetCoreId(cid);;
.  1212  000004B80  0F11D0004  adds.w    r0,sp,#4
.  1216  000004B84  0F7FBFE48  bl.w      Ext Proc #2
.  1220  000004B88      0E000  b         0 -> 1224
.  1222  000004B8A      00119  <LineNo: 281>
    Memory.ResetMainStack; (* for clean stack traces in main stack *)
.  1224  000004B8C  0F7FCF8E0  bl.w      Ext Proc #9
.  1228  000004B90      0E000  b         0 -> 1232
.  1230  000004B92      0011A  <LineNo: 282>
    ctx := coreCon[cid];
.  1232  000004B94      09801  ldr       r0,[sp,#4]
.  1234  000004B96      02801  cmp       r0,#1
.  1236  000004B98      0D301  bcc.n     2 -> 1242
.  1238  000004B9A      0DF01  svc       1
.  1240  000004B9C      0011B  <LineNo: 283>
.  1242  000004B9E  0F8DF11C8  ldr.w     r1,[pc,#456] -> 1700
.  1246  000004BA2      00082  lsls      r2,r0,#2
.  1248  000004BA4  0EB020001  add.w     r0,r2,r1
.  1252  000004BA8      06800  ldr       r0,[r0]
.  1254  000004BAA      09004  str       r0,[sp,#16]
    ctx.Ct := NIL;
.  1256  000004BAC      02000  movs      r0,#0
.  1258  000004BAE      09904  ldr       r1,[sp,#16]
.  1260  000004BB0      06408  str       r0,[r1,#64]
    REPEAT
      IF SysTick.Tick() THEN
.  1262  000004BB2  0F7FFFD57  bl.w      Ext Proc #1
.  1266  000004BB6      0E000  b         0 -> 1270
.  1268  000004BB8      0011E  <LineNo: 286>
.  1270  000004BBA  0F0100F01  tst.w     r0,#1
.  1274  000004BBE  0F00080A7  beq.w     334 -> 1612
        tid := 0;
.  1278  000004BC2      02000  movs      r0,#0
.  1280  000004BC4      09000  str       r0,[sp]
        WHILE tid < ctx.numThreads DO
.  1282  000004BC6      09800  ldr       r0,[sp]
.  1284  000004BC8      09904  ldr       r1,[sp,#16]
.  1286  000004BCA      06CC9  ldr       r1,[r1,#76]
.  1288  000004BCC      04288  cmp       r0,r1
.  1290  000004BCE  0F280809F  bge.w     318 -> 1612
          t := ctx.threads[tid];
.  1294  000004BD2      09800  ldr       r0,[sp]
.  1296  000004BD4      02810  cmp       r0,#16
.  1298  000004BD6      0D301  bcc.n     2 -> 1304
.  1300  000004BD8      0DF01  svc       1
.  1302  000004BDA      00121  <LineNo: 289>
.  1304  000004BDC      09904  ldr       r1,[sp,#16]
.  1306  000004BDE      00082  lsls      r2,r0,#2
.  1308  000004BE0  0EB020001  add.w     r0,r2,r1
.  1312  000004BE4      06800  ldr       r0,[r0]
.  1314  000004BE6      09002  str       r0,[sp,#8]
          t0 := NIL;
.  1316  000004BE8      02000  movs      r0,#0
.  1318  000004BEA      09003  str       r0,[sp,#12]
          IF t.state = StateEnabled THEN
.  1320  000004BEC      09802  ldr       r0,[sp,#8]
.  1322  000004BEE      06880  ldr       r0,[r0,#8]
.  1324  000004BF0      02800  cmp       r0,#0
.  1326  000004BF2  0F040807E  bne.w     252 -> 1582
            t.trigCode := TrigNone;
.  1330  000004BF6      02000  movs      r0,#0
.  1332  000004BF8      09902  ldr       r1,[sp,#8]
.  1334  000004BFA      06288  str       r0,[r1,#40]
            IF (t.delay <= 0) & (t.period = 0) & (t.devAddr = 0) THEN (* no triggers *)
.  1336  000004BFC      09802  ldr       r0,[sp,#8]
.  1338  000004BFE      06940  ldr       r0,[r0,#20]
.  1340  000004C00      02800  cmp       r0,#0
.  1342  000004C02  0F300800E  bgt.w     28 -> 1374
.  1346  000004C06      09802  ldr       r0,[sp,#8]
.  1348  000004C08      068C0  ldr       r0,[r0,#12]
.  1350  000004C0A      02800  cmp       r0,#0
.  1352  000004C0C  0F0408009  bne.w     18 -> 1374
.  1356  000004C10      09802  ldr       r0,[sp,#8]
.  1358  000004C12      06980  ldr       r0,[r0,#24]
.  1360  000004C14      02800  cmp       r0,#0
.  1362  000004C16  0F0408004  bne.w     8 -> 1374
              t0 := t;
.  1366  000004C1A      09802  ldr       r0,[sp,#8]
.  1368  000004C1C      09003  str       r0,[sp,#12]
            ELSE
              IF t.period > 0 THEN (* keep the periodic timing on schedule in any case *)
.  1370  000004C1E  0F000B868  b.w       208 -> 1582
.  1374  000004C22      09802  ldr       r0,[sp,#8]
.  1376  000004C24      068C0  ldr       r0,[r0,#12]
.  1378  000004C26      02800  cmp       r0,#0
.  1380  000004C28  0F3408017  ble.w     46 -> 1430
                DEC(t.ticker, ctx.loopPeriod);
.  1384  000004C2C      09804  ldr       r0,[sp,#16]
.  1386  000004C2E      06D00  ldr       r0,[r0,#80]
.  1388  000004C30      09902  ldr       r1,[sp,#8]
.  1390  000004C32      03110  adds      r1,#16
.  1392  000004C34      0680A  ldr       r2,[r1]
.  1394  000004C36  0EBA20200  sub.w     r2,r2,r0
.  1398  000004C3A      0600A  str       r2,[r1]
                IF t.ticker <= 0 THEN
.  1400  000004C3C      09802  ldr       r0,[sp,#8]
.  1402  000004C3E      06900  ldr       r0,[r0,#16]
.  1404  000004C40      02800  cmp       r0,#0
.  1406  000004C42  0F300800A  bgt.w     20 -> 1430
                  t.ticker := t.ticker + t.period;
.  1410  000004C46      09802  ldr       r0,[sp,#8]
.  1412  000004C48      06900  ldr       r0,[r0,#16]
.  1414  000004C4A      09902  ldr       r1,[sp,#8]
.  1416  000004C4C      068C9  ldr       r1,[r1,#12]
.  1418  000004C4E      04408  add       r0,r1
.  1420  000004C50      09902  ldr       r1,[sp,#8]
.  1422  000004C52      06108  str       r0,[r1,#16]
                  t.trigCode := TrigPeriod
                  (* don't slot in here *)
                END
.  1424  000004C54      02001  movs      r0,#1
.  1426  000004C56      09902  ldr       r1,[sp,#8]
.  1428  000004C58      06288  str       r0,[r1,#40]
              END;
              IF t.delay > 0 THEN (* on delay or timeout *)
.  1430  000004C5A      09802  ldr       r0,[sp,#8]
.  1432  000004C5C      06940  ldr       r0,[r0,#20]
.  1434  000004C5E      02800  cmp       r0,#0
.  1436  000004C60  0F3408012  ble.w     36 -> 1476
                DEC(t.delay, ctx.loopPeriod);
.  1440  000004C64      09804  ldr       r0,[sp,#16]
.  1442  000004C66      06D00  ldr       r0,[r0,#80]
.  1444  000004C68      09902  ldr       r1,[sp,#8]
.  1446  000004C6A      03114  adds      r1,#20
.  1448  000004C6C      0680A  ldr       r2,[r1]
.  1450  000004C6E  0EBA20200  sub.w     r2,r2,r0
.  1454  000004C72      0600A  str       r2,[r1]
                IF t.delay <= 0 THEN
.  1456  000004C74      09802  ldr       r0,[sp,#8]
.  1458  000004C76      06940  ldr       r0,[r0,#20]
.  1460  000004C78      02800  cmp       r0,#0
.  1462  000004C7A  0F3008005  bgt.w     10 -> 1476
                  t0 := t;
.  1466  000004C7E      09802  ldr       r0,[sp,#8]
.  1468  000004C80      09003  str       r0,[sp,#12]
                  t.trigCode := TrigDelay
                END
.  1470  000004C82      02002  movs      r0,#2
.  1472  000004C84      09902  ldr       r1,[sp,#8]
.  1474  000004C86      06288  str       r0,[r1,#40]
              END;
              IF t.devAddr # 0 THEN (* waiting for device flags *)
.  1476  000004C88      09802  ldr       r0,[sp,#8]
.  1478  000004C8A      06980  ldr       r0,[r0,#24]
.  1480  000004C8C      02800  cmp       r0,#0
.  1482  000004C8E  0F000801F  beq.w     62 -> 1548
                SYSTEM.GET(t.devAddr, devFlags);
.  1486  000004C92      09802  ldr       r0,[sp,#8]
.  1488  000004C94      06980  ldr       r0,[r0,#24]
.  1490  000004C96      06801  ldr       r1,[r0]
.  1492  000004C98      09105  str       r1,[sp,#20]
                IF (t.devFlagsSet * devFlags # {}) OR (devFlags * t.devFlagsClr # t.devFlagsClr) THEN
.  1494  000004C9A      09802  ldr       r0,[sp,#8]
.  1496  000004C9C      069C0  ldr       r0,[r0,#28]
.  1498  000004C9E      09905  ldr       r1,[sp,#20]
.  1500  000004CA0      04008  ands      r0,r1
.  1502  000004CA2      02100  movs      r1,#0
.  1504  000004CA4  0EA900F01  teq.w     r0,r1
.  1508  000004CA8  0F040800A  bne.w     20 -> 1532
.  1512  000004CAC      09805  ldr       r0,[sp,#20]
.  1514  000004CAE      09902  ldr       r1,[sp,#8]
.  1516  000004CB0      06A09  ldr       r1,[r1,#32]
.  1518  000004CB2      04008  ands      r0,r1
.  1520  000004CB4      09902  ldr       r1,[sp,#8]
.  1522  000004CB6      06A09  ldr       r1,[r1,#32]
.  1524  000004CB8  0EA900F01  teq.w     r0,r1
.  1528  000004CBC  0F0008008  beq.w     16 -> 1548
                  t0 := t;
.  1532  000004CC0      09802  ldr       r0,[sp,#8]
.  1534  000004CC2      09003  str       r0,[sp,#12]
                  t.devAddr := 0;
.  1536  000004CC4      02000  movs      r0,#0
.  1538  000004CC6      09902  ldr       r1,[sp,#8]
.  1540  000004CC8      06188  str       r0,[r1,#24]
                  t.trigCode := TrigDevice
                END
.  1542  000004CCA      02003  movs      r0,#3
.  1544  000004CCC      09902  ldr       r1,[sp,#8]
.  1546  000004CCE      06288  str       r0,[r1,#40]
              END;
              IF t.trigCode = TrigPeriod THEN (* see above *)
.  1548  000004CD0      09802  ldr       r0,[sp,#8]
.  1550  000004CD2      06A80  ldr       r0,[r0,#40]
.  1552  000004CD4      02801  cmp       r0,#1
.  1554  000004CD6  0F040800C  bne.w     24 -> 1582
                IF (t.delay <= 0) & (t.devAddr = 0) THEN (* delay and device flags take precedence *)
.  1558  000004CDA      09802  ldr       r0,[sp,#8]
.  1560  000004CDC      06940  ldr       r0,[r0,#20]
.  1562  000004CDE      02800  cmp       r0,#0
.  1564  000004CE0  0F3008007  bgt.w     14 -> 1582
.  1568  000004CE4      09802  ldr       r0,[sp,#8]
.  1570  000004CE6      06980  ldr       r0,[r0,#24]
.  1572  000004CE8      02800  cmp       r0,#0
.  1574  000004CEA  0F0408002  bne.w     4 -> 1582
                  t0 := t
                END
.  1578  000004CEE      09802  ldr       r0,[sp,#8]
.  1580  000004CF0      09003  str       r0,[sp,#12]
              END
            END
          END;
          IF t0 # NIL THEN
.  1582  000004CF2      09803  ldr       r0,[sp,#12]
.  1584  000004CF4      02800  cmp       r0,#0
.  1586  000004CF6  0F0008006  beq.w     12 -> 1602
            slotIn(t0, ctx)
.  1590  000004CFA      09803  ldr       r0,[sp,#12]
.  1592  000004CFC      09904  ldr       r1,[sp,#16]
          END;
.  1594  000004CFE  0F7FFFCF7  bl.w      -1554 -> 44
.  1598  000004D02      0E000  b         0 -> 1602
.  1600  000004D04      00147  <LineNo: 327>
          INC(tid)
        END
.  1602  000004D06      09800  ldr       r0,[sp]
.  1604  000004D08      03001  adds      r0,#1
.  1606  000004D0A      09000  str       r0,[sp]
.  1608  000004D0C  0F7FFBF5B  b.w       -330 -> 1282
      END;
      (* print ready-queue for debugging *)
      (* cannot be used together with UARTkstr, simply use UARTstr in Main.mod *)
      (*
      IF ctx.ct # NIL THEN
        t := ctx.ct;
        WHILE t # NIL DO
          Out.Int(t.tid, 4); Out.String(" / "); Out.Int(t.prio, 0);
          t := t.next
        END;
        Out.Ln;
      END;
      *)
      WHILE ctx.ct # NIL DO
.  1612  000004D10      09804  ldr       r0,[sp,#16]
.  1614  000004D12      06C40  ldr       r0,[r0,#68]
.  1616  000004D14      02800  cmp       r0,#0
.  1618  000004D16  0F0008021  beq.w     66 -> 1688
        t := ctx.ct;
.  1622  000004D1A      09804  ldr       r0,[sp,#16]
.  1624  000004D1C      06C40  ldr       r0,[r0,#68]
.  1626  000004D1E      09002  str       r0,[sp,#8]
        ctx.ct := ctx.ct.next; EXCL(ctx.queued, t.tid); (* slot out ctx.ct *)
.  1628  000004D20      09804  ldr       r0,[sp,#16]
.  1630  000004D22      06C40  ldr       r0,[r0,#68]
.  1632  000004D24      06AC0  ldr       r0,[r0,#44]
.  1634  000004D26      09904  ldr       r1,[sp,#16]
.  1636  000004D28      06448  str       r0,[r1,#68]
.  1638  000004D2A      09802  ldr       r0,[sp,#8]
.  1640  000004D2C      06840  ldr       r0,[r0,#4]
.  1642  000004D2E      02101  movs      r1,#1
.  1644  000004D30      04081  lsls      r1,r0
.  1646  000004D32      09A04  ldr       r2,[sp,#16]
.  1648  000004D34      03248  adds      r2,#72
.  1650  000004D36      06813  ldr       r3,[r2]
.  1652  000004D38      0438B  bics      r3,r1
.  1654  000004D3A      06013  str       r3,[r2]
        ctx.Ct := t;
.  1656  000004D3C      09802  ldr       r0,[sp,#8]
.  1658  000004D3E      09904  ldr       r1,[sp,#16]
.  1660  000004D40      06408  str       r0,[r1,#64]
        Coroutines.Transfer(ctx.loop, t.cor);
.  1662  000004D42      09804  ldr       r0,[sp,#16]
.  1664  000004D44      06D40  ldr       r0,[r0,#84]
.  1666  000004D46      09902  ldr       r1,[sp,#8]
.  1668  000004D48      06A49  ldr       r1,[r1,#36]
.  1670  000004D4A  0F7FFFC79  bl.w      Ext Proc #5
.  1674  000004D4E      0E000  b         0 -> 1678
.  1676  000004D50      0015C  <LineNo: 348>
        ctx.Ct := NIL
      END;
.  1678  000004D52      02000  movs      r0,#0
.  1680  000004D54      09904  ldr       r1,[sp,#16]
.  1682  000004D56      06408  str       r0,[r1,#64]
.  1684  000004D58  0F7FFBFDA  b.w       -76 -> 1612
    UNTIL FALSE
  END loopc;
.  1688  000004D5C      04280  cmp       r0,r0
.  1690  000004D5E  0F43FAF28  beq.w     -432 -> 1262
.  1694  000004D62      0B006  add       sp,#24
.  1696  000004D64      0BD00  pop       { pc }
.  1698  000004D66      0BF00  nop       
.  1700  000004D68  020027E88  <Global: Kernel data>


  (* scheduler start *)
  (* set use of PSP *)

  PROCEDURE Run*;
    CONST SP = 13; R11 = 11;
    VAR cid: INTEGER;
  BEGIN
.  1704  000004D6C      0B500  push      { lr }
.  1706  000004D6E      0B081  sub       sp,#4
    (* MSP is used here *)
    Cores.GetCoreId(cid);
.  1708  000004D70      04668  mov       r0,sp
.  1710  000004D72  0F7FBFD51  bl.w      Ext Proc #2
.  1714  000004D76      0E000  b         0 -> 1718
.  1716  000004D78      0016B  <LineNo: 363>
    (* set PSP to current MSP *)
    SYSTEM.LDREG(R11, SYSTEM.REG(SP));
.  1718  000004D7A      04668  mov       r0,sp
.  1720  000004D7C      04683  mov       r11,r0
    SYSTEM.EMIT(MCU.MSR_PSP_R11);
.  1722  000004D7E  0F38B8809  .word     0x8809F38B /* EMIT */
    (* enable PSP use *)
    SYSTEM.LDREG(R11, ORD({MCU.CONTROL_SPSEL}));
.  1726  000004D82  0F2400B02  movw      r11,#2
    SYSTEM.EMIT(MCU.MSR_CTL_R11);
.  1730  000004D86  0F38B8814  .word     0x8814F38B /* EMIT */
    SYSTEM.EMIT(MCU.ISB);
.  1734  000004D8A  0F3BF8F6F  isb       
    (* from here, we use the PSP *)
    (* still in main stack memory *)
    SysTick.Enable;
.  1738  000004D8E  0F7FFFC77  bl.w      Ext Proc #2
.  1742  000004D92      0E000  b         0 -> 1746
.  1744  000004D94      00175  <LineNo: 373>
    Coroutines.Transfer(coreCon[cid].jump, coreCon[cid].loop)
.  1746  000004D96      09800  ldr       r0,[sp]
.  1748  000004D98      02801  cmp       r0,#1
.  1750  000004D9A      0D301  bcc.n     2 -> 1756
.  1752  000004D9C      0DF01  svc       1
.  1754  000004D9E      00176  <LineNo: 374>
.  1756  000004DA0  0F8DF1030  ldr.w     r1,[pc,#48] -> 1808
.  1760  000004DA4      00082  lsls      r2,r0,#2
.  1762  000004DA6  0EB020001  add.w     r0,r2,r1
.  1766  000004DAA      06800  ldr       r0,[r0]
.  1768  000004DAC      06D80  ldr       r0,[r0,#88]
.  1770  000004DAE      09900  ldr       r1,[sp]
.  1772  000004DB0      02901  cmp       r1,#1
.  1774  000004DB2      0D301  bcc.n     2 -> 1780
.  1776  000004DB4      0DF01  svc       1
.  1778  000004DB6      00176  <LineNo: 374>
.  1780  000004DB8  0F8DF2018  ldr.w     r2,[pc,#24] -> 1808
.  1784  000004DBC      0008B  lsls      r3,r1,#2
.  1786  000004DBE  0EB030102  add.w     r1,r3,r2
.  1790  000004DC2      06809  ldr       r1,[r1]
.  1792  000004DC4      06D49  ldr       r1,[r1,#84]
    (* we'll not return here *)
  END Run;
.  1794  000004DC6  0F7FFFC3B  bl.w      Ext Proc #5
.  1798  000004DCA      0E000  b         0 -> 1802
.  1800  000004DCC      00176  <LineNo: 374>
.  1802  000004DCE      0B001  add       sp,#4
.  1804  000004DD0      0BD00  pop       { pc }
.  1806  000004DD2      0BF00  nop       
.  1808  000004DD4  020027E88  <Global: Kernel data>


  (* installation *)

  PROCEDURE Install*(microsecsPerTick: INTEGER);
    VAR i, stkAddr, cid: INTEGER; ctx: CoreContext;
  BEGIN
.  1812  000004DD8      0B501  push      { r0, lr }
.  1814  000004DDA      0B084  sub       sp,#16
    Cores.GetCoreId(cid);
.  1816  000004DDC  0F11D0008  adds.w    r0,sp,#8
.  1820  000004DE0  0F7FBFD1A  bl.w      Ext Proc #2
.  1824  000004DE4      0E000  b         0 -> 1828
.  1826  000004DE6      00180  <LineNo: 384>

    (* allocate and init the core's context *)
    NEW(coreCon[cid]); ASSERT(coreCon[cid] # NIL, Errors.HeapOverflow);
.  1828  000004DE8      09802  ldr       r0,[sp,#8]
.  1830  000004DEA      02801  cmp       r0,#1
.  1832  000004DEC      0D301  bcc.n     2 -> 1838
.  1834  000004DEE      0DF01  svc       1
.  1836  000004DF0      00183  <LineNo: 387>
.  1838  000004DF2  0F8DF11CC  ldr.w     r1,[pc,#460] -> 2300
.  1842  000004DF6      00082  lsls      r2,r0,#2
.  1844  000004DF8  0EB020001  add.w     r0,r2,r1
.  1848  000004DFC      0467A  mov       r2,pc
.  1850  000004DFE  0F8DF11B0  ldr.w     r1,[pc,#432] -> 2284
.  1854  000004E02  0EB110102  adds.w    r1,r1,r2
.  1858  000004E06  0F7FBFC3F  bl.w      Ext Proc #1
.  1862  000004E0A      0E000  b         0 -> 1866
.  1864  000004E0C      00183  <LineNo: 387>
.  1866  000004E0E      09802  ldr       r0,[sp,#8]
.  1868  000004E10      02801  cmp       r0,#1
.  1870  000004E12      0D301  bcc.n     2 -> 1876
.  1872  000004E14      0DF01  svc       1
.  1874  000004E16      00183  <LineNo: 387>
.  1876  000004E18  0F8DF11A4  ldr.w     r1,[pc,#420] -> 2300
.  1880  000004E1C      00082  lsls      r2,r0,#2
.  1882  000004E1E  0EB020001  add.w     r0,r2,r1
.  1886  000004E22      06800  ldr       r0,[r0]
.  1888  000004E24      02800  cmp       r0,#0
.  1890  000004E26      0D101  bne.n     2 -> 1896
.  1892  000004E28      0DF29  svc       41
.  1894  000004E2A      00183  <LineNo: 387>
    ctx := coreCon[cid];
.  1896  000004E2C      09802  ldr       r0,[sp,#8]
.  1898  000004E2E      02801  cmp       r0,#1
.  1900  000004E30      0D301  bcc.n     2 -> 1906
.  1902  000004E32      0DF01  svc       1
.  1904  000004E34      00184  <LineNo: 388>
.  1906  000004E36  0F8DF1188  ldr.w     r1,[pc,#392] -> 2300
.  1910  000004E3A      00082  lsls      r2,r0,#2
.  1912  000004E3C  0EB020001  add.w     r0,r2,r1
.  1916  000004E40      06800  ldr       r0,[r0]
.  1918  000004E42      09003  str       r0,[sp,#12]
    ctx.Ct := NIL; ctx.ct := NIL;
.  1920  000004E44      02000  movs      r0,#0
.  1922  000004E46      09903  ldr       r1,[sp,#12]
.  1924  000004E48      06408  str       r0,[r1,#64]
.  1926  000004E4A      02000  movs      r0,#0
.  1928  000004E4C      09903  ldr       r1,[sp,#12]
.  1930  000004E4E      06448  str       r0,[r1,#68]
    ctx.queued := {};
.  1932  000004E50      02000  movs      r0,#0
.  1934  000004E52      09903  ldr       r1,[sp,#12]
.  1936  000004E54      06488  str       r0,[r1,#72]
    ctx.numThreads := 0;
.  1938  000004E56      02000  movs      r0,#0
.  1940  000004E58      09903  ldr       r1,[sp,#12]
.  1942  000004E5A      064C8  str       r0,[r1,#76]
    ctx.loopPeriod := microsecsPerTick;
.  1944  000004E5C      09804  ldr       r0,[sp,#16]
.  1946  000004E5E      09903  ldr       r1,[sp,#12]
.  1948  000004E60      06508  str       r0,[r1,#80]
    NEW(ctx.jump); ASSERT(ctx.jump # NIL, Errors.HeapOverflow);
.  1950  000004E62      09803  ldr       r0,[sp,#12]
.  1952  000004E64      03058  adds      r0,#88
.  1954  000004E66  0F8DF1154  ldr.w     r1,[pc,#340] -> 2296
.  1958  000004E6A  0F7FBFC0D  bl.w      Ext Proc #1
.  1962  000004E6E      0E000  b         0 -> 1966
.  1964  000004E70      00189  <LineNo: 393>
.  1966  000004E72      09803  ldr       r0,[sp,#12]
.  1968  000004E74      06D80  ldr       r0,[r0,#88]
.  1970  000004E76      02800  cmp       r0,#0
.  1972  000004E78      0D101  bne.n     2 -> 1978
.  1974  000004E7A      0DF29  svc       41
.  1976  000004E7C      00189  <LineNo: 393>
    NEW(ctx.loop); ASSERT(ctx.loop # NIL, Errors.HeapOverflow);
.  1978  000004E7E      09803  ldr       r0,[sp,#12]
.  1980  000004E80      03054  adds      r0,#84
.  1982  000004E82  0F8DF1138  ldr.w     r1,[pc,#312] -> 2296
.  1986  000004E86  0F7FBFBFF  bl.w      Ext Proc #1
.  1990  000004E8A      0E000  b         0 -> 1994
.  1992  000004E8C      0018A  <LineNo: 394>
.  1994  000004E8E      09803  ldr       r0,[sp,#12]
.  1996  000004E90      06D40  ldr       r0,[r0,#84]
.  1998  000004E92      02800  cmp       r0,#0
.  2000  000004E94      0D101  bne.n     2 -> 2006
.  2002  000004E96      0DF29  svc       41
.  2004  000004E98      0018A  <LineNo: 394>
    Memory.AllocLoopStack(stkAddr, LoopStackSize); ASSERT(stkAddr # 0, Errors.StorageOverflow);
.  2006  000004E9A  0F11D0004  adds.w    r0,sp,#4
.  2010  000004E9E  0F2401100  movw      r1,#256
.  2014  000004EA2  0F7FBFEEF  bl.w      Ext Proc #7
.  2018  000004EA6      0E000  b         0 -> 2022
.  2020  000004EA8      0018B  <LineNo: 395>
.  2022  000004EAA      09801  ldr       r0,[sp,#4]
.  2024  000004EAC      02800  cmp       r0,#0
.  2026  000004EAE      0D101  bne.n     2 -> 2032
.  2028  000004EB0      0DF2B  svc       43
.  2030  000004EB2      0018B  <LineNo: 395>
    Coroutines.Init(ctx.loop, stkAddr, LoopStackSize, LoopCorId);
.  2032  000004EB4      09803  ldr       r0,[sp,#12]
.  2034  000004EB6      06D40  ldr       r0,[r0,#84]
.  2036  000004EB8      09901  ldr       r1,[sp,#4]
.  2038  000004EBA  0F2401200  movw      r2,#256
.  2042  000004EBE  0F8DF30F4  ldr.w     r3,[pc,#244] -> 2288
.  2046  000004EC2  0F7FFFBB3  bl.w      Ext Proc #4
.  2050  000004EC6      0E000  b         0 -> 2054
.  2052  000004EC8      0018C  <LineNo: 396>
    Coroutines.Allocate(ctx.loop, loopc);
.  2054  000004ECA      09803  ldr       r0,[sp,#12]
.  2056  000004ECC      06D40  ldr       r0,[r0,#84]
.  2058  000004ECE      0BF00  nop       
.  2060  000004ED0  0F2AF3158  adr.w     r1,pc,#-856 -> 1208
.  2064  000004ED4  0F7FFFB9A  bl.w      Ext Proc #3
.  2068  000004ED8      0E000  b         0 -> 2072
.  2070  000004EDA      0018D  <LineNo: 397>

    (* allocate the data structures for all threads and their coroutines *)
    (* don't yet allocate the stacks *)
    i := 0;
.  2072  000004EDC      02000  movs      r0,#0
.  2074  000004EDE      09000  str       r0,[sp]
    WHILE i < MaxNumThreads DO
.  2076  000004EE0      09800  ldr       r0,[sp]
.  2078  000004EE2      02810  cmp       r0,#16
.  2080  000004EE4  0F280805D  bge.w     186 -> 2270
      NEW(ctx.threads[i]); ASSERT(ctx.threads[i] # NIL, Errors.HeapOverflow);
.  2084  000004EE8      09800  ldr       r0,[sp]
.  2086  000004EEA      02810  cmp       r0,#16
.  2088  000004EEC      0D301  bcc.n     2 -> 2094
.  2090  000004EEE      0DF01  svc       1
.  2092  000004EF0      00193  <LineNo: 403>
.  2094  000004EF2      09903  ldr       r1,[sp,#12]
.  2096  000004EF4      00082  lsls      r2,r0,#2
.  2098  000004EF6  0EB020001  add.w     r0,r2,r1
.  2102  000004EFA      0467A  mov       r2,pc
.  2104  000004EFC  0F8DF10B8  ldr.w     r1,[pc,#184] -> 2292
.  2108  000004F00  0EB110102  adds.w    r1,r1,r2
.  2112  000004F04  0F7FBFBC0  bl.w      Ext Proc #1
.  2116  000004F08      0E000  b         0 -> 2120
.  2118  000004F0A      00193  <LineNo: 403>
.  2120  000004F0C      09800  ldr       r0,[sp]
.  2122  000004F0E      02810  cmp       r0,#16
.  2124  000004F10      0D301  bcc.n     2 -> 2130
.  2126  000004F12      0DF01  svc       1
.  2128  000004F14      00193  <LineNo: 403>
.  2130  000004F16      09903  ldr       r1,[sp,#12]
.  2132  000004F18      00082  lsls      r2,r0,#2
.  2134  000004F1A  0EB020001  add.w     r0,r2,r1
.  2138  000004F1E      06800  ldr       r0,[r0]
.  2140  000004F20      02800  cmp       r0,#0
.  2142  000004F22      0D101  bne.n     2 -> 2148
.  2144  000004F24      0DF29  svc       41
.  2146  000004F26      00193  <LineNo: 403>
      ctx.threads[i].state := StateSuspended;
.  2148  000004F28      09800  ldr       r0,[sp]
.  2150  000004F2A      02810  cmp       r0,#16
.  2152  000004F2C      0D301  bcc.n     2 -> 2158
.  2154  000004F2E      0DF01  svc       1
.  2156  000004F30      00194  <LineNo: 404>
.  2158  000004F32      09903  ldr       r1,[sp,#12]
.  2160  000004F34      00082  lsls      r2,r0,#2
.  2162  000004F36  0EB020001  add.w     r0,r2,r1
.  2166  000004F3A      06800  ldr       r0,[r0]
.  2168  000004F3C      02101  movs      r1,#1
.  2170  000004F3E      06081  str       r1,[r0,#8]
      ctx.threads[i].tid := i;
.  2172  000004F40      09800  ldr       r0,[sp]
.  2174  000004F42      02810  cmp       r0,#16
.  2176  000004F44      0D301  bcc.n     2 -> 2182
.  2178  000004F46      0DF01  svc       1
.  2180  000004F48      00195  <LineNo: 405>
.  2182  000004F4A      09903  ldr       r1,[sp,#12]
.  2184  000004F4C      00082  lsls      r2,r0,#2
.  2186  000004F4E  0EB020001  add.w     r0,r2,r1
.  2190  000004F52      06800  ldr       r0,[r0]
.  2192  000004F54      09900  ldr       r1,[sp]
.  2194  000004F56      06041  str       r1,[r0,#4]
      NEW(ctx.threads[i].cor); ASSERT(ctx.threads[i].cor # NIL, Errors.HeapOverflow);
.  2196  000004F58      09800  ldr       r0,[sp]
.  2198  000004F5A      02810  cmp       r0,#16
.  2200  000004F5C      0D301  bcc.n     2 -> 2206
.  2202  000004F5E      0DF01  svc       1
.  2204  000004F60      00196  <LineNo: 406>
.  2206  000004F62      09903  ldr       r1,[sp,#12]
.  2208  000004F64      00082  lsls      r2,r0,#2
.  2210  000004F66  0EB020001  add.w     r0,r2,r1
.  2214  000004F6A      06800  ldr       r0,[r0]
.  2216  000004F6C      03024  adds      r0,#36
.  2218  000004F6E  0F8DF104C  ldr.w     r1,[pc,#76] -> 2296
.  2222  000004F72  0F7FBFB89  bl.w      Ext Proc #1
.  2226  000004F76      0E000  b         0 -> 2230
.  2228  000004F78      00196  <LineNo: 406>
.  2230  000004F7A      09800  ldr       r0,[sp]
.  2232  000004F7C      02810  cmp       r0,#16
.  2234  000004F7E      0D301  bcc.n     2 -> 2240
.  2236  000004F80      0DF01  svc       1
.  2238  000004F82      00196  <LineNo: 406>
.  2240  000004F84      09903  ldr       r1,[sp,#12]
.  2242  000004F86      00082  lsls      r2,r0,#2
.  2244  000004F88  0EB020001  add.w     r0,r2,r1
.  2248  000004F8C      06800  ldr       r0,[r0]
.  2250  000004F8E      06A40  ldr       r0,[r0,#36]
.  2252  000004F90      02800  cmp       r0,#0
.  2254  000004F92      0D101  bne.n     2 -> 2260
.  2256  000004F94      0DF29  svc       41
.  2258  000004F96      00196  <LineNo: 406>
      INC(i)
    END;
.  2260  000004F98      09800  ldr       r0,[sp]
.  2262  000004F9A      03001  adds      r0,#1
.  2264  000004F9C      09000  str       r0,[sp]
.  2266  000004F9E  0F7FFBF9F  b.w       -194 -> 2076
    (* configure sys tick *)
    SysTick.Config(microsecsPerTick)
.  2270  000004FA2      09804  ldr       r0,[sp,#16]
  END Install;
.  2272  000004FA4  0F7FFFB74  bl.w      Ext Proc #3
.  2276  000004FA8      0E000  b         0 -> 2280
.  2278  000004FAA      0019A  <LineNo: 410>
.  2280  000004FAC      0B005  add       sp,#20
.  2282  000004FAE      0BD00  pop       { pc }
.  2284  000004FB0  0FFFFF8DC  <Const:  -1828>
.  2288  000004FB4  0FFFFFFFF  <Const:  -1>
.  2292  000004FB8  0FFFFF7CA  <Const:  -2102>
.  2296  000004FBC      045BC  <Global: Coroutines code>
.  2300  000004FC0  020027E88  <Global: Kernel data>

BEGIN
.  2304  000004FC4      0B500  push      { lr }
  ASSERT(MaxNumThreads <= 32, Errors.ProgError);
.  2306  000004FC6      02010  movs      r0,#16
.  2308  000004FC8      02820  cmp       r0,#32
.  2310  000004FCA      0DD01  ble.n     2 -> 2316
.  2312  000004FCC      0DF25  svc       37
.  2314  000004FCE      0019E  <LineNo: 414>
  Done := SuspendMe; Yield := Next
.  2316  000004FD0  0F2AF60DC  adr.w     r0,pc,#-1756 -> 564
.  2320  000004FD4  0F8DF1010  ldr.w     r1,[pc,#16] -> 2340
.  2324  000004FD8      06008  str       r0,[r1]
END Kernel.
.  2326  000004FDA      0BF00  nop       
.  2328  000004FDC  0F2AF7058  adr.w     r0,pc,#-1880 -> 452
.  2332  000004FE0  0F8DF1008  ldr.w     r1,[pc,#8] -> 2344
.  2336  000004FE4      06008  str       r0,[r1]
.  2338  000004FE6      0BD00  pop       { pc }
.  2340  000004FE8  020027E84  <Global: Kernel data>
.  2344  000004FEC  020027E80  <Global: Kernel data>
 