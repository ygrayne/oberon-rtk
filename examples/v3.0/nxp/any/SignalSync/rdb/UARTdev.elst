. <tool: Astrobe for RP2350>
. <prog: C:\Users\gray\Projects\oberon\dev\oberon-rtk\examples\v3.0\nxp\any\SignalSync\SignalSync.mod>

.     0  000003C20              <Pad: 0>
MODULE UARTdev;
(**
  Oberon RTK Framework
  Version: v3.0
  --
  UART device
  * initialisation of device data structure
  * configure UART hardware
  * enable physical UART device
  --
  The GPIO pins and pads used must be configured by the client module or program.
  --
  MCU: MCXA346
  --
  Copyright (c) 2020-2025 Gray gray@grayraven.org
  https://oberon-rtk.org/licences/
**)

  IMPORT SYSTEM, Errors, MCU := MCU2, StartUp, Clocks, ClockCtrl, TextIO;

  CONST
    UART0* = 0;
    UART1* = 1;
    UART2* = 2;
    UART3* = 3;
    UART4* = 4;
    UART5* = 5;
    UARTs = {UART0 .. UART5};
    NumUART* = MCU.NumUART;

    Disabled* = 0;
    Enabled* = 1;

    ClkFreq = Clocks.SIRC_DIV_FRQ;
    ClkSel = ClockCtrl.UART_SIRC_DIV;
    ClkDiv = 0; (* actual div is ClkDiv + 1 *)

    FifoSize* = 4;

    (* BAUD bits and values *)
    BAUD_OSR_1 = 28;
    BAUD_OSR_0 = 24;
    BAUD_SBR_1 = 12;
    BAUD_SBR_0 = 0;

    (* STAT bits and values *)
    STAT_TDRE* = 23;

    (* CTRL bits and values *)
    CTRL_TE = 19;
    CTRL_RE = 18;

    (* FIFO bits and values *)
    FIFO_TXEMPT* = 23;
    FIFO_TXFE = 7;
    FIFO_RXFE = 3;

    (* WATER bits and values *)
    WATER_RX_1 = 17;
    WATER_RX_0 = 16;
    WATER_TX_1 = 1;
    WATER_TX_0 = 0;


  TYPE
    Device* = POINTER TO DeviceDesc;
    DeviceDesc* = RECORD(TextIO.DeviceDesc)
      uartNo*: INTEGER;
      devNo*, clkSel, clkDiv: INTEGER;
      BAUD, STAT*: INTEGER;
      FIFO, CTRL, WATER: INTEGER;
      DATA*: INTEGER
    END;
.     4  000003C24      03C24      00028  <Type:   40>
.     8  000003C28      03C28      03C24  <Type:   040000H>
.    12  000003C2C      03C2C      00000  <Type:   0>
.    16  000003C30      03C30      00000  <Type:   0>
.    20  000003C34      03C34      00000  <Type:   0>


    DeviceCfg* = RECORD
      osr*: INTEGER;          (* oversampling rate *)
      txfe*, rxfe*: INTEGER;  (* fifo enable *)
      txwater*, rxwater*: INTEGER;
      (* ... *)
    END;
.    24  000003C38      03C38      00014  <Type:   20>
.    28  000003C3C      03C3C      00000  <Type:   0>
.    32  000003C40      03C40      00000  <Type:   0>
.    36  000003C44      03C44      00000  <Type:   0>
.    40  000003C48      03C48      00000  <Type:   0>


    PROCEDURE* Init*(dev: Device; uartNo: INTEGER);
      VAR base: INTEGER;
    BEGIN
.    44  000003C4C      0B500  push      { lr }
      ASSERT(dev # NIL, Errors.PreCond);
.    46  000003C4E      02800  cmp       r0,#0
.    48  000003C50      0D101  bne.n     2 -> 54
.    50  000003C52      0DF22  svc       34
.    52  000003C54      00057  <LineNo: 87>
      ASSERT(uartNo IN UARTs, Errors.PreCond);
.    54  000003C56      0233F  movs      r3,#63
.    56  000003C58      02401  movs      r4,#1
.    58  000003C5A      0408C  lsls      r4,r1
.    60  000003C5C  0EA130F04  tst.w     r3,r4
.    64  000003C60      0D101  bne.n     2 -> 70
.    66  000003C62      0DF22  svc       34
.    68  000003C64      00058  <LineNo: 88>
      dev.uartNo := uartNo;
.    70  000003C66      06001  str       r1,[r0]
      IF uartNo < UART5 THEN
.    72  000003C68      02905  cmp       r1,#5
.    74  000003C6A  0F2808014  bge.w     40 -> 118
        base := MCU.LPUART0_BASE + (uartNo * MCU.UART_Offset);
.    78  000003C6E      0030B  lsls      r3,r1,#12
.    80  000003C70  0F8DF4060  ldr.w     r4,[pc,#96] -> 180
.    84  000003C74      04423  add       r3,r4
.    86  000003C76      0461A  mov       r2,r3
        dev.devNo := MCU.DEV_UART0 + uartNo;
.    88  000003C78  0F1010317  add.w     r3,r1,#23
.    92  000003C7C      06043  str       r3,[r0,#4]
        dev.clkSel := MCU.CLKSEL_UART0 + (uartNo * MCU.CLK_UART_Offset);
.    94  000003C7E      000CB  lsls      r3,r1,#3
.    96  000003C80  0F8DF4054  ldr.w     r4,[pc,#84] -> 184
.   100  000003C84      04423  add       r3,r4
.   102  000003C86      06083  str       r3,[r0,#8]
        dev.clkDiv := MCU.CLKDIV_UART0 + (uartNo * MCU.CLK_UART_Offset)
.   104  000003C88      000CB  lsls      r3,r1,#3
      ELSE
.   106  000003C8A  0F8DF4050  ldr.w     r4,[pc,#80] -> 188
.   110  000003C8E      04423  add       r3,r4
.   112  000003C90      060C3  str       r3,[r0,#12]
        base := MCU.LPUART5_BASE;
.   114  000003C92  0F000B80B  b.w       22 -> 140
.   118  000003C96  0F8DF3048  ldr.w     r3,[pc,#72] -> 192
.   122  000003C9A      0461A  mov       r2,r3
        dev.devNo := MCU.DEV_UART5;
.   124  000003C9C      0233A  movs      r3,#58
.   126  000003C9E      06043  str       r3,[r0,#4]
        dev.clkSel := MCU.CLKSEL_UART5;
.   128  000003CA0  0F8DF3040  ldr.w     r3,[pc,#64] -> 196
.   132  000003CA4      06083  str       r3,[r0,#8]
        dev.clkDiv := MCU.CLKDIV_UART5
      END;
.   134  000003CA6  0F8DF3040  ldr.w     r3,[pc,#64] -> 200
.   138  000003CAA      060C3  str       r3,[r0,#12]
      dev.BAUD := base + MCU.UART_BAUD_Offset;
.   140  000003CAC  0F1020310  add.w     r3,r2,#16
.   144  000003CB0      06103  str       r3,[r0,#16]
      dev.STAT := base + MCU.UART_STAT_Offset;
.   146  000003CB2  0F1020314  add.w     r3,r2,#20
.   150  000003CB6      06143  str       r3,[r0,#20]
      dev.CTRL := base + MCU.UART_CTRL_Offset;
.   152  000003CB8  0F1020318  add.w     r3,r2,#24
.   156  000003CBC      061C3  str       r3,[r0,#28]
      dev.DATA := base + MCU.UART_DATA_Offset;
.   158  000003CBE  0F102031C  add.w     r3,r2,#28
.   162  000003CC2      06243  str       r3,[r0,#36]
      dev.FIFO := base + MCU.UART_FIFO_Offset;
.   164  000003CC4  0F1020328  add.w     r3,r2,#40
.   168  000003CC8      06183  str       r3,[r0,#24]
      dev.WATER := base + MCU.UART_WATER_Offset
    END Init;
.   170  000003CCA  0F102032C  add.w     r3,r2,#44
.   174  000003CCE      06203  str       r3,[r0,#32]
.   176  000003CD0      0BD00  pop       { pc }
.   178  000003CD2      0BF00  nop       
.   180  000003CD4  04009F000  <Const:  1074393088>
.   184  000003CD8  040091100  <Const:  1074336000>
.   188  000003CDC  040091104  <Const:  1074336004>
.   192  000003CE0  0400DA000  <Const:  1074634752>
.   196  000003CE4  0400911A0  <Const:  1074336160>
.   200  000003CE8  0400911A4  <Const:  1074336164>


    PROCEDURE Configure*(dev: Device; cfg: DeviceCfg; baudrate: INTEGER);
      VAR val, x: INTEGER;
    BEGIN
.   204  000003CEC      0B50F  push      { r0, r1, r2, r3, lr }
.   206  000003CEE      0B082  sub       sp,#8

      (* release reset on UART device, set clock *)
      StartUp.ReleaseReset(dev.devNo);
.   208  000003CF0      09802  ldr       r0,[sp,#8]
.   210  000003CF2      06840  ldr       r0,[r0,#4]
.   212  000003CF4  0F7FCFB24  bl.w      Ext Proc #1
.   216  000003CF8      0E000  b         0 -> 220
.   218  000003CFA      00073  <LineNo: 115>
      ClockCtrl.ConfigDevClock(dev.clkSel, dev.clkDiv, ClkSel, ClkDiv);
.   220  000003CFC      09802  ldr       r0,[sp,#8]
.   222  000003CFE      06880  ldr       r0,[r0,#8]
.   224  000003D00      09902  ldr       r1,[sp,#8]
.   226  000003D02      068C9  ldr       r1,[r1,#12]
.   228  000003D04      02200  movs      r2,#0
.   230  000003D06      02300  movs      r3,#0
.   232  000003D08  0F7FFFF7A  bl.w      Ext Proc #1
.   236  000003D0C      0E000  b         0 -> 240
.   238  000003D0E      00074  <LineNo: 116>
      StartUp.EnableClock(dev.devNo);
.   240  000003D10      09802  ldr       r0,[sp,#8]
.   242  000003D12      06840  ldr       r0,[r0,#4]
.   244  000003D14  0F7FCFB38  bl.w      Ext Proc #3
.   248  000003D18      0E000  b         0 -> 252
.   250  000003D1A      00075  <LineNo: 117>

      (* disable transmitter and receiver *)
      SYSTEM.GET(dev.CTRL, val);
.   252  000003D1C      09802  ldr       r0,[sp,#8]
.   254  000003D1E      069C0  ldr       r0,[r0,#28]
.   256  000003D20      06801  ldr       r1,[r0]
.   258  000003D22      09100  str       r1,[sp]
      BFI(val, CTRL_TE, CTRL_RE, 0);
.   260  000003D24      04668  mov       r0,sp
.   262  000003D26      02100  movs      r1,#0
.   264  000003D28      06802  ldr       r2,[r0]
.   266  000003D2A  0F3614293  bfi       r2,r1,18,2
.   270  000003D2E      09200  str       r2,[sp]
      SYSTEM.PUT(dev.CTRL, val);
.   272  000003D30      09802  ldr       r0,[sp,#8]
.   274  000003D32      069C0  ldr       r0,[r0,#28]
.   276  000003D34      09900  ldr       r1,[sp]
.   278  000003D36      06001  str       r1,[r0]
      REPEAT
        SYSTEM.GET(dev.CTRL, val)
      UNTIL BFX(val, CTRL_TE, CTRL_RE) = 0;
.   280  000003D38      09802  ldr       r0,[sp,#8]
.   282  000003D3A      069C0  ldr       r0,[r0,#28]
.   284  000003D3C      06801  ldr       r1,[r0]
.   286  000003D3E      09100  str       r1,[sp]
.   288  000003D40      09800  ldr       r0,[sp]
.   290  000003D42  0F3C04081  ubfx      r0,r0,18,2
.   294  000003D46      02800  cmp       r0,#0
.   296  000003D48  0F47FAFF6  bne.w     -20 -> 280

      (* baudrate *)
      SYSTEM.GET(dev.BAUD, val);
.   300  000003D4C      09802  ldr       r0,[sp,#8]
.   302  000003D4E      06900  ldr       r0,[r0,#16]
.   304  000003D50      06801  ldr       r1,[r0]
.   306  000003D52      09100  str       r1,[sp]
      BFI(val, BAUD_OSR_1, BAUD_OSR_0, cfg.osr);
.   308  000003D54      04668  mov       r0,sp
.   310  000003D56      09903  ldr       r1,[sp,#12]
.   312  000003D58      06809  ldr       r1,[r1]
.   314  000003D5A      06802  ldr       r2,[r0]
.   316  000003D5C  0F361621C  bfi       r2,r1,24,5
.   320  000003D60      09200  str       r2,[sp]
      x := (ClkFreq DIV (cfg.osr + 1)) DIV baudrate;
.   322  000003D62      09803  ldr       r0,[sp,#12]
.   324  000003D64      06800  ldr       r0,[r0]
.   326  000003D66      03001  adds      r0,#1
.   328  000003D68  0F8DF10A0  ldr.w     r1,[pc,#160] -> 492
.   332  000003D6C  0F1B00F00  cmp.w     r0,#0
.   336  000003D70      0DC01  bgt.n     2 -> 342
.   338  000003D72      0DF07  svc       7
.   340  000003D74      00082  <LineNo: 130>
.   342  000003D76  0FB91F2F0  sdiv.w    r2,r1,r0
.   346  000003D7A  0FB021010  mls.w     r0,r2,r0,r1
.   350  000003D7E  0EBA270D0  sub.w     r0,r2,r0,lsr 31
.   354  000003D82      09905  ldr       r1,[sp,#20]
.   356  000003D84  0F1B10F00  cmp.w     r1,#0
.   360  000003D88      0DC01  bgt.n     2 -> 366
.   362  000003D8A      0DF07  svc       7
.   364  000003D8C      00082  <LineNo: 130>
.   366  000003D8E  0FB90F2F1  sdiv.w    r2,r0,r1
.   370  000003D92  0FB020011  mls.w     r0,r2,r1,r0
.   374  000003D96  0EBA270D0  sub.w     r0,r2,r0,lsr 31
.   378  000003D9A      09001  str       r0,[sp,#4]
      BFI(val, BAUD_SBR_1, BAUD_SBR_0, x);
.   380  000003D9C      04668  mov       r0,sp
.   382  000003D9E      09901  ldr       r1,[sp,#4]
.   384  000003DA0      06802  ldr       r2,[r0]
.   386  000003DA2  0F361020C  bfi       r2,r1,0,13
.   390  000003DA6      09200  str       r2,[sp]
      SYSTEM.PUT(dev.BAUD, val);
.   392  000003DA8      09802  ldr       r0,[sp,#8]
.   394  000003DAA      06900  ldr       r0,[r0,#16]
.   396  000003DAC      09900  ldr       r1,[sp]
.   398  000003DAE      06001  str       r1,[r0]

      (* tx watermark *)
      SYSTEM.GET(dev.WATER, val);
.   400  000003DB0      09802  ldr       r0,[sp,#8]
.   402  000003DB2      06A00  ldr       r0,[r0,#32]
.   404  000003DB4      06801  ldr       r1,[r0]
.   406  000003DB6      09100  str       r1,[sp]
      BFI(val, WATER_TX_1, WATER_TX_0, cfg.txwater);
.   408  000003DB8      04668  mov       r0,sp
.   410  000003DBA      09903  ldr       r1,[sp,#12]
.   412  000003DBC      068C9  ldr       r1,[r1,#12]
.   414  000003DBE      06802  ldr       r2,[r0]
.   416  000003DC0  0F3610201  bfi       r2,r1,0,2
.   420  000003DC4      09200  str       r2,[sp]
      BFI(val, WATER_RX_1, WATER_RX_0, cfg.rxwater);
.   422  000003DC6      04668  mov       r0,sp
.   424  000003DC8      09903  ldr       r1,[sp,#12]
.   426  000003DCA      06909  ldr       r1,[r1,#16]
.   428  000003DCC      06802  ldr       r2,[r0]
.   430  000003DCE  0F3614211  bfi       r2,r1,16,2
.   434  000003DD2      09200  str       r2,[sp]
      SYSTEM.PUT(dev.WATER, val);
.   436  000003DD4      09802  ldr       r0,[sp,#8]
.   438  000003DD6      06A00  ldr       r0,[r0,#32]
.   440  000003DD8      09900  ldr       r1,[sp]
.   442  000003DDA      06001  str       r1,[r0]

      (* enable fifos *)
      SYSTEM.GET(dev.FIFO, val);
.   444  000003DDC      09802  ldr       r0,[sp,#8]
.   446  000003DDE      06980  ldr       r0,[r0,#24]
.   448  000003DE0      06801  ldr       r1,[r0]
.   450  000003DE2      09100  str       r1,[sp]
      BFI(val, FIFO_TXFE, cfg.txfe);
.   452  000003DE4      04668  mov       r0,sp
.   454  000003DE6      09903  ldr       r1,[sp,#12]
.   456  000003DE8      06849  ldr       r1,[r1,#4]
.   458  000003DEA      06802  ldr       r2,[r0]
.   460  000003DEC  0F36112C7  bfi       r2,r1,7,1
.   464  000003DF0      09200  str       r2,[sp]
      BFI(val, FIFO_RXFE, cfg.rxfe);
.   466  000003DF2      04668  mov       r0,sp
.   468  000003DF4      09903  ldr       r1,[sp,#12]
.   470  000003DF6      06889  ldr       r1,[r1,#8]
.   472  000003DF8      06802  ldr       r2,[r0]
.   474  000003DFA  0F36102C3  bfi       r2,r1,3,1
.   478  000003DFE      09200  str       r2,[sp]
      SYSTEM.PUT(dev.FIFO, val)
    END Configure;
.   480  000003E00      09802  ldr       r0,[sp,#8]
.   482  000003E02      06980  ldr       r0,[r0,#24]
.   484  000003E04      09900  ldr       r1,[sp]
.   486  000003E06      06001  str       r1,[r0]
.   488  000003E08      0B006  add       sp,#24
.   490  000003E0A      0BD00  pop       { pc }
.   492  000003E0C  000B71B00  <Const:  12000000>


    PROCEDURE* GetBaseCfg*(VAR cfg: DeviceCfg);
    BEGIN
.   496  000003E10      0B500  push      { lr }
      CLEAR(cfg);
.   498  000003E12      04602  mov       r2,r0
.   500  000003E14      02300  movs      r3,#0
.   502  000003E16      02405  movs      r4,#5
.   504  000003E18  0F8423B04  str.w     r3,[r2],#4
.   508  000003E1C      03C01  subs      r4,#1
.   510  000003E1E      0DCFB  bgt.n     -10 -> 504
      cfg.osr := 15;
.   512  000003E20      0220F  movs      r2,#15
.   514  000003E22      06002  str       r2,[r0]
      cfg.txfe := Disabled;
.   516  000003E24      02200  movs      r2,#0
.   518  000003E26      06042  str       r2,[r0,#4]
      cfg.rxfe := Disabled
    END GetBaseCfg;
.   520  000003E28      02200  movs      r2,#0
.   522  000003E2A      06082  str       r2,[r0,#8]
.   524  000003E2C      0BD00  pop       { pc }
.   526  000003E2E      0BF00  nop       


    PROCEDURE* Enable*(dev: Device);
      VAR val: INTEGER;
    BEGIN
.   528  000003E30      0B500  push      { lr }
      SYSTEM.GET(dev.CTRL, val);
.   530  000003E32      069C2  ldr       r2,[r0,#28]
.   532  000003E34      06811  ldr       r1,[r2]
      BFI(val, CTRL_TE, CTRL_RE, 3);
.   534  000003E36      0460A  mov       r2,r1
.   536  000003E38      02303  movs      r3,#3
.   538  000003E3A  0F3634193  bfi       r1,r3,18,2
      SYSTEM.PUT(dev.CTRL, val)
    END Enable;
.   542  000003E3E      069C2  ldr       r2,[r0,#28]
.   544  000003E40      06011  str       r1,[r2]
.   546  000003E42      0BD00  pop       { pc }

END UARTdev.
.   548  000003E44      0B500  push      { lr }
.   550  000003E46      0BD00  pop       { pc }
 