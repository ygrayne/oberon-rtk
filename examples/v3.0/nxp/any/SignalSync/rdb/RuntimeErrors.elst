. <tool: Astrobe for RP2350>
. <prog: C:\Users\gray\Projects\oberon\dev\oberon-rtk\examples\v3.0\nxp\any\SignalSync\SignalSync.mod>

.     0  010001340              <Pad: 0>
MODULE RuntimeErrors;
(**
  Oberon RTK Framework
  Version: v3.0
  --
  Exception handling: run-time errors and faults
  --
  * Error: run-time errors, including ASSERT, triggered by SVC calls in software
  * Fault: hardware faults, triggered by MCU hardware
  --
  MCU: MCXN947
  --
  Copyright (c) 2020-2025 Gray, gray@grayraven.org
  https://oberon-rtk.org/licences/
**)

  IMPORT
    SYSTEM, MCU := MCU2, LED, Config;

  CONST
    NumCores = Config.NumCoresUsed;

    (* register offsets from stacked r0 *)
    PCoffset = 24;

    (* register numbers *)
    SP = 13;

    (* PPB_SHCSR bits *)
    SECUREFAULTENA  = 19;
    USGFAULTENA     = 18;
    BUSFAULTENA     = 17;
    MEMFAULTENA     = 16;

    (* EXC_RETURN bits *)
    (*EXC_RET_S     = 6;*)  (* = 1: secure stack frame, faulty code was running in secure domain *)
    (*EXC_RET_DCRS  = 5;*)  (* = 0: all CPU regs stacked by hardware, extended state context *)
    (*EXC_RET_FType = 4;*)  (* = 0: all FPU regs stacked by hardware, extended FPU context *)
    EXC_RET_Mode  = 3;      (* = 1: thread mode, faulty code was running in thread mode *)
    EXC_RET_SPSEL = 2;      (* = 1: PSP used for stacking *)
    (*EXC_RET_ES    = 0;*)  (* = 1: exception running in secure domain *)

    (* MCU.PPB_ICSR bits *)
    PENDSVSET = 28;


  TYPE
    (* data collected for an error/fault *)
    ErrorDesc* = RECORD
      core*: BYTE;       (* MCU core *)
      errCode*: BYTE;    (* error or fault code *)
      errType*: BYTE;    (* type of error: error or fault, handler or thread mode *)
      errAddr*: INTEGER; (* error/fault code address *)
      errLineNo*: INTEGER;      (* error source code line no, if available *)
      stackframeBase*: INTEGER; (* address of exception frame stack *)
      excRetVal*: INTEGER;
      xpsr*: INTEGER
    END;
.     4  010001344  010001344      00018  <Type:   24>
.     8  010001348  010001348      00000  <Type:   0>
.    12  01000134C  01000134C      00000  <Type:   0>
.    16  010001350  010001350      00000  <Type:   0>
.    20  010001354  010001354      00000  <Type:   0>


  VAR
    ErrorRec*: ARRAY NumCores OF ErrorDesc;


  PROCEDURE excHandler[0];
    CONST FaultCodeBase = 2; R11 = 11;
    VAR
      cid, excNo, stackframeBase, excRetAddr, excRetVal, retAddr: INTEGER;
      b0, b1: BYTE; icsr: SET;
      er: ErrorDesc;
  BEGIN
.    24  010001358  0F84DED04  push.w    { lr }
.    28  01000135C      0B08E  sub       sp,#56
    SYSTEM.GET(MCU.PPB_VTOR, cid);
.    30  01000135E  0F8DF0100  ldr.w     r0,[pc,#256] -> 288
.    34  010001362      06801  ldr       r1,[r0]
.    36  010001364      09100  str       r1,[sp]
    SYSTEM.GET(cid, cid);
.    38  010001366      09800  ldr       r0,[sp]
.    40  010001368      06801  ldr       r1,[r0]
.    42  01000136A      09100  str       r1,[sp]
    excRetAddr := SYSTEM.REG(SP) + 56; (* addr of EXC_RETURN value on stack *)
.    44  01000136C      04668  mov       r0,sp
.    46  01000136E      03038  adds      r0,#56
.    48  010001370      09003  str       r0,[sp,#12]
    SYSTEM.GET(excRetAddr, excRetVal);
.    50  010001372      09803  ldr       r0,[sp,#12]
.    52  010001374      06801  ldr       r1,[r0]
.    54  010001376      09104  str       r1,[sp,#16]
    IF EXC_RET_SPSEL IN BITS(excRetVal) THEN (* PSP used for stacking *)
.    56  010001378      09804  ldr       r0,[sp,#16]
.    58  01000137A  0F0100F04  tst.w     r0,#4
.    62  01000137E  0F0008006  beq.w     12 -> 78
      SYSTEM.EMIT(MCU.MRS_R11_PSP);
.    66  010001382  0F3EF8B09  .word     0x8B09F3EF /* EMIT */
      stackframeBase := SYSTEM.REG(R11)
    ELSE (* MSP used *)
.    70  010001386      04658  mov       r0,r11
.    72  010001388      09002  str       r0,[sp,#8]
      stackframeBase := excRetAddr + 4;
.    74  01000138A  0F000B803  b.w       6 -> 84
.    78  01000138E      09803  ldr       r0,[sp,#12]
.    80  010001390      03004  adds      r0,#4
.    82  010001392      09002  str       r0,[sp,#8]
    END;
    SYSTEM.GET(stackframeBase + PCoffset, retAddr);
.    84  010001394      09802  ldr       r0,[sp,#8]
.    86  010001396      03018  adds      r0,#24
.    88  010001398      06801  ldr       r1,[r0]
.    90  01000139A      09105  str       r1,[sp,#20]
    SYSTEM.EMIT(MCU.MRS_R11_XPSR);
.    92  01000139C  0F3EF8B03  .word     0x8B03F3EF /* EMIT */
    er.xpsr := SYSTEM.REG(R11);
.    96  0100013A0      04658  mov       r0,r11
.    98  0100013A2      0900D  str       r0,[sp,#52]
    er.core := cid;
.   100  0100013A4      09800  ldr       r0,[sp]
.   102  0100013A6  0F88D0020  strb.w    r0,[sp,#32]
    er.excRetVal := excRetVal;
.   106  0100013AA      09804  ldr       r0,[sp,#16]
.   108  0100013AC      0900C  str       r0,[sp,#48]
    er.errAddr := retAddr;
.   110  0100013AE      09805  ldr       r0,[sp,#20]
.   112  0100013B0      09009  str       r0,[sp,#36]
    er.stackframeBase := stackframeBase;
.   114  0100013B2      09802  ldr       r0,[sp,#8]
.   116  0100013B4      0900B  str       r0,[sp,#44]

    SYSTEM.EMIT(MCU.MRS_R11_IPSR);
.   118  0100013B6  0F3EF8B05  .word     0x8B05F3EF /* EMIT */
    excNo := SYSTEM.REG(R11);
.   122  0100013BA      04658  mov       r0,r11
.   124  0100013BC      09001  str       r0,[sp,#4]
    IF excNo = MCU.EXC_SVC THEN (* SVC exception *)
.   126  0100013BE      09801  ldr       r0,[sp,#4]
.   128  0100013C0      0280B  cmp       r0,#11
.   130  0100013C2  0F040801C  bne.w     56 -> 190
      (* get source line number *)
      SYSTEM.GET(retAddr + 1, b1);
.   134  0100013C6      09805  ldr       r0,[sp,#20]
.   136  0100013C8      03001  adds      r0,#1
.   138  0100013CA      07801  ldrb      r1,[r0]
.   140  0100013CC  0F88D1019  strb.w    r1,[sp,#25]
      SYSTEM.GET(retAddr, b0);
.   144  0100013D0      09805  ldr       r0,[sp,#20]
.   146  0100013D2      07801  ldrb      r1,[r0]
.   148  0100013D4  0F88D1018  strb.w    r1,[sp,#24]
      er.errLineNo := LSL(b1, 8) + b0;
.   152  0100013D8  0F89D0019  ldrb.w    r0,[sp,#25]
.   156  0100013DC      00200  lsls      r0,r0,#8
.   158  0100013DE  0F89D1018  ldrb.w    r1,[sp,#24]
.   162  0100013E2      04408  add       r0,r1
.   164  0100013E4      0900A  str       r0,[sp,#40]
      (* get imm svc value = error code *)
      SYSTEM.GET(retAddr - 2, er.errCode); (* svc instr is two bytes, imm value is lower byte *)
.   166  0100013E6      09805  ldr       r0,[sp,#20]
.   168  0100013E8      03802  subs      r0,#2
.   170  0100013EA      07801  ldrb      r1,[r0]
.   172  0100013EC  0F88D1021  strb.w    r1,[sp,#33]
      (* type: 0 = error in handler mode, 1 = error in thread mode *)
      er.errType := BFX(excRetVal, EXC_RET_Mode);
.   176  0100013F0      09804  ldr       r0,[sp,#16]
.   178  0100013F2  0F3C000C0  ubfx      r0,r0,3,1
.   182  0100013F6  0F88D0022  strb.w    r0,[sp,#34]
    ELSE (* all others *)
      er.errLineNo := 0;
.   186  0100013FA  0F000B80B  b.w       22 -> 212
.   190  0100013FE      02000  movs      r0,#0
.   192  010001400      0900A  str       r0,[sp,#40]
      er.errCode := excNo;
.   194  010001402      09801  ldr       r0,[sp,#4]
.   196  010001404  0F88D0021  strb.w    r0,[sp,#33]
      (* type: 2 = fault in handler mode, 3 = fault in thread mode *)
      er.errType := FaultCodeBase + BFX(excRetVal, EXC_RET_Mode);
.   200  010001408      09804  ldr       r0,[sp,#16]
.   202  01000140A  0F3C000C0  ubfx      r0,r0,3,1
.   206  01000140E      03002  adds      r0,#2
.   208  010001410  0F88D0022  strb.w    r0,[sp,#34]
    END;
    ErrorRec[cid] := er;
.   212  010001414      09800  ldr       r0,[sp]
.   214  010001416      02801  cmp       r0,#1
.   216  010001418      0D301  bcc.n     2 -> 222
.   218  01000141A      0DF01  svc       1
.   220  01000141C      0006B  <LineNo: 107>
.   222  01000141E  0F8DF1048  ldr.w     r1,[pc,#72] -> 296
.   226  010001422      02218  movs      r2,#24
.   228  010001424  0FB021000  mla.w     r0,r2,r0,r1
.   232  010001428      02106  movs      r1,#6
.   234  01000142A  0F11D0220  adds.w    r2,sp,#32
.   238  01000142E  0F8523B04  ldr.w     r3,[r2],#4
.   242  010001432  0F8403B04  str.w     r3,[r0],#4
.   246  010001436      03901  subs      r1,#1
.   248  010001438      0D1F9  bne.n     -14 -> 238

    (* set PendSV pending to trigger error handler *)
    SYSTEM.GET(MCU.PPB_ICSR, icsr);
.   250  01000143A  0F8DF0028  ldr.w     r0,[pc,#40] -> 292
.   254  01000143E      06801  ldr       r1,[r0]
.   256  010001440      09107  str       r1,[sp,#28]
    icsr := icsr + {PENDSVSET};
.   258  010001442      09807  ldr       r0,[sp,#28]
.   260  010001444  0F0505080  orrs.w    r0,r0,#010000000H
.   264  010001448      09007  str       r0,[sp,#28]
    SYSTEM.PUT(MCU.PPB_ICSR, icsr);
.   266  01000144A  0F8DF0018  ldr.w     r0,[pc,#24] -> 292
.   270  01000144E      09907  ldr       r1,[sp,#28]
.   272  010001450      06001  str       r1,[r0]
    SYSTEM.EMIT(MCU.DSB); SYSTEM.EMIT(MCU.ISB)
.   274  010001452  0F3BF8F4F  dsb       
  END excHandler;
.   278  010001456  0F3BF8F6F  isb       
.   282  01000145A      0B00E  add       sp,#56
.   284  01000145C  0F85DFB04  pop.w     { pc }
.   288  010001460  0E000ED08  <Const:  -536810232>
.   292  010001464  0E000ED04  <Const:  -536810236>
.   296  010001468  02001FED8  <Global: RuntimeErrors data>


  PROCEDURE* errorHandler[0];
  (* default handler: simply blink LED *)
    VAR cid, cnt, i: INTEGER; er: ErrorDesc;
  BEGIN
.   300  01000146C  0E92D4070  push.w    { r4, r5, r6, lr }
.   304  010001470      0B086  sub       sp,#24
    SYSTEM.GET(MCU.PPB_VTOR, cid);
.   306  010001472  0F8DF3068  ldr.w     r3,[pc,#104] -> 412
.   310  010001476      06818  ldr       r0,[r3]
    SYSTEM.GET(cid, cid);
.   312  010001478      06800  ldr       r0,[r0]
    er := ErrorRec[cid];
.   314  01000147A  0F8DF3070  ldr.w     r3,[pc,#112] -> 428
.   318  01000147E      02418  movs      r4,#24
.   320  010001480  0FB043300  mla.w     r3,r4,r0,r3
.   324  010001484      02406  movs      r4,#6
.   326  010001486      0466D  mov       r5,sp
.   328  010001488  0F8536B04  ldr.w     r6,[r3],#4
.   332  01000148C  0F8456B04  str.w     r6,[r5],#4
.   336  010001490      03C01  subs      r4,#1
.   338  010001492      0D1F9  bne.n     -14 -> 328
    IF er.errType IN {0, 1} THEN
.   340  010001494      02303  movs      r3,#3
.   342  010001496  0F89D4002  ldrb.w    r4,[sp,#2]
.   346  01000149A      02501  movs      r5,#1
.   348  01000149C      040A5  lsls      r5,r4
.   350  01000149E  0EA130F05  tst.w     r3,r5
.   354  0100014A2  0F0008005  beq.w     10 -> 368
      cnt := 1000000
    ELSE
.   358  0100014A6  0F8DF3038  ldr.w     r3,[pc,#56] -> 416
.   362  0100014AA      04619  mov       r1,r3
      cnt := 5000000
.   364  0100014AC  0F000B803  b.w       6 -> 374
    END;
.   368  0100014B0  0F8DF3030  ldr.w     r3,[pc,#48] -> 420
.   372  0100014B4      04619  mov       r1,r3
    REPEAT
      SYSTEM.PUT(LED.LXOR0, {LED.Red});
.   374  0100014B6  0F8DF3030  ldr.w     r3,[pc,#48] -> 424
.   378  0100014BA  0F2404400  movw      r4,#1024
.   382  0100014BE      0601C  str       r4,[r3]
      i := 0;
.   384  0100014C0      02300  movs      r3,#0
.   386  0100014C2      0461A  mov       r2,r3
      WHILE i < cnt DO INC(i) END
.   388  0100014C4      0428A  cmp       r2,r1
.   390  0100014C6  0F2808003  bge.w     6 -> 400
.   394  0100014CA      03201  adds      r2,#1
.   396  0100014CC  0F7FFBFFA  b.w       -12 -> 388
    UNTIL FALSE
  END errorHandler;
.   400  0100014D0      04280  cmp       r0,r0
.   402  0100014D2  0F43FAFF0  beq.w     -32 -> 374
.   406  0100014D6      0B006  add       sp,#24
.   408  0100014D8  0E8BD8070  pop.w     { r4, r5, r6, pc }
.   412  0100014DC  0E000ED08  <Const:  -536810232>
.   416  0100014E0  0000F4240  <Const:  1000000>
.   420  0100014E4  0004C4B40  <Const:  5000000>
.   424  0100014E8  04009604C  <Const:  1074356300>
.   428  0100014EC  02001FED8  <Global: RuntimeErrors data>


  PROCEDURE* install(vectAddr: INTEGER; p: PROCEDURE);
  BEGIN
.   432  0100014F0      0B500  push      { lr }
    INCL(SYSTEM.VAL(SET, p), 0); (* thumb code *)
.   434  0100014F2  0F0510101  orrs.w    r1,r1,#1
    SYSTEM.PUT(vectAddr, p)
  END install;
.   438  0100014F6      06001  str       r1,[r0]
.   440  0100014F8      0BD00  pop       { pc }
.   442  0100014FA      0BF00  nop       


  PROCEDURE* EnableFaults*;
  (* call from code running on core 0 AND on core 1*)
    VAR x: SET;
  BEGIN
.   444  0100014FC      0B500  push      { lr }
    SYSTEM.GET(MCU.PPB_SHCSR, x);
.   446  0100014FE  0F8DF101C  ldr.w     r1,[pc,#28] -> 476
.   450  010001502      06808  ldr       r0,[r1]
    x := x + {MEMFAULTENA, BUSFAULTENA, USGFAULTENA, SECUREFAULTENA};
.   452  010001504  0F4502170  orrs.w    r1,r0,#00F0000H
.   456  010001508      04608  mov       r0,r1
    SYSTEM.PUT(MCU.PPB_SHCSR, x);
.   458  01000150A  0F8DF1010  ldr.w     r1,[pc,#16] -> 476
.   462  01000150E      06008  str       r0,[r1]
    SYSTEM.EMIT(MCU.DSB); SYSTEM.EMIT(MCU.ISB)
.   464  010001510  0F3BF8F4F  dsb       
  END EnableFaults;
.   468  010001514  0F3BF8F6F  isb       
.   472  010001518      0BD00  pop       { pc }
.   474  01000151A      0BF00  nop       
.   476  01000151C  0E000ED24  <Const:  -536810204>


  PROCEDURE InstallErrorHandler*(cid: INTEGER; eh: PROCEDURE);
    VAR vectorTableBase: INTEGER;
  BEGIN
.   480  010001520      0B503  push      { r0, r1, lr }
.   482  010001522      0B081  sub       sp,#4
    vectorTableBase := Config.VectMem[cid].start;
.   484  010001524      09801  ldr       r0,[sp,#4]
.   486  010001526      02801  cmp       r0,#1
.   488  010001528      0D301  bcc.n     2 -> 494
.   490  01000152A      0DF01  svc       1
.   492  01000152C      0009E  <LineNo: 158>
.   494  01000152E  0F8DF1020  ldr.w     r1,[pc,#32] -> 528
.   498  010001532      000C2  lsls      r2,r0,#3
.   500  010001534  0EB020001  add.w     r0,r2,r1
.   504  010001538      06800  ldr       r0,[r0]
.   506  01000153A      09000  str       r0,[sp]
    install(vectorTableBase + MCU.EXC_PendSV_Offset, eh);
.   508  01000153C      09800  ldr       r0,[sp]
.   510  01000153E      03038  adds      r0,#56
.   512  010001540      09902  ldr       r1,[sp,#8]
.   514  010001542  0F7FFFFD5  bl.w      -86 -> 432
.   518  010001546      0E000  b         0 -> 522
.   520  010001548      0009F  <LineNo: 159>
  END InstallErrorHandler;
.   522  01000154A      0B003  add       sp,#12
.   524  01000154C      0BD00  pop       { pc }
.   526  01000154E      0BF00  nop       
.   528  010001550  02001FFB0  <Global: Config data>


  PROCEDURE Install*(cid: INTEGER);
  (* initialise vector table for core cid *)
    VAR addr, vectorTableBase, vectorTableTop: INTEGER;
  BEGIN
.   532  010001554      0B501  push      { r0, lr }
.   534  010001556      0B083  sub       sp,#12
    ASSERT(cid < NumCores);
.   536  010001558      09803  ldr       r0,[sp,#12]
.   538  01000155A      02801  cmp       r0,#1
.   540  01000155C      0DB01  blt.n     2 -> 546
.   542  01000155E      0DF00  svc       0
.   544  010001560      000A7  <LineNo: 167>
    (* vector table address and range *)
    vectorTableBase := Config.VectMem[cid].start;
.   546  010001562      09803  ldr       r0,[sp,#12]
.   548  010001564      02801  cmp       r0,#1
.   550  010001566      0D301  bcc.n     2 -> 556
.   552  010001568      0DF01  svc       1
.   554  01000156A      000A9  <LineNo: 169>
.   556  01000156C  0F8DF10F4  ldr.w     r1,[pc,#244] -> 804
.   560  010001570      000C2  lsls      r2,r0,#3
.   562  010001572  0EB020001  add.w     r0,r2,r1
.   566  010001576      06800  ldr       r0,[r0]
.   568  010001578      09001  str       r0,[sp,#4]
    vectorTableTop := Config.VectMem[cid].end;
.   570  01000157A      09803  ldr       r0,[sp,#12]
.   572  01000157C      02801  cmp       r0,#1
.   574  01000157E      0D301  bcc.n     2 -> 580
.   576  010001580      0DF01  svc       1
.   578  010001582      000AA  <LineNo: 170>
.   580  010001584  0F8DF10DC  ldr.w     r1,[pc,#220] -> 804
.   584  010001588      000C2  lsls      r2,r0,#3
.   586  01000158A  0EB020001  add.w     r0,r2,r1
.   590  01000158E      06840  ldr       r0,[r0,#4]
.   592  010001590      09002  str       r0,[sp,#8]
    (* install excHandler for all errors and faults *)
    install(vectorTableBase + MCU.EXC_NMI_Offset, excHandler);
.   594  010001592      09801  ldr       r0,[sp,#4]
.   596  010001594      03008  adds      r0,#8
.   598  010001596      0BF00  nop       
.   600  010001598  0F2AF2144  adr.w     r1,pc,#-580 -> 24
.   604  01000159C  0F7FFFFA8  bl.w      -176 -> 432
.   608  0100015A0      0E000  b         0 -> 612
.   610  0100015A2      000AC  <LineNo: 172>
    install(vectorTableBase + MCU.EXC_HardFault_Offset, excHandler);
.   612  0100015A4      09801  ldr       r0,[sp,#4]
.   614  0100015A6      0300C  adds      r0,#12
.   616  0100015A8  0F2AF2154  adr.w     r1,pc,#-596 -> 24
.   620  0100015AC  0F7FFFFA0  bl.w      -192 -> 432
.   624  0100015B0      0E000  b         0 -> 628
.   626  0100015B2      000AD  <LineNo: 173>
    install(vectorTableBase + MCU.EXC_MemMgmtFault_Offset, excHandler);
.   628  0100015B4      09801  ldr       r0,[sp,#4]
.   630  0100015B6      03010  adds      r0,#16
.   632  0100015B8  0F2AF2164  adr.w     r1,pc,#-612 -> 24
.   636  0100015BC  0F7FFFF98  bl.w      -208 -> 432
.   640  0100015C0      0E000  b         0 -> 644
.   642  0100015C2      000AE  <LineNo: 174>
    install(vectorTableBase + MCU.EXC_BusFault_Offset, excHandler);
.   644  0100015C4      09801  ldr       r0,[sp,#4]
.   646  0100015C6      03014  adds      r0,#20
.   648  0100015C8  0F2AF2174  adr.w     r1,pc,#-628 -> 24
.   652  0100015CC  0F7FFFF90  bl.w      -224 -> 432
.   656  0100015D0      0E000  b         0 -> 660
.   658  0100015D2      000AF  <LineNo: 175>
    install(vectorTableBase + MCU.EXC_UsageFault_Offset, excHandler);
.   660  0100015D4      09801  ldr       r0,[sp,#4]
.   662  0100015D6      03018  adds      r0,#24
.   664  0100015D8  0F2AF2184  adr.w     r1,pc,#-644 -> 24
.   668  0100015DC  0F7FFFF88  bl.w      -240 -> 432
.   672  0100015E0      0E000  b         0 -> 676
.   674  0100015E2      000B0  <LineNo: 176>
    install(vectorTableBase + MCU.EXC_SecureFault_Offset, excHandler);
.   676  0100015E4      09801  ldr       r0,[sp,#4]
.   678  0100015E6      0301C  adds      r0,#28
.   680  0100015E8  0F2AF2194  adr.w     r1,pc,#-660 -> 24
.   684  0100015EC  0F7FFFF80  bl.w      -256 -> 432
.   688  0100015F0      0E000  b         0 -> 692
.   690  0100015F2      000B1  <LineNo: 177>
    install(vectorTableBase + MCU.EXC_SVC_Offset, excHandler);
.   692  0100015F4      09801  ldr       r0,[sp,#4]
.   694  0100015F6      0302C  adds      r0,#44
.   696  0100015F8  0F2AF21A4  adr.w     r1,pc,#-676 -> 24
.   700  0100015FC  0F7FFFF78  bl.w      -272 -> 432
.   704  010001600      0E000  b         0 -> 708
.   706  010001602      000B2  <LineNo: 178>
    install(vectorTableBase + MCU.EXC_DebugMon_Offset, excHandler);
.   708  010001604      09801  ldr       r0,[sp,#4]
.   710  010001606      03030  adds      r0,#48
.   712  010001608  0F2AF21B4  adr.w     r1,pc,#-692 -> 24
.   716  01000160C  0F7FFFF70  bl.w      -288 -> 432
.   720  010001610      0E000  b         0 -> 724
.   722  010001612      000B3  <LineNo: 179>
    install(vectorTableBase + MCU.EXC_SysTick_Offset, excHandler);
.   724  010001614      09801  ldr       r0,[sp,#4]
.   726  010001616      0303C  adds      r0,#60
.   728  010001618  0F2AF21C4  adr.w     r1,pc,#-708 -> 24
.   732  01000161C  0F7FFFF68  bl.w      -304 -> 432
.   736  010001620      0E000  b         0 -> 740
.   738  010001622      000B4  <LineNo: 180>
    (* install default errorhandler *)
    install(vectorTableBase + MCU.EXC_PendSV_Offset, errorHandler);
.   740  010001624      09801  ldr       r0,[sp,#4]
.   742  010001626      03038  adds      r0,#56
.   744  010001628  0F2AF11C0  adr.w     r1,pc,#-448 -> 300
.   748  01000162C  0F7FFFF60  bl.w      -320 -> 432
.   752  010001630      0E000  b         0 -> 756
.   754  010001632      000B6  <LineNo: 182>
    (* install excHandler across the rest of the vector table *)
    (* will catch any exception with a missing handler *)
    addr := vectorTableBase + MCU.EXC_IRQ0_Offset;
.   756  010001634      09801  ldr       r0,[sp,#4]
.   758  010001636      03040  adds      r0,#64
.   760  010001638      09000  str       r0,[sp]
    WHILE addr < vectorTableTop DO
.   762  01000163A      09800  ldr       r0,[sp]
.   764  01000163C      09902  ldr       r1,[sp,#8]
.   766  01000163E      04288  cmp       r0,r1
.   768  010001640  0F280800D  bge.w     26 -> 798
      install(addr, excHandler); INC(addr, 4)
.   772  010001644      09800  ldr       r0,[sp]
.   774  010001646      0BF00  nop       
.   776  010001648  0F2AF21F4  adr.w     r1,pc,#-756 -> 24
.   780  01000164C  0F7FFFF50  bl.w      -352 -> 432
.   784  010001650      0E000  b         0 -> 788
.   786  010001652      000BB  <LineNo: 187>
    END
.   788  010001654      09800  ldr       r0,[sp]
.   790  010001656      03004  adds      r0,#4
.   792  010001658      09000  str       r0,[sp]
.   794  01000165A  0F7FFBFEE  b.w       -36 -> 762
  END Install;
.   798  01000165E      0B004  add       sp,#16
.   800  010001660      0BD00  pop       { pc }
.   802  010001662      0BF00  nop       
.   804  010001664  02001FFB0  <Global: Config data>

END RuntimeErrors.
.   808  010001668      0B500  push      { lr }
.   810  01000166A      0BD00  pop       { pc }
 