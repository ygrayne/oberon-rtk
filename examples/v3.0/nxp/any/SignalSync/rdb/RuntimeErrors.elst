. <tool: Astrobe for RP2350>
. <prog: C:\Users\gray\Projects\oberon\dev\oberon-rtk\examples\v3.0\nxp\any\SignalSync\SignalSync.mod>

.     0  000001108              <Pad: 0>
MODULE RuntimeErrors;
(**
  Oberon RTK Framework
  Version: v3.0
  --
  Exception handling: run-time errors and faults
  --
  * Error: run-time errors, including ASSERT, triggered by SVC calls in software
  * Fault: hardware faults, triggered by MCU hardware
  --
  MCU: MCXA346
  --
  Copyright (c) 2020-2025 Gray, gray@grayraven.org
  https://oberon-rtk.org/licences/
**)

  IMPORT
    SYSTEM, MCU := MCU2, LED, Config;

  CONST
    NumCores = Config.NumCoresUsed;
    TraceDepth* = 16;

    (* register offsets from stacked r0 *)
    PCoffset = 24;

    (* register numbers *)
    SP = 13;

    (* PPB_SHCSR bits *)
    SECUREFAULTENA  = 19;
    USGFAULTENA     = 18;
    BUSFAULTENA     = 17;
    MEMFAULTENA     = 16;

    (* EXC_RETURN bits *)
    (*EXC_RET_S     = 6;*)  (* = 1: secure stack frame, faulty code was running in secure domain *)
    (*EXC_RET_DCRS  = 5;*)  (* = 0: all CPU regs stacked by hardware, extended state context *)
    (*EXC_RET_FType = 4;*)  (* = 0: all FPU regs stacked by hardware, extended FPU context *)
    EXC_RET_Mode  = 3;      (* = 1: thread mode, faulty code was running in thread mode *)
    EXC_RET_SPSEL = 2;      (* = 1: PSP used for stacking *)
    (*EXC_RET_ES    = 0;*)  (* = 1: exception running in secure domain *)

    (* MCU.PPB_ICSR bits *)
    PENDSVSET = 28;


  TYPE
    (* data collected for an error/fault *)
    ErrorDesc* = RECORD
      core*: BYTE;       (* MCU core *)
      errCode*: BYTE;    (* error or fault code *)
      errType*: BYTE;    (* type of error: error or fault, handler or thread mode *)
      errAddr*: INTEGER; (* error/fault code address *)
      errLineNo*: INTEGER;      (* error source code line no, if available *)
      stackframeBase*: INTEGER; (* address of exception frame stack *)
      excRetVal*: INTEGER;
      xpsr*: INTEGER
    END;
.     4  00000110C      0110C      00018  <Type:   24>
.     8  000001110      01110      00000  <Type:   0>
.    12  000001114      01114      00000  <Type:   0>
.    16  000001118      01118      00000  <Type:   0>
.    20  00000111C      0111C      00000  <Type:   0>


  VAR
    ErrorRec*: ARRAY NumCores OF ErrorDesc;


  PROCEDURE excHandler[0];
    CONST FaultCodeBase = 2; R11 = 11;
    VAR
      cid, excNo, stackframeBase, excRetAddr, excRetVal, retAddr: INTEGER;
      b0, b1: BYTE; icsr: SET;
      er: ErrorDesc;
  BEGIN
.    24  000001120  0F84DED04  push.w    { lr }
.    28  000001124      0B08E  sub       sp,#56
    SYSTEM.GET(MCU.PPB_VTOR, cid);
.    30  000001126  0F8DF0100  ldr.w     r0,[pc,#256] -> 288
.    34  00000112A      06801  ldr       r1,[r0]
.    36  00000112C      09100  str       r1,[sp]
    SYSTEM.GET(cid, cid);
.    38  00000112E      09800  ldr       r0,[sp]
.    40  000001130      06801  ldr       r1,[r0]
.    42  000001132      09100  str       r1,[sp]
    excRetAddr := SYSTEM.REG(SP) + 56; (* addr of EXC_RETURN value on stack *)
.    44  000001134      04668  mov       r0,sp
.    46  000001136      03038  adds      r0,#56
.    48  000001138      09003  str       r0,[sp,#12]
    SYSTEM.GET(excRetAddr, excRetVal);
.    50  00000113A      09803  ldr       r0,[sp,#12]
.    52  00000113C      06801  ldr       r1,[r0]
.    54  00000113E      09104  str       r1,[sp,#16]
    IF EXC_RET_SPSEL IN BITS(excRetVal) THEN (* PSP used for stacking *)
.    56  000001140      09804  ldr       r0,[sp,#16]
.    58  000001142  0F0100F04  tst.w     r0,#4
.    62  000001146  0F0008006  beq.w     12 -> 78
      SYSTEM.EMIT(MCU.MRS_R11_PSP);
.    66  00000114A  0F3EF8B09  .word     0x8B09F3EF /* EMIT */
      stackframeBase := SYSTEM.REG(R11)
    ELSE (* MSP used *)
.    70  00000114E      04658  mov       r0,r11
.    72  000001150      09002  str       r0,[sp,#8]
      stackframeBase := excRetAddr + 4;
.    74  000001152  0F000B803  b.w       6 -> 84
.    78  000001156      09803  ldr       r0,[sp,#12]
.    80  000001158      03004  adds      r0,#4
.    82  00000115A      09002  str       r0,[sp,#8]
    END;
    SYSTEM.GET(stackframeBase + PCoffset, retAddr);
.    84  00000115C      09802  ldr       r0,[sp,#8]
.    86  00000115E      03018  adds      r0,#24
.    88  000001160      06801  ldr       r1,[r0]
.    90  000001162      09105  str       r1,[sp,#20]
    SYSTEM.EMIT(MCU.MRS_R11_XPSR);
.    92  000001164  0F3EF8B03  .word     0x8B03F3EF /* EMIT */
    er.xpsr := SYSTEM.REG(R11);
.    96  000001168      04658  mov       r0,r11
.    98  00000116A      0900D  str       r0,[sp,#52]
    er.core := cid;
.   100  00000116C      09800  ldr       r0,[sp]
.   102  00000116E  0F88D0020  strb.w    r0,[sp,#32]
    er.excRetVal := excRetVal;
.   106  000001172      09804  ldr       r0,[sp,#16]
.   108  000001174      0900C  str       r0,[sp,#48]
    er.errAddr := retAddr;
.   110  000001176      09805  ldr       r0,[sp,#20]
.   112  000001178      09009  str       r0,[sp,#36]
    er.stackframeBase := stackframeBase;
.   114  00000117A      09802  ldr       r0,[sp,#8]
.   116  00000117C      0900B  str       r0,[sp,#44]

    SYSTEM.EMIT(MCU.MRS_R11_IPSR);
.   118  00000117E  0F3EF8B05  .word     0x8B05F3EF /* EMIT */
    excNo := SYSTEM.REG(R11);
.   122  000001182      04658  mov       r0,r11
.   124  000001184      09001  str       r0,[sp,#4]
    IF excNo = MCU.EXC_SVC THEN (* SVC exception *)
.   126  000001186      09801  ldr       r0,[sp,#4]
.   128  000001188      0280B  cmp       r0,#11
.   130  00000118A  0F040801C  bne.w     56 -> 190
      (* get source line number *)
      SYSTEM.GET(retAddr + 1, b1);
.   134  00000118E      09805  ldr       r0,[sp,#20]
.   136  000001190      03001  adds      r0,#1
.   138  000001192      07801  ldrb      r1,[r0]
.   140  000001194  0F88D1019  strb.w    r1,[sp,#25]
      SYSTEM.GET(retAddr, b0);
.   144  000001198      09805  ldr       r0,[sp,#20]
.   146  00000119A      07801  ldrb      r1,[r0]
.   148  00000119C  0F88D1018  strb.w    r1,[sp,#24]
      er.errLineNo := LSL(b1, 8) + b0;
.   152  0000011A0  0F89D0019  ldrb.w    r0,[sp,#25]
.   156  0000011A4      00200  lsls      r0,r0,#8
.   158  0000011A6  0F89D1018  ldrb.w    r1,[sp,#24]
.   162  0000011AA      04408  add       r0,r1
.   164  0000011AC      0900A  str       r0,[sp,#40]
      (* get imm svc value = error code *)
      SYSTEM.GET(retAddr - 2, er.errCode); (* svc instr is two bytes, imm value is lower byte *)
.   166  0000011AE      09805  ldr       r0,[sp,#20]
.   168  0000011B0      03802  subs      r0,#2
.   170  0000011B2      07801  ldrb      r1,[r0]
.   172  0000011B4  0F88D1021  strb.w    r1,[sp,#33]
      (* type: 0 = error in handler mode, 1 = error in thread mode *)
      er.errType := BFX(excRetVal, EXC_RET_Mode);
.   176  0000011B8      09804  ldr       r0,[sp,#16]
.   178  0000011BA  0F3C000C0  ubfx      r0,r0,3,1
.   182  0000011BE  0F88D0022  strb.w    r0,[sp,#34]
    ELSE (* all others *)
      er.errLineNo := 0;
.   186  0000011C2  0F000B80B  b.w       22 -> 212
.   190  0000011C6      02000  movs      r0,#0
.   192  0000011C8      0900A  str       r0,[sp,#40]
      er.errCode := excNo;
.   194  0000011CA      09801  ldr       r0,[sp,#4]
.   196  0000011CC  0F88D0021  strb.w    r0,[sp,#33]
      (* type: 2 = fault in handler mode, 3 = fault in thread mode *)
      er.errType := FaultCodeBase + BFX(excRetVal, EXC_RET_Mode);
.   200  0000011D0      09804  ldr       r0,[sp,#16]
.   202  0000011D2  0F3C000C0  ubfx      r0,r0,3,1
.   206  0000011D6      03002  adds      r0,#2
.   208  0000011D8  0F88D0022  strb.w    r0,[sp,#34]
    END;
    ErrorRec[cid] := er;
.   212  0000011DC      09800  ldr       r0,[sp]
.   214  0000011DE      02801  cmp       r0,#1
.   216  0000011E0      0D301  bcc.n     2 -> 222
.   218  0000011E2      0DF01  svc       1
.   220  0000011E4      0006C  <LineNo: 108>
.   222  0000011E6  0F8DF1048  ldr.w     r1,[pc,#72] -> 296
.   226  0000011EA      02218  movs      r2,#24
.   228  0000011EC  0FB021000  mla.w     r0,r2,r0,r1
.   232  0000011F0      02106  movs      r1,#6
.   234  0000011F2  0F11D0220  adds.w    r2,sp,#32
.   238  0000011F6  0F8523B04  ldr.w     r3,[r2],#4
.   242  0000011FA  0F8403B04  str.w     r3,[r0],#4
.   246  0000011FE      03901  subs      r1,#1
.   248  000001200      0D1F9  bne.n     -14 -> 238

    (* set PendSV pending to trigger error handler *)
    SYSTEM.GET(MCU.PPB_ICSR, icsr);
.   250  000001202  0F8DF0028  ldr.w     r0,[pc,#40] -> 292
.   254  000001206      06801  ldr       r1,[r0]
.   256  000001208      09107  str       r1,[sp,#28]
    icsr := icsr + {PENDSVSET};
.   258  00000120A      09807  ldr       r0,[sp,#28]
.   260  00000120C  0F0505080  orrs.w    r0,r0,#010000000H
.   264  000001210      09007  str       r0,[sp,#28]
    SYSTEM.PUT(MCU.PPB_ICSR, icsr);
.   266  000001212  0F8DF0018  ldr.w     r0,[pc,#24] -> 292
.   270  000001216      09907  ldr       r1,[sp,#28]
.   272  000001218      06001  str       r1,[r0]
    SYSTEM.EMIT(MCU.DSB); SYSTEM.EMIT(MCU.ISB)
.   274  00000121A  0F3BF8F4F  dsb       
  END excHandler;
.   278  00000121E  0F3BF8F6F  isb       
.   282  000001222      0B00E  add       sp,#56
.   284  000001224  0F85DFB04  pop.w     { pc }
.   288  000001228  0E000ED08  <Const:  -536810232>
.   292  00000122C  0E000ED04  <Const:  -536810236>
.   296  000001230  020027EE0  <Global: RuntimeErrors data>

  PROCEDURE* errorHandler[0];
  (* default handler: simply blink LED *)
    VAR cid, cnt, i: INTEGER; er: ErrorDesc;
  BEGIN
.   300  000001234  0E92D4070  push.w    { r4, r5, r6, lr }
.   304  000001238      0B086  sub       sp,#24
    SYSTEM.GET(MCU.PPB_VTOR, cid);
.   306  00000123A  0F8DF3068  ldr.w     r3,[pc,#104] -> 412
.   310  00000123E      06818  ldr       r0,[r3]
    SYSTEM.GET(cid, cid);
.   312  000001240      06800  ldr       r0,[r0]
    er := ErrorRec[cid];
.   314  000001242  0F8DF3070  ldr.w     r3,[pc,#112] -> 428
.   318  000001246      02418  movs      r4,#24
.   320  000001248  0FB043300  mla.w     r3,r4,r0,r3
.   324  00000124C      02406  movs      r4,#6
.   326  00000124E      0466D  mov       r5,sp
.   328  000001250  0F8536B04  ldr.w     r6,[r3],#4
.   332  000001254  0F8456B04  str.w     r6,[r5],#4
.   336  000001258      03C01  subs      r4,#1
.   338  00000125A      0D1F9  bne.n     -14 -> 328
    IF er.errType IN {0, 1} THEN
.   340  00000125C      02303  movs      r3,#3
.   342  00000125E  0F89D4002  ldrb.w    r4,[sp,#2]
.   346  000001262      02501  movs      r5,#1
.   348  000001264      040A5  lsls      r5,r4
.   350  000001266  0EA130F05  tst.w     r3,r5
.   354  00000126A  0F0008005  beq.w     10 -> 368
      cnt := 1000000
    ELSE
.   358  00000126E  0F8DF3038  ldr.w     r3,[pc,#56] -> 416
.   362  000001272      04619  mov       r1,r3
      cnt := 5000000
.   364  000001274  0F000B803  b.w       6 -> 374
    END;
.   368  000001278  0F8DF3030  ldr.w     r3,[pc,#48] -> 420
.   372  00000127C      04619  mov       r1,r3
    REPEAT
      SYSTEM.PUT(LED.LXOR, {LED.Red});
.   374  00000127E  0F8DF3030  ldr.w     r3,[pc,#48] -> 424
.   378  000001282  0F44F2480  mov.w     r4,#0040000H
.   382  000001286      0601C  str       r4,[r3]
      i := 0;
.   384  000001288      02300  movs      r3,#0
.   386  00000128A      0461A  mov       r2,r3
      WHILE i < cnt DO INC(i) END
.   388  00000128C      0428A  cmp       r2,r1
.   390  00000128E  0F2808003  bge.w     6 -> 400
.   394  000001292      03201  adds      r2,#1
.   396  000001294  0F7FFBFFA  b.w       -12 -> 388
    UNTIL FALSE
  END errorHandler;
.   400  000001298      04280  cmp       r0,r0
.   402  00000129A  0F43FAFF0  beq.w     -32 -> 374
.   406  00000129E      0B006  add       sp,#24
.   408  0000012A0  0E8BD8070  pop.w     { r4, r5, r6, pc }
.   412  0000012A4  0E000ED08  <Const:  -536810232>
.   416  0000012A8  0000F4240  <Const:  1000000>
.   420  0000012AC  0004C4B40  <Const:  5000000>
.   424  0000012B0  04010504C  <Const:  1074810956>
.   428  0000012B4  020027EE0  <Global: RuntimeErrors data>


  PROCEDURE* install(vectAddr: INTEGER; p: PROCEDURE);
  BEGIN
.   432  0000012B8      0B500  push      { lr }
    INCL(SYSTEM.VAL(SET, p), 0); (* thumb code *)
.   434  0000012BA  0F0510101  orrs.w    r1,r1,#1
    SYSTEM.PUT(vectAddr, p)
  END install;
.   438  0000012BE      06001  str       r1,[r0]
.   440  0000012C0      0BD00  pop       { pc }
.   442  0000012C2      0BF00  nop       


  PROCEDURE InstallErrorHandler*(cid: INTEGER; eh: PROCEDURE);
    VAR vectorTableBase: INTEGER;
  BEGIN
.   444  0000012C4      0B503  push      { r0, r1, lr }
.   446  0000012C6      0B081  sub       sp,#4
    vectorTableBase := Config.DataMem[cid].start;
.   448  0000012C8      09801  ldr       r0,[sp,#4]
.   450  0000012CA      02801  cmp       r0,#1
.   452  0000012CC      0D301  bcc.n     2 -> 458
.   454  0000012CE      0DF01  svc       1
.   456  0000012D0      00093  <LineNo: 147>
.   458  0000012D2  0F8DF1020  ldr.w     r1,[pc,#32] -> 492
.   462  0000012D6      000C2  lsls      r2,r0,#3
.   464  0000012D8  0EB020001  add.w     r0,r2,r1
.   468  0000012DC      06800  ldr       r0,[r0]
.   470  0000012DE      09000  str       r0,[sp]
    install(vectorTableBase + MCU.EXC_PendSV_Offset, eh);
.   472  0000012E0      09800  ldr       r0,[sp]
.   474  0000012E2      03038  adds      r0,#56
.   476  0000012E4      09902  ldr       r1,[sp,#8]
.   478  0000012E6  0F7FFFFE7  bl.w      -50 -> 432
.   482  0000012EA      0E000  b         0 -> 486
.   484  0000012EC      00094  <LineNo: 148>
  END InstallErrorHandler;
.   486  0000012EE      0B003  add       sp,#12
.   488  0000012F0      0BD00  pop       { pc }
.   490  0000012F2      0BF00  nop       
.   492  0000012F4  020027FCC  <Global: Config data>


  PROCEDURE* EnableFaults*;
  (* call from code running on core 0 AND on core 1*)
    VAR x: SET;
  BEGIN
.   496  0000012F8      0B500  push      { lr }
    SYSTEM.GET(MCU.PPB_SHCSR, x);
.   498  0000012FA  0F8DF101C  ldr.w     r1,[pc,#28] -> 528
.   502  0000012FE      06808  ldr       r0,[r1]
    x := x + {MEMFAULTENA, BUSFAULTENA, USGFAULTENA, SECUREFAULTENA};
.   504  000001300  0F4502170  orrs.w    r1,r0,#00F0000H
.   508  000001304      04608  mov       r0,r1
    SYSTEM.PUT(MCU.PPB_SHCSR, x);
.   510  000001306  0F8DF1010  ldr.w     r1,[pc,#16] -> 528
.   514  00000130A      06008  str       r0,[r1]
    SYSTEM.EMIT(MCU.DSB); SYSTEM.EMIT(MCU.ISB)
.   516  00000130C  0F3BF8F4F  dsb       
  END EnableFaults;
.   520  000001310  0F3BF8F6F  isb       
.   524  000001314      0BD00  pop       { pc }
.   526  000001316      0BF00  nop       
.   528  000001318  0E000ED24  <Const:  -536810204>


  PROCEDURE Init*;
    VAR cid, addr, vectorTableBase, vectorTableTop: INTEGER;
  BEGIN
.   532  00000131C      0B500  push      { lr }
.   534  00000131E      0B084  sub       sp,#16
    cid := 0;
.   536  000001320      02000  movs      r0,#0
.   538  000001322      09000  str       r0,[sp]
    WHILE cid < NumCores DO
.   540  000001324      09800  ldr       r0,[sp]
.   542  000001326      02801  cmp       r0,#1
.   544  000001328  0F2808062  bge.w     196 -> 744
      (* initialise vector tables for each core *)
      (* install exception handlers for all errors and faults *)
      vectorTableBase := Config.DataMem[cid].start;
.   548  00000132C      09800  ldr       r0,[sp]
.   550  00000132E      02801  cmp       r0,#1
.   552  000001330      0D301  bcc.n     2 -> 558
.   554  000001332      0DF01  svc       1
.   556  000001334      000AA  <LineNo: 170>
.   558  000001336  0F8DF10BC  ldr.w     r1,[pc,#188] -> 748
.   562  00000133A      000C2  lsls      r2,r0,#3
.   564  00000133C  0EB020001  add.w     r0,r2,r1
.   568  000001340      06800  ldr       r0,[r0]
.   570  000001342      09002  str       r0,[sp,#8]
      vectorTableTop := vectorTableBase + MCU.VectorTableSize;
.   572  000001344      09802  ldr       r0,[sp,#8]
.   574  000001346  0F5007009  add.w     r0,r0,#548
.   578  00000134A      09003  str       r0,[sp,#12]
      install(vectorTableBase + MCU.EXC_NMI_Offset, excHandler);
.   580  00000134C      09802  ldr       r0,[sp,#8]
.   582  00000134E      03008  adds      r0,#8
.   584  000001350  0F2AF2134  adr.w     r1,pc,#-564 -> 24
.   588  000001354  0F7FFFFB0  bl.w      -160 -> 432
.   592  000001358      0E000  b         0 -> 596
.   594  00000135A      000AC  <LineNo: 172>
      install(vectorTableBase + MCU.EXC_HardFault_Offset, excHandler);
.   596  00000135C      09802  ldr       r0,[sp,#8]
.   598  00000135E      0300C  adds      r0,#12
.   600  000001360  0F2AF2144  adr.w     r1,pc,#-580 -> 24
.   604  000001364  0F7FFFFA8  bl.w      -176 -> 432
.   608  000001368      0E000  b         0 -> 612
.   610  00000136A      000AD  <LineNo: 173>
      install(vectorTableBase + MCU.EXC_BusFault_Offset, excHandler);
.   612  00000136C      09802  ldr       r0,[sp,#8]
.   614  00000136E      03014  adds      r0,#20
.   616  000001370  0F2AF2154  adr.w     r1,pc,#-596 -> 24
.   620  000001374  0F7FFFFA0  bl.w      -192 -> 432
.   624  000001378      0E000  b         0 -> 628
.   626  00000137A      000AE  <LineNo: 174>
      install(vectorTableBase + MCU.EXC_UsageFault_Offset, excHandler);
.   628  00000137C      09802  ldr       r0,[sp,#8]
.   630  00000137E      03018  adds      r0,#24
.   632  000001380  0F2AF2164  adr.w     r1,pc,#-612 -> 24
.   636  000001384  0F7FFFF98  bl.w      -208 -> 432
.   640  000001388      0E000  b         0 -> 644
.   642  00000138A      000AF  <LineNo: 175>
      install(vectorTableBase + MCU.EXC_SVC_Offset, excHandler);
.   644  00000138C      09802  ldr       r0,[sp,#8]
.   646  00000138E      0302C  adds      r0,#44
.   648  000001390  0F2AF2174  adr.w     r1,pc,#-628 -> 24
.   652  000001394  0F7FFFF90  bl.w      -224 -> 432
.   656  000001398      0E000  b         0 -> 660
.   658  00000139A      000B0  <LineNo: 176>
      install(vectorTableBase + MCU.EXC_DebugMon_Offset, excHandler);
.   660  00000139C      09802  ldr       r0,[sp,#8]
.   662  00000139E      03030  adds      r0,#48
.   664  0000013A0  0F2AF2184  adr.w     r1,pc,#-644 -> 24
.   668  0000013A4  0F7FFFF88  bl.w      -240 -> 432
.   672  0000013A8      0E000  b         0 -> 676
.   674  0000013AA      000B1  <LineNo: 177>
      (* install default error handler *)
      install(vectorTableBase + MCU.EXC_PendSV_Offset, errorHandler);
.   676  0000013AC      09802  ldr       r0,[sp,#8]
.   678  0000013AE      03038  adds      r0,#56
.   680  0000013B0  0F2AF1180  adr.w     r1,pc,#-384 -> 300
.   684  0000013B4  0F7FFFF80  bl.w      -256 -> 432
.   688  0000013B8      0E000  b         0 -> 692
.   690  0000013BA      000B3  <LineNo: 179>

      (* install excHandler across the rest of the vector table *)
      (* will catch any exception with a missing handler *)
      addr := vectorTableBase + MCU.EXC_SysTick_Offset;
.   692  0000013BC      09802  ldr       r0,[sp,#8]
.   694  0000013BE      0303C  adds      r0,#60
.   696  0000013C0      09001  str       r0,[sp,#4]
      WHILE addr < vectorTableTop DO
.   698  0000013C2      09801  ldr       r0,[sp,#4]
.   700  0000013C4      09903  ldr       r1,[sp,#12]
.   702  0000013C6      04288  cmp       r0,r1
.   704  0000013C8  0F280800D  bge.w     26 -> 734
        install(addr, excHandler); INC(addr, 4)
.   708  0000013CC      09801  ldr       r0,[sp,#4]
.   710  0000013CE      0BF00  nop       
.   712  0000013D0  0F2AF21B4  adr.w     r1,pc,#-692 -> 24
.   716  0000013D4  0F7FFFF70  bl.w      -288 -> 432
.   720  0000013D8      0E000  b         0 -> 724
.   722  0000013DA      000B9  <LineNo: 185>
      END;
.   724  0000013DC      09801  ldr       r0,[sp,#4]
.   726  0000013DE      03004  adds      r0,#4
.   728  0000013E0      09001  str       r0,[sp,#4]
.   730  0000013E2  0F7FFBFEE  b.w       -36 -> 698
      INC(cid)
    END
.   734  0000013E6      09800  ldr       r0,[sp]
.   736  0000013E8      03001  adds      r0,#1
.   738  0000013EA      09000  str       r0,[sp]
.   740  0000013EC  0F7FFBF9A  b.w       -204 -> 540
  END Init;
.   744  0000013F0      0B004  add       sp,#16
.   746  0000013F2      0BD00  pop       { pc }
.   748  0000013F4  020027FCC  <Global: Config data>

END RuntimeErrors.
.   752  0000013F8      0B500  push      { lr }
.   754  0000013FA      0BD00  pop       { pc }
 