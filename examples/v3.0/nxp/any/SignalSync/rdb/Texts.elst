. <tool: Astrobe for RP2350>
. <prog: C:\Users\gray\Projects\oberon\dev\oberon-rtk\examples\v3.0\nxp\any\SignalSync\SignalSync.mod>

.     0  0000022BC              <Pad: 0>
MODULE Texts;
(**
  Oberon RTK Framework
  Version: v3.0
  --
  Formatted output to a "channel", using a 'TextIO.Writer'
  Formatted input from a "channel", using a 'TextIO.Reader'
  --
  The behaviour of the procedures depends on the write string and read
  procedures allocated to 'W' and 'R' parameters:
  * blocking
  * non-blocking (using the kernel)
  --
  Copyright (c) 2020-2025 Gray gray@grayraven.org
  https://oberon-rtk.org/licences/
**)

  IMPORT TextIO, Errors;

  CONST
    CR = 0DX;
    LF = 0AX;
    Blanks = "                                "; (* 32 blanks *)
.     4  0000022C0  020202020  <String: "    ">
.     8  0000022C4  020202020  <String: "    ">
.    12  0000022C8  020202020  <String: "    ">
.    16  0000022CC  020202020  <String: "    ">
.    20  0000022D0  020202020  <String: "    ">
.    24  0000022D4  020202020  <String: "    ">
.    28  0000022D8  020202020  <String: "    ">
.    32  0000022DC  020202020  <String: "    ">
.    36  0000022E0  000000000  <String: "....">
    MaxBlanks = 32;

    (* conversion constants *)
    MaxInt* = 07FFFFFFFH; (*  2,147,483,647 *)
    MinInt* = 080000000H; (* -2,147,483,648 *)
    MaxIntDigits* = 10;   (* sans sign, sans leading zeros *)

    (* read results *)
    NoError* = TextIO.NoError;
    BufferOverflow* = TextIO.BufferOverflow; (* a tool small buffer was provided or used *)
    SyntaxError* = TextIO.SyntaxError;      (* zero length or non-numerical chars *)
    OutOfLimits* = TextIO.OutOfLimits;    (* bigger than MaxInt, smaller than MinInt *)
    NoInput* = TextIO.NoInput;
    FifoOverrun* = TextIO.FifoOverrun;

  VAR eol: ARRAY 2 OF CHAR;

  (* write conversions *)

  PROCEDURE IntToString*(int: INTEGER; VAR str: ARRAY OF CHAR; VAR slen: INTEGER);
    VAR spos, dpos: INTEGER; digits: ARRAY 10 OF CHAR;
  BEGIN
.    40  0000022E4      0B50F  push      { r0, r1, r2, r3, lr }
.    42  0000022E6      0B085  sub       sp,#20
    ASSERT(LEN(str) >= 12, Errors.PreCond); (* 10 digits, minus sign, 0X *)
.    44  0000022E8      09807  ldr       r0,[sp,#28]
.    46  0000022EA      0280C  cmp       r0,#12
.    48  0000022EC      0DA01  bge.n     2 -> 54
.    50  0000022EE      0DF22  svc       34
.    52  0000022F0      0002E  <LineNo: 46>
    IF int = 080000000H THEN
.    54  0000022F2      09805  ldr       r0,[sp,#20]
.    56  0000022F4  0F1104F00  cmn.w     r0,#080000000H
.    60  0000022F8  0F0408027  bne.w     78 -> 142
      str := "-2147483648";
.    64  0000022FC      0200C  movs      r0,#12
.    66  0000022FE      09907  ldr       r1,[sp,#28]
.    68  000002300      04281  cmp       r1,r0
.    70  000002302      0DA01  bge.n     2 -> 76
.    72  000002304      0DF06  svc       6
.    74  000002306      00030  <LineNo: 48>
.    76  000002308      09806  ldr       r0,[sp,#24]
.    78  00000230A      0BF00  nop       
.    80  00000230C      0A100  adr       r1,pc,#0 -> 84
.    82  00000230E      0E005  b         10 -> 96
.    84  000002310  03431322D  <String: "-214">
.    88  000002314  033383437  <String: "7483">
.    92  000002318  000383436  <String: "648.">
.    96  00000231C  0F8512B04  ldr.w     r2,[r1],#4
.   100  000002320  0F8402B04  str.w     r2,[r0],#4
.   104  000002324  0F012427F  ands.w    r2,r2,#0FF000000H
.   108  000002328      0D1F8  bne.n     -16 -> 96
      str[11] := 0X;
.   110  00000232A      0200B  movs      r0,#11
.   112  00000232C      09907  ldr       r1,[sp,#28]
.   114  00000232E      04288  cmp       r0,r1
.   116  000002330      0D301  bcc.n     2 -> 122
.   118  000002332      0DF01  svc       1
.   120  000002334      00031  <LineNo: 49>
.   122  000002336      09906  ldr       r1,[sp,#24]
.   124  000002338  0EB100001  adds.w    r0,r0,r1
.   128  00000233C      02100  movs      r1,#0
.   130  00000233E      07001  strb      r1,[r0]
      slen := 11
    ELSE
.   132  000002340      0200B  movs      r0,#11
.   134  000002342      09908  ldr       r1,[sp,#32]
.   136  000002344      06008  str       r0,[r1]
      spos := 0;
.   138  000002346  0F000B86D  b.w       218 -> 360
.   142  00000234A      02000  movs      r0,#0
.   144  00000234C      09000  str       r0,[sp]
      IF int < 0 THEN
.   146  00000234E      09805  ldr       r0,[sp,#20]
.   148  000002350      02800  cmp       r0,#0
.   150  000002352  0F2808012  bge.w     36 -> 190
        int := -int;
.   154  000002356      09805  ldr       r0,[sp,#20]
.   156  000002358  0F1D00000  rsbs.w    r0,r0,#0
.   160  00000235C      09005  str       r0,[sp,#20]
        str[spos] := "-";
.   162  00000235E      09800  ldr       r0,[sp]
.   164  000002360      09907  ldr       r1,[sp,#28]
.   166  000002362      04288  cmp       r0,r1
.   168  000002364      0D301  bcc.n     2 -> 174
.   170  000002366      0DF01  svc       1
.   172  000002368      00037  <LineNo: 55>
.   174  00000236A      09906  ldr       r1,[sp,#24]
.   176  00000236C  0EB100001  adds.w    r0,r0,r1
.   180  000002370      0212D  movs      r1,#45
.   182  000002372      07001  strb      r1,[r0]
        INC(spos)
      END;
.   184  000002374      09800  ldr       r0,[sp]
.   186  000002376      03001  adds      r0,#1
.   188  000002378      09000  str       r0,[sp]
      dpos := 0;
.   190  00000237A      02000  movs      r0,#0
.   192  00000237C      09001  str       r0,[sp,#4]
      REPEAT
        digits[dpos] := CHR(int MOD 10 + ORD("0"));
.   194  00000237E      09801  ldr       r0,[sp,#4]
.   196  000002380      0280A  cmp       r0,#10
.   198  000002382      0D301  bcc.n     2 -> 204
.   200  000002384      0DF01  svc       1
.   202  000002386      0003C  <LineNo: 60>
.   204  000002388  0EB1D0000  adds.w    r0,sp,r0
.   208  00000238C      09905  ldr       r1,[sp,#20]
.   210  00000238E      0220A  movs      r2,#10
.   212  000002390  0FB91F3F2  sdiv.w    r3,r1,r2
.   216  000002394  0FB031112  mls.w     r1,r3,r2,r1
.   220  000002398  0F1B10F00  cmp.w     r1,#0
.   224  00000239C      0BF48  it        mi
.   226  00000239E  0EB010102  addmi.w   r1,r1,r2
.   230  0000023A2      03130  adds      r1,#48
.   232  0000023A4      07201  strb      r1,[r0,#8]
        int := int DIV 10;
.   234  0000023A6      09805  ldr       r0,[sp,#20]
.   236  0000023A8      0210A  movs      r1,#10
.   238  0000023AA  0FB90F2F1  sdiv.w    r2,r0,r1
.   242  0000023AE  0FB020011  mls.w     r0,r2,r1,r0
.   246  0000023B2  0EBA270D0  sub.w     r0,r2,r0,lsr 31
.   250  0000023B6      09005  str       r0,[sp,#20]
        INC(dpos)
      UNTIL int = 0;
.   252  0000023B8      09801  ldr       r0,[sp,#4]
.   254  0000023BA      03001  adds      r0,#1
.   256  0000023BC      09001  str       r0,[sp,#4]
.   258  0000023BE      09805  ldr       r0,[sp,#20]
.   260  0000023C0      02800  cmp       r0,#0
.   262  0000023C2  0F47FAFDC  bne.w     -72 -> 194
      DEC(dpos);
.   266  0000023C6      09801  ldr       r0,[sp,#4]
.   268  0000023C8      03801  subs      r0,#1
.   270  0000023CA      09001  str       r0,[sp,#4]
      WHILE dpos >= 0 DO
.   272  0000023CC      09801  ldr       r0,[sp,#4]
.   274  0000023CE      02800  cmp       r0,#0
.   276  0000023D0  0F2C0801A  blt.w     52 -> 332
        str[spos] := digits[dpos];
.   280  0000023D4      09800  ldr       r0,[sp]
.   282  0000023D6      09907  ldr       r1,[sp,#28]
.   284  0000023D8      04288  cmp       r0,r1
.   286  0000023DA      0D301  bcc.n     2 -> 292
.   288  0000023DC      0DF01  svc       1
.   290  0000023DE      00042  <LineNo: 66>
.   292  0000023E0      09906  ldr       r1,[sp,#24]
.   294  0000023E2  0EB100001  adds.w    r0,r0,r1
.   298  0000023E6      09901  ldr       r1,[sp,#4]
.   300  0000023E8      0290A  cmp       r1,#10
.   302  0000023EA      0D301  bcc.n     2 -> 308
.   304  0000023EC      0DF01  svc       1
.   306  0000023EE      00042  <LineNo: 66>
.   308  0000023F0  0EB1D0101  adds.w    r1,sp,r1
.   312  0000023F4      07A09  ldrb      r1,[r1,#8]
.   314  0000023F6      07001  strb      r1,[r0]
        DEC(dpos); INC(spos)
.   316  0000023F8      09801  ldr       r0,[sp,#4]
.   318  0000023FA      03801  subs      r0,#1
.   320  0000023FC      09001  str       r0,[sp,#4]
      END;
.   322  0000023FE      09800  ldr       r0,[sp]
.   324  000002400      03001  adds      r0,#1
.   326  000002402      09000  str       r0,[sp]
.   328  000002404  0F7FFBFE2  b.w       -60 -> 272
      str[spos] := 0X;
.   332  000002408      09800  ldr       r0,[sp]
.   334  00000240A      09907  ldr       r1,[sp,#28]
.   336  00000240C      04288  cmp       r0,r1
.   338  00000240E      0D301  bcc.n     2 -> 344
.   340  000002410      0DF01  svc       1
.   342  000002412      00045  <LineNo: 69>
.   344  000002414      09906  ldr       r1,[sp,#24]
.   346  000002416  0EB100001  adds.w    r0,r0,r1
.   350  00000241A      02100  movs      r1,#0
.   352  00000241C      07001  strb      r1,[r0]
      slen := spos
    END
.   354  00000241E      09800  ldr       r0,[sp]
.   356  000002420      09908  ldr       r1,[sp,#32]
.   358  000002422      06008  str       r0,[r1]
  END IntToString;
.   360  000002424      0B009  add       sp,#36
.   362  000002426      0BD00  pop       { pc }


  PROCEDURE IntToHexString*(int: INTEGER; VAR str: ARRAY OF CHAR; VAR slen: INTEGER);
    VAR dpos, spos, d: INTEGER; digits: ARRAY 10 OF CHAR;
  BEGIN
.   364  000002428      0B50F  push      { r0, r1, r2, r3, lr }
.   366  00000242A      0B086  sub       sp,#24
    ASSERT(LEN(str) >= 10, Errors.PreCond);
.   368  00000242C      09808  ldr       r0,[sp,#32]
.   370  00000242E      0280A  cmp       r0,#10
.   372  000002430      0DA01  bge.n     2 -> 378
.   374  000002432      0DF22  svc       34
.   376  000002434      0004E  <LineNo: 78>
    dpos := 0;
.   378  000002436      02000  movs      r0,#0
.   380  000002438      09000  str       r0,[sp]
    REPEAT
      d := int MOD 010H;
.   382  00000243A      09806  ldr       r0,[sp,#24]
.   384  00000243C  0F000000F  and.w     r0,r0,#15
.   388  000002440      09002  str       r0,[sp,#8]
      IF d < 10 THEN
.   390  000002442      09802  ldr       r0,[sp,#8]
.   392  000002444      0280A  cmp       r0,#10
.   394  000002446  0F280800C  bge.w     24 -> 422
        digits[dpos] := CHR(d + ORD("0"))
.   398  00000244A      09800  ldr       r0,[sp]
.   400  00000244C      0280A  cmp       r0,#10
.   402  00000244E      0D301  bcc.n     2 -> 408
.   404  000002450      0DF01  svc       1
.   406  000002452      00053  <LineNo: 83>
.   408  000002454  0EB1D0000  adds.w    r0,sp,r0
.   412  000002458      09902  ldr       r1,[sp,#8]
.   414  00000245A      03130  adds      r1,#48
      ELSE
.   416  00000245C      07301  strb      r1,[r0,#12]
        digits[dpos] := CHR(d - 10 + ORD("A"))
.   418  00000245E  0F000B80B  b.w       22 -> 444
.   422  000002462      09800  ldr       r0,[sp]
.   424  000002464      0280A  cmp       r0,#10
.   426  000002466      0D301  bcc.n     2 -> 432
.   428  000002468      0DF01  svc       1
.   430  00000246A      00055  <LineNo: 85>
.   432  00000246C  0EB1D0000  adds.w    r0,sp,r0
.   436  000002470      09902  ldr       r1,[sp,#8]
.   438  000002472      0390A  subs      r1,#10
.   440  000002474      03141  adds      r1,#65
      END;
.   442  000002476      07301  strb      r1,[r0,#12]
      int := int DIV 010H;
.   444  000002478      09806  ldr       r0,[sp,#24]
.   446  00000247A      01100  asrs      r0,r0,#4
.   448  00000247C      09006  str       r0,[sp,#24]
      INC(dpos)
    UNTIL dpos = 8;
.   450  00000247E      09800  ldr       r0,[sp]
.   452  000002480      03001  adds      r0,#1
.   454  000002482      09000  str       r0,[sp]
.   456  000002484      09800  ldr       r0,[sp]
.   458  000002486      02808  cmp       r0,#8
.   460  000002488  0F47FAFD7  bne.w     -82 -> 382
    DEC(dpos); spos := 0;
.   464  00000248C      09800  ldr       r0,[sp]
.   466  00000248E      03801  subs      r0,#1
.   468  000002490      09000  str       r0,[sp]
.   470  000002492      02000  movs      r0,#0
.   472  000002494      09001  str       r0,[sp,#4]
    WHILE dpos >= 0 DO
.   474  000002496      09800  ldr       r0,[sp]
.   476  000002498      02800  cmp       r0,#0
.   478  00000249A  0F2C0801A  blt.w     52 -> 534
      str[spos] := digits[dpos];
.   482  00000249E      09801  ldr       r0,[sp,#4]
.   484  0000024A0      09908  ldr       r1,[sp,#32]
.   486  0000024A2      04288  cmp       r0,r1
.   488  0000024A4      0D301  bcc.n     2 -> 494
.   490  0000024A6      0DF01  svc       1
.   492  0000024A8      0005C  <LineNo: 92>
.   494  0000024AA      09907  ldr       r1,[sp,#28]
.   496  0000024AC  0EB100001  adds.w    r0,r0,r1
.   500  0000024B0      09900  ldr       r1,[sp]
.   502  0000024B2      0290A  cmp       r1,#10
.   504  0000024B4      0D301  bcc.n     2 -> 510
.   506  0000024B6      0DF01  svc       1
.   508  0000024B8      0005C  <LineNo: 92>
.   510  0000024BA  0EB1D0101  adds.w    r1,sp,r1
.   514  0000024BE      07B09  ldrb      r1,[r1,#12]
.   516  0000024C0      07001  strb      r1,[r0]
      DEC(dpos); INC(spos)
.   518  0000024C2      09800  ldr       r0,[sp]
.   520  0000024C4      03801  subs      r0,#1
.   522  0000024C6      09000  str       r0,[sp]
    END;
.   524  0000024C8      09801  ldr       r0,[sp,#4]
.   526  0000024CA      03001  adds      r0,#1
.   528  0000024CC      09001  str       r0,[sp,#4]
.   530  0000024CE  0F7FFBFE2  b.w       -60 -> 474
    str[8] := "H";
.   534  0000024D2      02008  movs      r0,#8
.   536  0000024D4      09908  ldr       r1,[sp,#32]
.   538  0000024D6      04288  cmp       r0,r1
.   540  0000024D8      0D301  bcc.n     2 -> 546
.   542  0000024DA      0DF01  svc       1
.   544  0000024DC      0005F  <LineNo: 95>
.   546  0000024DE      09907  ldr       r1,[sp,#28]
.   548  0000024E0  0EB100001  adds.w    r0,r0,r1
.   552  0000024E4      02148  movs      r1,#72
.   554  0000024E6      07001  strb      r1,[r0]
    str[9] := 0X;
.   556  0000024E8      02009  movs      r0,#9
.   558  0000024EA      09908  ldr       r1,[sp,#32]
.   560  0000024EC      04288  cmp       r0,r1
.   562  0000024EE      0D301  bcc.n     2 -> 568
.   564  0000024F0      0DF01  svc       1
.   566  0000024F2      00060  <LineNo: 96>
.   568  0000024F4      09907  ldr       r1,[sp,#28]
.   570  0000024F6  0EB100001  adds.w    r0,r0,r1
.   574  0000024FA      02100  movs      r1,#0
.   576  0000024FC      07001  strb      r1,[r0]
    slen := 9
  END IntToHexString;
.   578  0000024FE      02009  movs      r0,#9
.   580  000002500      09909  ldr       r1,[sp,#36]
.   582  000002502      06008  str       r0,[r1]
.   584  000002504      0B00A  add       sp,#40
.   586  000002506      0BD00  pop       { pc }


  PROCEDURE IntToBinString*(int: INTEGER; VAR str: ARRAY OF CHAR; VAR slen: INTEGER);
    VAR
      i, j, k: INTEGER;
      bits: SET;
  BEGIN
.   588  000002508      0B50F  push      { r0, r1, r2, r3, lr }
.   590  00000250A      0B084  sub       sp,#16
    ASSERT(LEN(str) >= 36, Errors.PreCond);
.   592  00000250C      09806  ldr       r0,[sp,#24]
.   594  00000250E      02824  cmp       r0,#36
.   596  000002510      0DA01  bge.n     2 -> 602
.   598  000002512      0DF22  svc       34
.   600  000002514      0006A  <LineNo: 106>
    k := 0;
.   602  000002516      02000  movs      r0,#0
.   604  000002518      09002  str       r0,[sp,#8]
    FOR i := 0 TO 3 DO
.   606  00000251A      02000  movs      r0,#0
.   608  00000251C      09000  str       r0,[sp]
      bits := BITS(BFX(int, 31, 24));
.   610  00000251E      09800  ldr       r0,[sp]
.   612  000002520      02803  cmp       r0,#3
.   614  000002522  0F3008048  bgt.w     144 -> 762
.   618  000002526      09804  ldr       r0,[sp,#16]
.   620  000002528  0F3C06007  ubfx      r0,r0,24,8
.   624  00000252C      09003  str       r0,[sp,#12]
      int := LSL(int, 8);
.   626  00000252E      09804  ldr       r0,[sp,#16]
.   628  000002530      00200  lsls      r0,r0,#8
.   630  000002532      09004  str       r0,[sp,#16]
      FOR j := 7 TO 0 BY -1 DO
.   632  000002534      02007  movs      r0,#7
.   634  000002536      09001  str       r0,[sp,#4]
        IF j IN bits THEN str[k] := "1" ELSE str[k] := "0" END;
.   636  000002538      09801  ldr       r0,[sp,#4]
.   638  00000253A      02800  cmp       r0,#0
.   640  00000253C  0F2C08028  blt.w     80 -> 724
.   644  000002540      09803  ldr       r0,[sp,#12]
.   646  000002542      09901  ldr       r1,[sp,#4]
.   648  000002544      02201  movs      r2,#1
.   650  000002546      0408A  lsls      r2,r1
.   652  000002548  0EA100F02  tst.w     r0,r2
.   656  00000254C  0F000800D  beq.w     26 -> 686
.   660  000002550      09802  ldr       r0,[sp,#8]
.   662  000002552      09906  ldr       r1,[sp,#24]
.   664  000002554      04288  cmp       r0,r1
.   666  000002556      0D301  bcc.n     2 -> 672
.   668  000002558      0DF01  svc       1
.   670  00000255A      00070  <LineNo: 112>
.   672  00000255C      09905  ldr       r1,[sp,#20]
.   674  00000255E  0EB100001  adds.w    r0,r0,r1
.   678  000002562      02131  movs      r1,#49
.   680  000002564      07001  strb      r1,[r0]
.   682  000002566  0F000B80B  b.w       22 -> 708
.   686  00000256A      09802  ldr       r0,[sp,#8]
.   688  00000256C      09906  ldr       r1,[sp,#24]
.   690  00000256E      04288  cmp       r0,r1
.   692  000002570      0D301  bcc.n     2 -> 698
.   694  000002572      0DF01  svc       1
.   696  000002574      00070  <LineNo: 112>
.   698  000002576      09905  ldr       r1,[sp,#20]
.   700  000002578  0EB100001  adds.w    r0,r0,r1
.   704  00000257C      02130  movs      r1,#48
.   706  00000257E      07001  strb      r1,[r0]
        INC(k)
      END;
.   708  000002580      09802  ldr       r0,[sp,#8]
.   710  000002582      03001  adds      r0,#1
.   712  000002584      09002  str       r0,[sp,#8]
.   714  000002586      09801  ldr       r0,[sp,#4]
.   716  000002588      03801  subs      r0,#1
.   718  00000258A      09001  str       r0,[sp,#4]
.   720  00000258C  0F7FFBFD4  b.w       -88 -> 636
      str[k] := " ";
.   724  000002590      09802  ldr       r0,[sp,#8]
.   726  000002592      09906  ldr       r1,[sp,#24]
.   728  000002594      04288  cmp       r0,r1
.   730  000002596      0D301  bcc.n     2 -> 736
.   732  000002598      0DF01  svc       1
.   734  00000259A      00073  <LineNo: 115>
.   736  00000259C      09905  ldr       r1,[sp,#20]
.   738  00000259E  0EB100001  adds.w    r0,r0,r1
.   742  0000025A2      02120  movs      r1,#32
.   744  0000025A4      07001  strb      r1,[r0]
      INC(k)
    END;
.   746  0000025A6      09802  ldr       r0,[sp,#8]
.   748  0000025A8      03001  adds      r0,#1
.   750  0000025AA      09002  str       r0,[sp,#8]
.   752  0000025AC      09800  ldr       r0,[sp]
.   754  0000025AE      03001  adds      r0,#1
.   756  0000025B0      09000  str       r0,[sp]
.   758  0000025B2  0F7FFBFB4  b.w       -152 -> 610
    str[35] := 0X;
.   762  0000025B6      02023  movs      r0,#35
.   764  0000025B8      09906  ldr       r1,[sp,#24]
.   766  0000025BA      04288  cmp       r0,r1
.   768  0000025BC      0D301  bcc.n     2 -> 774
.   770  0000025BE      0DF01  svc       1
.   772  0000025C0      00076  <LineNo: 118>
.   774  0000025C2      09905  ldr       r1,[sp,#20]
.   776  0000025C4  0EB100001  adds.w    r0,r0,r1
.   780  0000025C8      02100  movs      r1,#0
.   782  0000025CA      07001  strb      r1,[r0]
    slen := 35
  END IntToBinString;
.   784  0000025CC      02023  movs      r0,#35
.   786  0000025CE      09907  ldr       r1,[sp,#28]
.   788  0000025D0      06008  str       r0,[r1]
.   790  0000025D2      0B008  add       sp,#32
.   792  0000025D4      0BD00  pop       { pc }
.   794  0000025D6      0BF00  nop       

  (* write *)

  PROCEDURE Write*(W: TextIO.Writer; ch: CHAR);
    VAR s: ARRAY 1 OF CHAR;
  BEGIN
.   796  0000025D8      0B503  push      { r0, r1, lr }
.   798  0000025DA      0B081  sub       sp,#4
    s[0] := ch;
.   800  0000025DC  0F89D0008  ldrb.w    r0,[sp,#8]
.   804  0000025E0  0F88D0000  strb.w    r0,[sp]
    W.putString(W.dev, s, 1)
.   808  0000025E4      09801  ldr       r0,[sp,#4]
.   810  0000025E6      06800  ldr       r0,[r0]
.   812  0000025E8      04669  mov       r1,sp
.   814  0000025EA      02201  movs      r2,#1
.   816  0000025EC      02301  movs      r3,#1
  END Write;
.   818  0000025EE      09C01  ldr       r4,[sp,#4]
.   820  0000025F0      06864  ldr       r4,[r4,#4]
.   822  0000025F2  0F1B40F00  cmp.w     r4,#0
.   826  0000025F6      0D101  bne.n     2 -> 832
.   828  0000025F8      0DF05  svc       5
.   830  0000025FA      00080  <LineNo: 128>
.   832  0000025FC      03401  adds      r4,#1
.   834  0000025FE      047A0  blx       r4
.   836  000002600      0E000  b         0 -> 840
.   838  000002602      00080  <LineNo: 128>
.   840  000002604      0B003  add       sp,#12
.   842  000002606      0BD00  pop       { pc }


  PROCEDURE WriteString*(W: TextIO.Writer; str: ARRAY OF CHAR);
    VAR i: INTEGER;
  BEGIN
.   844  000002608      0B507  push      { r0, r1, r2, lr }
.   846  00000260A      0B081  sub       sp,#4
    i := 0;
.   848  00000260C      02000  movs      r0,#0
.   850  00000260E      09000  str       r0,[sp]
    WHILE (i < LEN(str)) & (str[i] # 0X) DO INC(i) END;
.   852  000002610      09800  ldr       r0,[sp]
.   854  000002612      09903  ldr       r1,[sp,#12]
.   856  000002614      04288  cmp       r0,r1
.   858  000002616  0F2808012  bge.w     36 -> 898
.   862  00000261A      09800  ldr       r0,[sp]
.   864  00000261C      09903  ldr       r1,[sp,#12]
.   866  00000261E      04288  cmp       r0,r1
.   868  000002620      0D301  bcc.n     2 -> 874
.   870  000002622      0DF01  svc       1
.   872  000002624      00088  <LineNo: 136>
.   874  000002626      09902  ldr       r1,[sp,#8]
.   876  000002628  0EB100001  adds.w    r0,r0,r1
.   880  00000262C      07800  ldrb      r0,[r0]
.   882  00000262E      02800  cmp       r0,#0
.   884  000002630  0F0008005  beq.w     10 -> 898
.   888  000002634      09800  ldr       r0,[sp]
.   890  000002636      03001  adds      r0,#1
.   892  000002638      09000  str       r0,[sp]
.   894  00000263A  0F7FFBFE9  b.w       -46 -> 852
    W.putString(W.dev, str, i)
.   898  00000263E      09801  ldr       r0,[sp,#4]
.   900  000002640      06800  ldr       r0,[r0]
.   902  000002642      09902  ldr       r1,[sp,#8]
.   904  000002644      09A03  ldr       r2,[sp,#12]
.   906  000002646      09B00  ldr       r3,[sp]
  END WriteString;
.   908  000002648      09C01  ldr       r4,[sp,#4]
.   910  00000264A      06864  ldr       r4,[r4,#4]
.   912  00000264C  0F1B40F00  cmp.w     r4,#0
.   916  000002650      0D101  bne.n     2 -> 922
.   918  000002652      0DF05  svc       5
.   920  000002654      00089  <LineNo: 137>
.   922  000002656      03401  adds      r4,#1
.   924  000002658      047A0  blx       r4
.   926  00000265A      0E000  b         0 -> 930
.   928  00000265C      00089  <LineNo: 137>
.   930  00000265E      0B004  add       sp,#16
.   932  000002660      0BD00  pop       { pc }
.   934  000002662      0BF00  nop       


  PROCEDURE WriteLn*(W: TextIO.Writer);
  BEGIN
.   936  000002664      0B501  push      { r0, lr }
    W.putString(W.dev, eol, 2)
.   938  000002666      09800  ldr       r0,[sp]
.   940  000002668      06800  ldr       r0,[r0]
.   942  00000266A  0F8DF1020  ldr.w     r1,[pc,#32] -> 976
.   946  00000266E      02202  movs      r2,#2
.   948  000002670      02302  movs      r3,#2
  END WriteLn;
.   950  000002672      09C00  ldr       r4,[sp]
.   952  000002674      06864  ldr       r4,[r4,#4]
.   954  000002676  0F1B40F00  cmp.w     r4,#0
.   958  00000267A      0D101  bne.n     2 -> 964
.   960  00000267C      0DF05  svc       5
.   962  00000267E      0008F  <LineNo: 143>
.   964  000002680      03401  adds      r4,#1
.   966  000002682      047A0  blx       r4
.   968  000002684      0E000  b         0 -> 972
.   970  000002686      0008F  <LineNo: 143>
.   972  000002688      0B001  add       sp,#4
.   974  00000268A      0BD00  pop       { pc }
.   976  00000268C  020027ED8  <Global: Texts data>


  PROCEDURE writeNumString(W: TextIO.Writer; str: ARRAY OF CHAR; numChars, leftPadding: INTEGER);
  BEGIN
.   980  000002690      0B51F  push      { r0, r1, r2, r3, r4, lr }
    IF leftPadding > MaxBlanks THEN leftPadding := MaxBlanks END;
.   982  000002692      09804  ldr       r0,[sp,#16]
.   984  000002694      02820  cmp       r0,#32
.   986  000002696  0F3408002  ble.w     4 -> 994
.   990  00000269A      02020  movs      r0,#32
.   992  00000269C      09004  str       r0,[sp,#16]
    IF leftPadding > 0 THEN
.   994  00000269E      09804  ldr       r0,[sp,#16]
.   996  0000026A0      02800  cmp       r0,#0
.   998  0000026A2  0F3408013  ble.w     38 -> 1040
      W.putString(W.dev, Blanks, leftPadding)
.  1002  0000026A6      09800  ldr       r0,[sp]
.  1004  0000026A8      06800  ldr       r0,[r0]
.  1006  0000026AA      0BF00  nop       
.  1008  0000026AC      0467A  mov       r2,pc
.  1010  0000026AE  0F5B2717C  subs.w    r1,r2,#1008
.  1014  0000026B2      02221  movs      r2,#33
.  1016  0000026B4      09B04  ldr       r3,[sp,#16]
    END;
.  1018  0000026B6      09C00  ldr       r4,[sp]
.  1020  0000026B8      06864  ldr       r4,[r4,#4]
.  1022  0000026BA  0F1B40F00  cmp.w     r4,#0
.  1026  0000026BE      0D101  bne.n     2 -> 1032
.  1028  0000026C0      0DF05  svc       5
.  1030  0000026C2      00097  <LineNo: 151>
.  1032  0000026C4      03401  adds      r4,#1
.  1034  0000026C6      047A0  blx       r4
.  1036  0000026C8      0E000  b         0 -> 1040
.  1038  0000026CA      00097  <LineNo: 151>
    W.putString(W.dev, str, numChars)
.  1040  0000026CC      09800  ldr       r0,[sp]
.  1042  0000026CE      06800  ldr       r0,[r0]
.  1044  0000026D0      09901  ldr       r1,[sp,#4]
.  1046  0000026D2      09A02  ldr       r2,[sp,#8]
.  1048  0000026D4      09B03  ldr       r3,[sp,#12]
  END writeNumString;
.  1050  0000026D6      09C00  ldr       r4,[sp]
.  1052  0000026D8      06864  ldr       r4,[r4,#4]
.  1054  0000026DA  0F1B40F00  cmp.w     r4,#0
.  1058  0000026DE      0D101  bne.n     2 -> 1064
.  1060  0000026E0      0DF05  svc       5
.  1062  0000026E2      00099  <LineNo: 153>
.  1064  0000026E4      03401  adds      r4,#1
.  1066  0000026E6      047A0  blx       r4
.  1068  0000026E8      0E000  b         0 -> 1072
.  1070  0000026EA      00099  <LineNo: 153>
.  1072  0000026EC      0B005  add       sp,#20
.  1074  0000026EE      0BD00  pop       { pc }


  PROCEDURE WriteInt*(W: TextIO.Writer; int, width: INTEGER);
    VAR buffer: ARRAY 12 OF CHAR; strLen: INTEGER;
  BEGIN
.  1076  0000026F0      0B507  push      { r0, r1, r2, lr }
.  1078  0000026F2      0B084  sub       sp,#16
    IntToString(int, buffer, strLen);
.  1080  0000026F4      09805  ldr       r0,[sp,#20]
.  1082  0000026F6      04669  mov       r1,sp
.  1084  0000026F8      0220C  movs      r2,#12
.  1086  0000026FA  0F11D030C  adds.w    r3,sp,#12
.  1090  0000026FE  0F7FFFDF1  bl.w      -1054 -> 40
.  1094  000002702      0E000  b         0 -> 1098
.  1096  000002704      000A0  <LineNo: 160>
    writeNumString(W, buffer, strLen, width - strLen)
.  1098  000002706      09804  ldr       r0,[sp,#16]
.  1100  000002708      04669  mov       r1,sp
.  1102  00000270A      0220C  movs      r2,#12
.  1104  00000270C      09B03  ldr       r3,[sp,#12]
.  1106  00000270E      09C06  ldr       r4,[sp,#24]
.  1108  000002710      09D03  ldr       r5,[sp,#12]
.  1110  000002712  0EBA40405  sub.w     r4,r4,r5
  END WriteInt;
.  1114  000002716  0F7FFFFBB  bl.w      -138 -> 980
.  1118  00000271A      0E000  b         0 -> 1122
.  1120  00000271C      000A1  <LineNo: 161>
.  1122  00000271E      0B007  add       sp,#28
.  1124  000002720      0BD00  pop       { pc }
.  1126  000002722      0BF00  nop       


  PROCEDURE WriteHex*(W: TextIO.Writer; int, width: INTEGER);
    VAR buffer: ARRAY 12 OF CHAR; strLen: INTEGER;
  BEGIN
.  1128  000002724      0B507  push      { r0, r1, r2, lr }
.  1130  000002726      0B084  sub       sp,#16
    IntToHexString(int, buffer, strLen);
.  1132  000002728      09805  ldr       r0,[sp,#20]
.  1134  00000272A      04669  mov       r1,sp
.  1136  00000272C      0220C  movs      r2,#12
.  1138  00000272E  0F11D030C  adds.w    r3,sp,#12
.  1142  000002732  0F7FFFE79  bl.w      -782 -> 364
.  1146  000002736      0E000  b         0 -> 1150
.  1148  000002738      000A8  <LineNo: 168>
    writeNumString(W, buffer, strLen, width - strLen)
.  1150  00000273A      09804  ldr       r0,[sp,#16]
.  1152  00000273C      04669  mov       r1,sp
.  1154  00000273E      0220C  movs      r2,#12
.  1156  000002740      09B03  ldr       r3,[sp,#12]
.  1158  000002742      09C06  ldr       r4,[sp,#24]
.  1160  000002744      09D03  ldr       r5,[sp,#12]
.  1162  000002746  0EBA40405  sub.w     r4,r4,r5
  END WriteHex;
.  1166  00000274A  0F7FFFFA1  bl.w      -190 -> 980
.  1170  00000274E      0E000  b         0 -> 1174
.  1172  000002750      000A9  <LineNo: 169>
.  1174  000002752      0B007  add       sp,#28
.  1176  000002754      0BD00  pop       { pc }
.  1178  000002756      0BF00  nop       


  PROCEDURE WriteBin*(W: TextIO.Writer; int, width: INTEGER);
    VAR buffer: ARRAY 36 OF CHAR; strLen: INTEGER;
  BEGIN
.  1180  000002758      0B507  push      { r0, r1, r2, lr }
.  1182  00000275A      0B08A  sub       sp,#40
    IntToBinString(int, buffer, strLen);
.  1184  00000275C      0980B  ldr       r0,[sp,#44]
.  1186  00000275E      04669  mov       r1,sp
.  1188  000002760      02224  movs      r2,#36
.  1190  000002762  0F11D0324  adds.w    r3,sp,#36
.  1194  000002766  0F7FFFECF  bl.w      -610 -> 588
.  1198  00000276A      0E000  b         0 -> 1202
.  1200  00000276C      000B0  <LineNo: 176>
    writeNumString(W, buffer, strLen, width - strLen)
.  1202  00000276E      0980A  ldr       r0,[sp,#40]
.  1204  000002770      04669  mov       r1,sp
.  1206  000002772      02224  movs      r2,#36
.  1208  000002774      09B09  ldr       r3,[sp,#36]
.  1210  000002776      09C0C  ldr       r4,[sp,#48]
.  1212  000002778      09D09  ldr       r5,[sp,#36]
.  1214  00000277A  0EBA40405  sub.w     r4,r4,r5
  END WriteBin;
.  1218  00000277E  0F7FFFF87  bl.w      -242 -> 980
.  1222  000002782      0E000  b         0 -> 1226
.  1224  000002784      000B1  <LineNo: 177>
.  1226  000002786      0B00D  add       sp,#52
.  1228  000002788      0BD00  pop       { pc }
.  1230  00000278A      0BF00  nop       

  (* read conversions *)

  PROCEDURE cleanLeft(str: ARRAY OF CHAR; VAR first: INTEGER; VAR neg: BOOLEAN);
    VAR ch: CHAR;
  BEGIN
.  1232  00000278C      0B50F  push      { r0, r1, r2, r3, lr }
.  1234  00000278E      0B081  sub       sp,#4
    first := 0;
.  1236  000002790      02000  movs      r0,#0
.  1238  000002792      09903  ldr       r1,[sp,#12]
.  1240  000002794      06008  str       r0,[r1]
    WHILE str[first] = " " DO INC(first) END;
.  1242  000002796      09803  ldr       r0,[sp,#12]
.  1244  000002798      06800  ldr       r0,[r0]
.  1246  00000279A      09902  ldr       r1,[sp,#8]
.  1248  00000279C      04288  cmp       r0,r1
.  1250  00000279E      0D301  bcc.n     2 -> 1256
.  1252  0000027A0      0DF01  svc       1
.  1254  0000027A2      000BA  <LineNo: 186>
.  1256  0000027A4      09901  ldr       r1,[sp,#4]
.  1258  0000027A6  0EB100001  adds.w    r0,r0,r1
.  1262  0000027AA      07800  ldrb      r0,[r0]
.  1264  0000027AC      02820  cmp       r0,#32
.  1266  0000027AE  0F0408006  bne.w     12 -> 1282
.  1270  0000027B2      09803  ldr       r0,[sp,#12]
.  1272  0000027B4      06801  ldr       r1,[r0]
.  1274  0000027B6      03101  adds      r1,#1
.  1276  0000027B8      06001  str       r1,[r0]
.  1278  0000027BA  0F7FFBFEC  b.w       -40 -> 1242
    ch := str[first];
.  1282  0000027BE      09803  ldr       r0,[sp,#12]
.  1284  0000027C0      06800  ldr       r0,[r0]
.  1286  0000027C2      09902  ldr       r1,[sp,#8]
.  1288  0000027C4      04288  cmp       r0,r1
.  1290  0000027C6      0D301  bcc.n     2 -> 1296
.  1292  0000027C8      0DF01  svc       1
.  1294  0000027CA      000BB  <LineNo: 187>
.  1296  0000027CC      09901  ldr       r1,[sp,#4]
.  1298  0000027CE  0EB100001  adds.w    r0,r0,r1
.  1302  0000027D2      07800  ldrb      r0,[r0]
.  1304  0000027D4  0F88D0000  strb.w    r0,[sp]
    neg := ch = "-";
.  1308  0000027D8  0F89D0000  ldrb.w    r0,[sp]
.  1312  0000027DC      0282D  cmp       r0,#45
.  1314  0000027DE      0BF0C  ite       eq
.  1316  0000027E0  0F04F0001  moveq.w   r0,#1
.  1320  0000027E4  0F04F0000  movne.w   r0,#0
.  1324  0000027E8      09904  ldr       r1,[sp,#16]
.  1326  0000027EA      07008  strb      r0,[r1]
    IF (ch = "-") OR (ch = "+") THEN INC(first) END;
.  1328  0000027EC  0F89D0000  ldrb.w    r0,[sp]
.  1332  0000027F0      0282D  cmp       r0,#45
.  1334  0000027F2  0F0008005  beq.w     10 -> 1348
.  1338  0000027F6  0F89D0000  ldrb.w    r0,[sp]
.  1342  0000027FA      0282B  cmp       r0,#43
.  1344  0000027FC  0F0408004  bne.w     8 -> 1356
.  1348  000002800      09803  ldr       r0,[sp,#12]
.  1350  000002802      06801  ldr       r1,[r0]
.  1352  000002804      03101  adds      r1,#1
.  1354  000002806      06001  str       r1,[r0]
    WHILE str[first] = " " DO INC(first) END;
.  1356  000002808      09803  ldr       r0,[sp,#12]
.  1358  00000280A      06800  ldr       r0,[r0]
.  1360  00000280C      09902  ldr       r1,[sp,#8]
.  1362  00000280E      04288  cmp       r0,r1
.  1364  000002810      0D301  bcc.n     2 -> 1370
.  1366  000002812      0DF01  svc       1
.  1368  000002814      000BE  <LineNo: 190>
.  1370  000002816      09901  ldr       r1,[sp,#4]
.  1372  000002818  0EB100001  adds.w    r0,r0,r1
.  1376  00000281C      07800  ldrb      r0,[r0]
.  1378  00000281E      02820  cmp       r0,#32
.  1380  000002820  0F0408006  bne.w     12 -> 1396
.  1384  000002824      09803  ldr       r0,[sp,#12]
.  1386  000002826      06801  ldr       r1,[r0]
.  1388  000002828      03101  adds      r1,#1
.  1390  00000282A      06001  str       r1,[r0]
.  1392  00000282C  0F7FFBFEC  b.w       -40 -> 1356
    WHILE str[first] = "0" DO INC(first) END;
.  1396  000002830      09803  ldr       r0,[sp,#12]
.  1398  000002832      06800  ldr       r0,[r0]
.  1400  000002834      09902  ldr       r1,[sp,#8]
.  1402  000002836      04288  cmp       r0,r1
.  1404  000002838      0D301  bcc.n     2 -> 1410
.  1406  00000283A      0DF01  svc       1
.  1408  00000283C      000BF  <LineNo: 191>
.  1410  00000283E      09901  ldr       r1,[sp,#4]
.  1412  000002840  0EB100001  adds.w    r0,r0,r1
.  1416  000002844      07800  ldrb      r0,[r0]
.  1418  000002846      02830  cmp       r0,#48
.  1420  000002848  0F0408006  bne.w     12 -> 1436
.  1424  00000284C      09803  ldr       r0,[sp,#12]
.  1426  00000284E      06801  ldr       r1,[r0]
.  1428  000002850      03101  adds      r1,#1
.  1430  000002852      06001  str       r1,[r0]
.  1432  000002854  0F7FFBFEC  b.w       -40 -> 1396
  END cleanLeft;
.  1436  000002858      0B005  add       sp,#20
.  1438  00000285A      0BD00  pop       { pc }

  PROCEDURE cleanRight(str: ARRAY OF CHAR; numCh: INTEGER; VAR last: INTEGER);
  BEGIN
.  1440  00000285C      0B50F  push      { r0, r1, r2, r3, lr }
    last := numCh - 1;
.  1442  00000285E      09802  ldr       r0,[sp,#8]
.  1444  000002860      03801  subs      r0,#1
.  1446  000002862      09903  ldr       r1,[sp,#12]
.  1448  000002864      06008  str       r0,[r1]
    WHILE str[last] = " " DO
.  1450  000002866      09803  ldr       r0,[sp,#12]
.  1452  000002868      06800  ldr       r0,[r0]
.  1454  00000286A      09901  ldr       r1,[sp,#4]
.  1456  00000286C      04288  cmp       r0,r1
.  1458  00000286E      0D301  bcc.n     2 -> 1464
.  1460  000002870      0DF01  svc       1
.  1462  000002872      000C5  <LineNo: 197>
.  1464  000002874      09900  ldr       r1,[sp]
.  1466  000002876  0EB100001  adds.w    r0,r0,r1
.  1470  00000287A      07800  ldrb      r0,[r0]
.  1472  00000287C      02820  cmp       r0,#32
.  1474  00000287E  0F0408006  bne.w     12 -> 1490
      DEC(last)
    END
.  1478  000002882      09803  ldr       r0,[sp,#12]
.  1480  000002884      06801  ldr       r1,[r0]
.  1482  000002886      03901  subs      r1,#1
.  1484  000002888      06001  str       r1,[r0]
.  1486  00000288A  0F7FFBFEC  b.w       -40 -> 1450
  END cleanRight;
.  1490  00000288E      0B004  add       sp,#16
.  1492  000002890      0BD00  pop       { pc }
.  1494  000002892      0BF00  nop       


  PROCEDURE StrToInt*(str: ARRAY OF CHAR; numCh: INTEGER; VAR int: INTEGER; VAR res: INTEGER);
  (* rolls over at 0100000000H = 2^32 *)
    VAR first, last, digit: INTEGER; neg: BOOLEAN; ch: CHAR;
  BEGIN
.  1496  000002894      0B51F  push      { r0, r1, r2, r3, r4, lr }
.  1498  000002896      0B084  sub       sp,#16
    res := NoError;
.  1500  000002898      02000  movs      r0,#0
.  1502  00000289A      09908  ldr       r1,[sp,#32]
.  1504  00000289C      06008  str       r0,[r1]
    cleanLeft(str, first, neg);
.  1506  00000289E      09804  ldr       r0,[sp,#16]
.  1508  0000028A0      09905  ldr       r1,[sp,#20]
.  1510  0000028A2      0466A  mov       r2,sp
.  1512  0000028A4  0F11D030C  adds.w    r3,sp,#12
.  1516  0000028A8  0F7FFFF70  bl.w      -288 -> 1232
.  1520  0000028AC      0E000  b         0 -> 1524
.  1522  0000028AE      000D0  <LineNo: 208>
    IF numCh - first > MaxIntDigits THEN
.  1524  0000028B0      09806  ldr       r0,[sp,#24]
.  1526  0000028B2      09900  ldr       r1,[sp]
.  1528  0000028B4  0EBA00001  sub.w     r0,r0,r1
.  1532  0000028B8      0280A  cmp       r0,#10
.  1534  0000028BA  0F3408003  ble.w     6 -> 1544
      res := OutOfLimits;
.  1538  0000028BE      02003  movs      r0,#3
.  1540  0000028C0      09908  ldr       r1,[sp,#32]
.  1542  0000028C2      06008  str       r0,[r1]
    END;
    IF res = NoError THEN
.  1544  0000028C4      09808  ldr       r0,[sp,#32]
.  1546  0000028C6      06800  ldr       r0,[r0]
.  1548  0000028C8      02800  cmp       r0,#0
.  1550  0000028CA  0F0408060  bne.w     192 -> 1746
      cleanRight(str, numCh, last);
.  1554  0000028CE      09804  ldr       r0,[sp,#16]
.  1556  0000028D0      09905  ldr       r1,[sp,#20]
.  1558  0000028D2      09A06  ldr       r2,[sp,#24]
.  1560  0000028D4  0F11D0304  adds.w    r3,sp,#4
.  1564  0000028D8  0F7FFFFC0  bl.w      -128 -> 1440
.  1568  0000028DC      0E000  b         0 -> 1572
.  1570  0000028DE      000D5  <LineNo: 213>
      int := 0;
.  1572  0000028E0      02000  movs      r0,#0
.  1574  0000028E2      09907  ldr       r1,[sp,#28]
.  1576  0000028E4      06008  str       r0,[r1]
      WHILE (first <= last) & (res = NoError) DO
.  1578  0000028E6      09800  ldr       r0,[sp]
.  1580  0000028E8      09901  ldr       r1,[sp,#4]
.  1582  0000028EA      04288  cmp       r0,r1
.  1584  0000028EC  0F300804F  bgt.w     158 -> 1746
.  1588  0000028F0      09808  ldr       r0,[sp,#32]
.  1590  0000028F2      06800  ldr       r0,[r0]
.  1592  0000028F4      02800  cmp       r0,#0
.  1594  0000028F6  0F040804A  bne.w     148 -> 1746
        ch := str[first];
.  1598  0000028FA      09800  ldr       r0,[sp]
.  1600  0000028FC      09905  ldr       r1,[sp,#20]
.  1602  0000028FE      04288  cmp       r0,r1
.  1604  000002900      0D301  bcc.n     2 -> 1610
.  1606  000002902      0DF01  svc       1
.  1608  000002904      000D8  <LineNo: 216>
.  1610  000002906      09904  ldr       r1,[sp,#16]
.  1612  000002908  0EB100001  adds.w    r0,r0,r1
.  1616  00000290C      07800  ldrb      r0,[r0]
.  1618  00000290E  0F88D000D  strb.w    r0,[sp,#13]
        IF (ch < "0") OR (ch > "9") THEN
.  1622  000002912  0F89D000D  ldrb.w    r0,[sp,#13]
.  1626  000002916      02830  cmp       r0,#48
.  1628  000002918  0F2C08005  blt.w     10 -> 1642
.  1632  00000291C  0F89D000D  ldrb.w    r0,[sp,#13]
.  1636  000002920      02839  cmp       r0,#57
.  1638  000002922  0F3408005  ble.w     10 -> 1652
          res := SyntaxError;
.  1642  000002926      02002  movs      r0,#2
.  1644  000002928      09908  ldr       r1,[sp,#32]
.  1646  00000292A      06008  str       r0,[r1]
        ELSE
          digit := ORD(ch) - ORD("0");
.  1648  00000292C  0F000B82D  b.w       90 -> 1742
.  1652  000002930  0F89D000D  ldrb.w    r0,[sp,#13]
.  1656  000002934      03830  subs      r0,#48
.  1658  000002936      09002  str       r0,[sp,#8]
          int := (int * 10) + digit;
.  1660  000002938      09807  ldr       r0,[sp,#28]
.  1662  00000293A      06800  ldr       r0,[r0]
.  1664  00000293C      0210A  movs      r1,#10
.  1666  00000293E  0FB00F001  mul.w     r0,r0,r1
.  1670  000002942      09902  ldr       r1,[sp,#8]
.  1672  000002944      04408  add       r0,r1
.  1674  000002946      09907  ldr       r1,[sp,#28]
.  1676  000002948      06008  str       r0,[r1]
          IF MaxInt - int < 0 THEN  (* works across overflow *)
.  1678  00000294A      09807  ldr       r0,[sp,#28]
.  1680  00000294C      06800  ldr       r0,[r0]
.  1682  00000294E  0F8DF1064  ldr.w     r1,[pc,#100] -> 1784
.  1686  000002952  0EBC00001  rsb.w     r0,r0,r1
.  1690  000002956      02800  cmp       r0,#0
.  1692  000002958  0F2808014  bge.w     40 -> 1736
            IF neg & (int = MinInt) THEN
.  1696  00000295C  0F89D000C  ldrb.w    r0,[sp,#12]
.  1700  000002960  0F0100F01  tst.w     r0,#1
.  1704  000002964  0F000800B  beq.w     22 -> 1730
.  1708  000002968      09807  ldr       r0,[sp,#28]
.  1710  00000296A      06800  ldr       r0,[r0]
.  1712  00000296C  0F1104F00  cmn.w     r0,#080000000H
.  1716  000002970  0F0408005  bne.w     10 -> 1730
              neg := FALSE
            ELSE
.  1720  000002974      02000  movs      r0,#0
.  1722  000002976  0F88D000C  strb.w    r0,[sp,#12]
              res := OutOfLimits
.  1726  00000297A  0F000B803  b.w       6 -> 1736
            END
.  1730  00000297E      02003  movs      r0,#3
.  1732  000002980      09908  ldr       r1,[sp,#32]
.  1734  000002982      06008  str       r0,[r1]
          END;
          INC(first)
        END
.  1736  000002984      09800  ldr       r0,[sp]
.  1738  000002986      03001  adds      r0,#1
.  1740  000002988      09000  str       r0,[sp]
      END
.  1742  00000298A  0F7FFBFAC  b.w       -168 -> 1578
    END;
    IF res = NoError THEN
.  1746  00000298E      09808  ldr       r0,[sp,#32]
.  1748  000002990      06800  ldr       r0,[r0]
.  1750  000002992      02800  cmp       r0,#0
.  1752  000002994  0F040800C  bne.w     24 -> 1780
      IF neg THEN int := -int END
.  1756  000002998  0F89D000C  ldrb.w    r0,[sp,#12]
.  1760  00000299C  0F0100F01  tst.w     r0,#1
.  1764  0000029A0  0F0008006  beq.w     12 -> 1780
.  1768  0000029A4      09807  ldr       r0,[sp,#28]
.  1770  0000029A6      06800  ldr       r0,[r0]
.  1772  0000029A8  0F1D00000  rsbs.w    r0,r0,#0
.  1776  0000029AC      09907  ldr       r1,[sp,#28]
.  1778  0000029AE      06008  str       r0,[r1]
    END
  END StrToInt;
.  1780  0000029B0      0B009  add       sp,#36
.  1782  0000029B2      0BD00  pop       { pc }
.  1784  0000029B4  07FFFFFFF  <Const:  2147483647>

  (* read *)

  PROCEDURE ReadString*(R: TextIO.Reader; VAR s: ARRAY OF CHAR; VAR res: INTEGER);
  (**
    Read a string via 'R', terminated by 'TextIO.EOL'.
    Flush the rest of the input in case of buffer overflow.
    The string is truncated to the buffer length, terminated by 0X.
  **)
    VAR numCh: INTEGER;
  BEGIN
.  1788  0000029B8      0B50F  push      { r0, r1, r2, r3, lr }
.  1790  0000029BA      0B081  sub       sp,#4
    R.getString(R.dev, s, numCh, res);
.  1792  0000029BC      09801  ldr       r0,[sp,#4]
.  1794  0000029BE      06800  ldr       r0,[r0]
.  1796  0000029C0      09902  ldr       r1,[sp,#8]
.  1798  0000029C2      09A03  ldr       r2,[sp,#12]
.  1800  0000029C4      0466B  mov       r3,sp
.  1802  0000029C6      09C04  ldr       r4,[sp,#16]
.  1804  0000029C8      09D01  ldr       r5,[sp,#4]
.  1806  0000029CA      0686D  ldr       r5,[r5,#4]
.  1808  0000029CC  0F1B50F00  cmp.w     r5,#0
.  1812  0000029D0      0D101  bne.n     2 -> 1818
.  1814  0000029D2      0DF05  svc       5
.  1816  0000029D4      000F8  <LineNo: 248>
.  1818  0000029D6      03501  adds      r5,#1
.  1820  0000029D8      047A8  blx       r5
.  1822  0000029DA      0E000  b         0 -> 1826
.  1824  0000029DC      000F8  <LineNo: 248>
    IF res = NoError THEN
.  1826  0000029DE      09804  ldr       r0,[sp,#16]
.  1828  0000029E0      06800  ldr       r0,[r0]
.  1830  0000029E2      02800  cmp       r0,#0
.  1832  0000029E4  0F0408007  bne.w     14 -> 1850
      IF numCh = 0 THEN
.  1836  0000029E8      09800  ldr       r0,[sp]
.  1838  0000029EA      02800  cmp       r0,#0
.  1840  0000029EC  0F0408003  bne.w     6 -> 1850
        res := NoInput
      END
.  1844  0000029F0      02004  movs      r0,#4
.  1846  0000029F2      09904  ldr       r1,[sp,#16]
.  1848  0000029F4      06008  str       r0,[r1]
    END
  END ReadString;
.  1850  0000029F6      0B005  add       sp,#20
.  1852  0000029F8      0BD00  pop       { pc }
.  1854  0000029FA      0BF00  nop       


  PROCEDURE ReadInt*(R: TextIO.Reader; VAR int, res: INTEGER);
  (**
    Read an integer in decimal form via 'R', terminated by 'TextIO.EOL'.
    Flush the rest of the input in case of buffer overflow.
    The number is not valid in case of any error.
    As long as there's no buffer overflow or fifo overrrun, any number of leading
    blanks, blanks after the sign, leading zeros, and trailing blanks are permitted.
  **)
    VAR numCh: INTEGER; buf: ARRAY 32 OF CHAR;
  BEGIN
.  1856  0000029FC      0B507  push      { r0, r1, r2, lr }
.  1858  0000029FE      0B089  sub       sp,#36
    R.getString(R.dev, buf, numCh, res);
.  1860  000002A00      09809  ldr       r0,[sp,#36]
.  1862  000002A02      06800  ldr       r0,[r0]
.  1864  000002A04  0F11D0104  adds.w    r1,sp,#4
.  1868  000002A08      02220  movs      r2,#32
.  1870  000002A0A      0466B  mov       r3,sp
.  1872  000002A0C      09C0B  ldr       r4,[sp,#44]
.  1874  000002A0E      09D09  ldr       r5,[sp,#36]
.  1876  000002A10      0686D  ldr       r5,[r5,#4]
.  1878  000002A12  0F1B50F00  cmp.w     r5,#0
.  1882  000002A16      0D101  bne.n     2 -> 1888
.  1884  000002A18      0DF05  svc       5
.  1886  000002A1A      0010B  <LineNo: 267>
.  1888  000002A1C      03501  adds      r5,#1
.  1890  000002A1E      047A8  blx       r5
.  1892  000002A20      0E000  b         0 -> 1896
.  1894  000002A22      0010B  <LineNo: 267>
    IF res = NoError THEN
.  1896  000002A24      0980B  ldr       r0,[sp,#44]
.  1898  000002A26      06800  ldr       r0,[r0]
.  1900  000002A28      02800  cmp       r0,#0
.  1902  000002A2A  0F0408013  bne.w     38 -> 1944
      IF numCh > 0 THEN
.  1906  000002A2E      09800  ldr       r0,[sp]
.  1908  000002A30      02800  cmp       r0,#0
.  1910  000002A32  0F340800C  ble.w     24 -> 1938
        StrToInt(buf, numCh, int, res)
.  1914  000002A36  0F11D0004  adds.w    r0,sp,#4
.  1918  000002A3A      02120  movs      r1,#32
.  1920  000002A3C      09A00  ldr       r2,[sp]
.  1922  000002A3E      09B0A  ldr       r3,[sp,#40]
.  1924  000002A40      09C0B  ldr       r4,[sp,#44]
      ELSE
.  1926  000002A42  0F7FFFF27  bl.w      -434 -> 1496
.  1930  000002A46      0E000  b         0 -> 1934
.  1932  000002A48      0010E  <LineNo: 270>
        res := NoInput
.  1934  000002A4A  0F000B803  b.w       6 -> 1944
      END
.  1938  000002A4E      02004  movs      r0,#4
.  1940  000002A50      0990B  ldr       r1,[sp,#44]
.  1942  000002A52      06008  str       r0,[r1]
    END
  END ReadInt;
.  1944  000002A54      0B00C  add       sp,#48
.  1946  000002A56      0BD00  pop       { pc }


  PROCEDURE FlushOut*(W: TextIO.Writer);
  (**
    Allow flushing on writers that don't need it to keep
    program code independent of output channel if needed.
  **)
  BEGIN
.  1948  000002A58      0B501  push      { r0, lr }
    IF W.flush # NIL THEN
.  1950  000002A5A      09800  ldr       r0,[sp]
.  1952  000002A5C      06880  ldr       r0,[r0,#8]
.  1954  000002A5E      02800  cmp       r0,#0
.  1956  000002A60  0F000800D  beq.w     26 -> 1986
      W.flush(W.dev)
.  1960  000002A64      09800  ldr       r0,[sp]
.  1962  000002A66      06800  ldr       r0,[r0]
    END
.  1964  000002A68      09900  ldr       r1,[sp]
.  1966  000002A6A      06889  ldr       r1,[r1,#8]
.  1968  000002A6C  0F1B10F00  cmp.w     r1,#0
.  1972  000002A70      0D101  bne.n     2 -> 1978
.  1974  000002A72      0DF05  svc       5
.  1976  000002A74      0011D  <LineNo: 285>
.  1978  000002A76      03101  adds      r1,#1
.  1980  000002A78      04788  blx       r1
.  1982  000002A7A      0E000  b         0 -> 1986
.  1984  000002A7C      0011D  <LineNo: 285>
  END FlushOut;
.  1986  000002A7E      0B001  add       sp,#4
.  1988  000002A80      0BD00  pop       { pc }
.  1990  000002A82      0BF00  nop       

BEGIN
.  1992  000002A84      0B500  push      { lr }
  eol[0] := CR; eol[1] := LF
.  1994  000002A86  0F8DF0010  ldr.w     r0,[pc,#16] -> 2012
.  1998  000002A8A      0210D  movs      r1,#13
.  2000  000002A8C      07001  strb      r1,[r0]
.  2002  000002A8E  0F8DF0008  ldr.w     r0,[pc,#8] -> 2012
END Texts.
.  2006  000002A92      0210A  movs      r1,#10
.  2008  000002A94      07041  strb      r1,[r0,#1]
.  2010  000002A96      0BD00  pop       { pc }
.  2012  000002A98  020027ED8  <Global: Texts data>
 