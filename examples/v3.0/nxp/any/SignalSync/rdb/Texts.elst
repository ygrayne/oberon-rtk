. <tool: Astrobe for RP2350>
. <prog: C:\Users\gray\Projects\oberon\dev\oberon-rtk\examples\v3.0\nxp\any\SignalSync\SignalSync.mod>

.     0  01000252C              <Pad: 0>
MODULE Texts;
(**
  Oberon RTK Framework
  Version: v3.0
  --
  Formatted output to a "channel", using a 'TextIO.Writer'
  Formatted input from a "channel", using a 'TextIO.Reader'
  --
  The behaviour of the procedures depends on the write string and read
  procedures allocated to 'W' and 'R' parameters:
  * blocking
  * non-blocking (using the kernel)
  --
  Copyright (c) 2020-2025 Gray gray@grayraven.org
  https://oberon-rtk.org/licences/
**)

  IMPORT TextIO, Errors;

  CONST
    CR = 0DX;
    LF = 0AX;
    Blanks = "                                "; (* 32 blanks *)
.     4  010002530  020202020  <String: "    ">
.     8  010002534  020202020  <String: "    ">
.    12  010002538  020202020  <String: "    ">
.    16  01000253C  020202020  <String: "    ">
.    20  010002540  020202020  <String: "    ">
.    24  010002544  020202020  <String: "    ">
.    28  010002548  020202020  <String: "    ">
.    32  01000254C  020202020  <String: "    ">
.    36  010002550  000000000  <String: "....">
    MaxBlanks = 32;

    (* conversion constants *)
    MaxInt* = 07FFFFFFFH; (*  2,147,483,647 *)
    MinInt* = 080000000H; (* -2,147,483,648 *)
    MaxIntDigits* = 10;   (* sans sign, sans leading zeros *)

    (* read results *)
    NoError* = TextIO.NoError;
    BufferOverflow* = TextIO.BufferOverflow; (* a tool small buffer was provided or used *)
    SyntaxError* = TextIO.SyntaxError;      (* zero length or non-numerical chars *)
    OutOfLimits* = TextIO.OutOfLimits;    (* bigger than MaxInt, smaller than MinInt *)
    NoInput* = TextIO.NoInput;
    FifoOverrun* = TextIO.FifoOverrun;

  VAR eol: ARRAY 2 OF CHAR;

  (* write conversions *)

  PROCEDURE IntToString*(int: INTEGER; VAR str: ARRAY OF CHAR; VAR slen: INTEGER);
    VAR spos, dpos: INTEGER; digits: ARRAY 10 OF CHAR;
  BEGIN
.    40  010002554      0B50F  push      { r0, r1, r2, r3, lr }
.    42  010002556      0B085  sub       sp,#20
    ASSERT(LEN(str) >= 12, Errors.PreCond); (* 10 digits, minus sign, 0X *)
.    44  010002558      09807  ldr       r0,[sp,#28]
.    46  01000255A      0280C  cmp       r0,#12
.    48  01000255C      0DA01  bge.n     2 -> 54
.    50  01000255E      0DF22  svc       34
.    52  010002560      0002E  <LineNo: 46>
    IF int = 080000000H THEN
.    54  010002562      09805  ldr       r0,[sp,#20]
.    56  010002564  0F1104F00  cmn.w     r0,#080000000H
.    60  010002568  0F0408027  bne.w     78 -> 142
      str := "-2147483648";
.    64  01000256C      0200C  movs      r0,#12
.    66  01000256E      09907  ldr       r1,[sp,#28]
.    68  010002570      04281  cmp       r1,r0
.    70  010002572      0DA01  bge.n     2 -> 76
.    72  010002574      0DF06  svc       6
.    74  010002576      00030  <LineNo: 48>
.    76  010002578      09806  ldr       r0,[sp,#24]
.    78  01000257A      0BF00  nop       
.    80  01000257C      0A100  adr       r1,pc,#0 -> 84
.    82  01000257E      0E005  b         10 -> 96
.    84  010002580  03431322D  <String: "-214">
.    88  010002584  033383437  <String: "7483">
.    92  010002588  000383436  <String: "648.">
.    96  01000258C  0F8512B04  ldr.w     r2,[r1],#4
.   100  010002590  0F8402B04  str.w     r2,[r0],#4
.   104  010002594  0F012427F  ands.w    r2,r2,#0FF000000H
.   108  010002598      0D1F8  bne.n     -16 -> 96
      str[11] := 0X;
.   110  01000259A      0200B  movs      r0,#11
.   112  01000259C      09907  ldr       r1,[sp,#28]
.   114  01000259E      04288  cmp       r0,r1
.   116  0100025A0      0D301  bcc.n     2 -> 122
.   118  0100025A2      0DF01  svc       1
.   120  0100025A4      00031  <LineNo: 49>
.   122  0100025A6      09906  ldr       r1,[sp,#24]
.   124  0100025A8  0EB100001  adds.w    r0,r0,r1
.   128  0100025AC      02100  movs      r1,#0
.   130  0100025AE      07001  strb      r1,[r0]
      slen := 11
    ELSE
.   132  0100025B0      0200B  movs      r0,#11
.   134  0100025B2      09908  ldr       r1,[sp,#32]
.   136  0100025B4      06008  str       r0,[r1]
      spos := 0;
.   138  0100025B6  0F000B86D  b.w       218 -> 360
.   142  0100025BA      02000  movs      r0,#0
.   144  0100025BC      09000  str       r0,[sp]
      IF int < 0 THEN
.   146  0100025BE      09805  ldr       r0,[sp,#20]
.   148  0100025C0      02800  cmp       r0,#0
.   150  0100025C2  0F2808012  bge.w     36 -> 190
        int := -int;
.   154  0100025C6      09805  ldr       r0,[sp,#20]
.   156  0100025C8  0F1D00000  rsbs.w    r0,r0,#0
.   160  0100025CC      09005  str       r0,[sp,#20]
        str[spos] := "-";
.   162  0100025CE      09800  ldr       r0,[sp]
.   164  0100025D0      09907  ldr       r1,[sp,#28]
.   166  0100025D2      04288  cmp       r0,r1
.   168  0100025D4      0D301  bcc.n     2 -> 174
.   170  0100025D6      0DF01  svc       1
.   172  0100025D8      00037  <LineNo: 55>
.   174  0100025DA      09906  ldr       r1,[sp,#24]
.   176  0100025DC  0EB100001  adds.w    r0,r0,r1
.   180  0100025E0      0212D  movs      r1,#45
.   182  0100025E2      07001  strb      r1,[r0]
        INC(spos)
      END;
.   184  0100025E4      09800  ldr       r0,[sp]
.   186  0100025E6      03001  adds      r0,#1
.   188  0100025E8      09000  str       r0,[sp]
      dpos := 0;
.   190  0100025EA      02000  movs      r0,#0
.   192  0100025EC      09001  str       r0,[sp,#4]
      REPEAT
        digits[dpos] := CHR(int MOD 10 + ORD("0"));
.   194  0100025EE      09801  ldr       r0,[sp,#4]
.   196  0100025F0      0280A  cmp       r0,#10
.   198  0100025F2      0D301  bcc.n     2 -> 204
.   200  0100025F4      0DF01  svc       1
.   202  0100025F6      0003C  <LineNo: 60>
.   204  0100025F8  0EB1D0000  adds.w    r0,sp,r0
.   208  0100025FC      09905  ldr       r1,[sp,#20]
.   210  0100025FE      0220A  movs      r2,#10
.   212  010002600  0FB91F3F2  sdiv.w    r3,r1,r2
.   216  010002604  0FB031112  mls.w     r1,r3,r2,r1
.   220  010002608  0F1B10F00  cmp.w     r1,#0
.   224  01000260C      0BF48  it        mi
.   226  01000260E  0EB010102  addmi.w   r1,r1,r2
.   230  010002612      03130  adds      r1,#48
.   232  010002614      07201  strb      r1,[r0,#8]
        int := int DIV 10;
.   234  010002616      09805  ldr       r0,[sp,#20]
.   236  010002618      0210A  movs      r1,#10
.   238  01000261A  0FB90F2F1  sdiv.w    r2,r0,r1
.   242  01000261E  0FB020011  mls.w     r0,r2,r1,r0
.   246  010002622  0EBA270D0  sub.w     r0,r2,r0,lsr 31
.   250  010002626      09005  str       r0,[sp,#20]
        INC(dpos)
      UNTIL int = 0;
.   252  010002628      09801  ldr       r0,[sp,#4]
.   254  01000262A      03001  adds      r0,#1
.   256  01000262C      09001  str       r0,[sp,#4]
.   258  01000262E      09805  ldr       r0,[sp,#20]
.   260  010002630      02800  cmp       r0,#0
.   262  010002632  0F47FAFDC  bne.w     -72 -> 194
      DEC(dpos);
.   266  010002636      09801  ldr       r0,[sp,#4]
.   268  010002638      03801  subs      r0,#1
.   270  01000263A      09001  str       r0,[sp,#4]
      WHILE dpos >= 0 DO
.   272  01000263C      09801  ldr       r0,[sp,#4]
.   274  01000263E      02800  cmp       r0,#0
.   276  010002640  0F2C0801A  blt.w     52 -> 332
        str[spos] := digits[dpos];
.   280  010002644      09800  ldr       r0,[sp]
.   282  010002646      09907  ldr       r1,[sp,#28]
.   284  010002648      04288  cmp       r0,r1
.   286  01000264A      0D301  bcc.n     2 -> 292
.   288  01000264C      0DF01  svc       1
.   290  01000264E      00042  <LineNo: 66>
.   292  010002650      09906  ldr       r1,[sp,#24]
.   294  010002652  0EB100001  adds.w    r0,r0,r1
.   298  010002656      09901  ldr       r1,[sp,#4]
.   300  010002658      0290A  cmp       r1,#10
.   302  01000265A      0D301  bcc.n     2 -> 308
.   304  01000265C      0DF01  svc       1
.   306  01000265E      00042  <LineNo: 66>
.   308  010002660  0EB1D0101  adds.w    r1,sp,r1
.   312  010002664      07A09  ldrb      r1,[r1,#8]
.   314  010002666      07001  strb      r1,[r0]
        DEC(dpos); INC(spos)
.   316  010002668      09801  ldr       r0,[sp,#4]
.   318  01000266A      03801  subs      r0,#1
.   320  01000266C      09001  str       r0,[sp,#4]
      END;
.   322  01000266E      09800  ldr       r0,[sp]
.   324  010002670      03001  adds      r0,#1
.   326  010002672      09000  str       r0,[sp]
.   328  010002674  0F7FFBFE2  b.w       -60 -> 272
      str[spos] := 0X;
.   332  010002678      09800  ldr       r0,[sp]
.   334  01000267A      09907  ldr       r1,[sp,#28]
.   336  01000267C      04288  cmp       r0,r1
.   338  01000267E      0D301  bcc.n     2 -> 344
.   340  010002680      0DF01  svc       1
.   342  010002682      00045  <LineNo: 69>
.   344  010002684      09906  ldr       r1,[sp,#24]
.   346  010002686  0EB100001  adds.w    r0,r0,r1
.   350  01000268A      02100  movs      r1,#0
.   352  01000268C      07001  strb      r1,[r0]
      slen := spos
    END
.   354  01000268E      09800  ldr       r0,[sp]
.   356  010002690      09908  ldr       r1,[sp,#32]
.   358  010002692      06008  str       r0,[r1]
  END IntToString;
.   360  010002694      0B009  add       sp,#36
.   362  010002696      0BD00  pop       { pc }


  PROCEDURE IntToHexString*(int: INTEGER; VAR str: ARRAY OF CHAR; VAR slen: INTEGER);
    VAR dpos, spos, d: INTEGER; digits: ARRAY 10 OF CHAR;
  BEGIN
.   364  010002698      0B50F  push      { r0, r1, r2, r3, lr }
.   366  01000269A      0B086  sub       sp,#24
    ASSERT(LEN(str) >= 10, Errors.PreCond);
.   368  01000269C      09808  ldr       r0,[sp,#32]
.   370  01000269E      0280A  cmp       r0,#10
.   372  0100026A0      0DA01  bge.n     2 -> 378
.   374  0100026A2      0DF22  svc       34
.   376  0100026A4      0004E  <LineNo: 78>
    dpos := 0;
.   378  0100026A6      02000  movs      r0,#0
.   380  0100026A8      09000  str       r0,[sp]
    REPEAT
      d := int MOD 010H;
.   382  0100026AA      09806  ldr       r0,[sp,#24]
.   384  0100026AC  0F000000F  and.w     r0,r0,#15
.   388  0100026B0      09002  str       r0,[sp,#8]
      IF d < 10 THEN
.   390  0100026B2      09802  ldr       r0,[sp,#8]
.   392  0100026B4      0280A  cmp       r0,#10
.   394  0100026B6  0F280800C  bge.w     24 -> 422
        digits[dpos] := CHR(d + ORD("0"))
.   398  0100026BA      09800  ldr       r0,[sp]
.   400  0100026BC      0280A  cmp       r0,#10
.   402  0100026BE      0D301  bcc.n     2 -> 408
.   404  0100026C0      0DF01  svc       1
.   406  0100026C2      00053  <LineNo: 83>
.   408  0100026C4  0EB1D0000  adds.w    r0,sp,r0
.   412  0100026C8      09902  ldr       r1,[sp,#8]
.   414  0100026CA      03130  adds      r1,#48
      ELSE
.   416  0100026CC      07301  strb      r1,[r0,#12]
        digits[dpos] := CHR(d - 10 + ORD("A"))
.   418  0100026CE  0F000B80B  b.w       22 -> 444
.   422  0100026D2      09800  ldr       r0,[sp]
.   424  0100026D4      0280A  cmp       r0,#10
.   426  0100026D6      0D301  bcc.n     2 -> 432
.   428  0100026D8      0DF01  svc       1
.   430  0100026DA      00055  <LineNo: 85>
.   432  0100026DC  0EB1D0000  adds.w    r0,sp,r0
.   436  0100026E0      09902  ldr       r1,[sp,#8]
.   438  0100026E2      0390A  subs      r1,#10
.   440  0100026E4      03141  adds      r1,#65
      END;
.   442  0100026E6      07301  strb      r1,[r0,#12]
      int := int DIV 010H;
.   444  0100026E8      09806  ldr       r0,[sp,#24]
.   446  0100026EA      01100  asrs      r0,r0,#4
.   448  0100026EC      09006  str       r0,[sp,#24]
      INC(dpos)
    UNTIL dpos = 8;
.   450  0100026EE      09800  ldr       r0,[sp]
.   452  0100026F0      03001  adds      r0,#1
.   454  0100026F2      09000  str       r0,[sp]
.   456  0100026F4      09800  ldr       r0,[sp]
.   458  0100026F6      02808  cmp       r0,#8
.   460  0100026F8  0F47FAFD7  bne.w     -82 -> 382
    DEC(dpos); spos := 0;
.   464  0100026FC      09800  ldr       r0,[sp]
.   466  0100026FE      03801  subs      r0,#1
.   468  010002700      09000  str       r0,[sp]
.   470  010002702      02000  movs      r0,#0
.   472  010002704      09001  str       r0,[sp,#4]
    WHILE dpos >= 0 DO
.   474  010002706      09800  ldr       r0,[sp]
.   476  010002708      02800  cmp       r0,#0
.   478  01000270A  0F2C0801A  blt.w     52 -> 534
      str[spos] := digits[dpos];
.   482  01000270E      09801  ldr       r0,[sp,#4]
.   484  010002710      09908  ldr       r1,[sp,#32]
.   486  010002712      04288  cmp       r0,r1
.   488  010002714      0D301  bcc.n     2 -> 494
.   490  010002716      0DF01  svc       1
.   492  010002718      0005C  <LineNo: 92>
.   494  01000271A      09907  ldr       r1,[sp,#28]
.   496  01000271C  0EB100001  adds.w    r0,r0,r1
.   500  010002720      09900  ldr       r1,[sp]
.   502  010002722      0290A  cmp       r1,#10
.   504  010002724      0D301  bcc.n     2 -> 510
.   506  010002726      0DF01  svc       1
.   508  010002728      0005C  <LineNo: 92>
.   510  01000272A  0EB1D0101  adds.w    r1,sp,r1
.   514  01000272E      07B09  ldrb      r1,[r1,#12]
.   516  010002730      07001  strb      r1,[r0]
      DEC(dpos); INC(spos)
.   518  010002732      09800  ldr       r0,[sp]
.   520  010002734      03801  subs      r0,#1
.   522  010002736      09000  str       r0,[sp]
    END;
.   524  010002738      09801  ldr       r0,[sp,#4]
.   526  01000273A      03001  adds      r0,#1
.   528  01000273C      09001  str       r0,[sp,#4]
.   530  01000273E  0F7FFBFE2  b.w       -60 -> 474
    str[8] := "H";
.   534  010002742      02008  movs      r0,#8
.   536  010002744      09908  ldr       r1,[sp,#32]
.   538  010002746      04288  cmp       r0,r1
.   540  010002748      0D301  bcc.n     2 -> 546
.   542  01000274A      0DF01  svc       1
.   544  01000274C      0005F  <LineNo: 95>
.   546  01000274E      09907  ldr       r1,[sp,#28]
.   548  010002750  0EB100001  adds.w    r0,r0,r1
.   552  010002754      02148  movs      r1,#72
.   554  010002756      07001  strb      r1,[r0]
    str[9] := 0X;
.   556  010002758      02009  movs      r0,#9
.   558  01000275A      09908  ldr       r1,[sp,#32]
.   560  01000275C      04288  cmp       r0,r1
.   562  01000275E      0D301  bcc.n     2 -> 568
.   564  010002760      0DF01  svc       1
.   566  010002762      00060  <LineNo: 96>
.   568  010002764      09907  ldr       r1,[sp,#28]
.   570  010002766  0EB100001  adds.w    r0,r0,r1
.   574  01000276A      02100  movs      r1,#0
.   576  01000276C      07001  strb      r1,[r0]
    slen := 9
  END IntToHexString;
.   578  01000276E      02009  movs      r0,#9
.   580  010002770      09909  ldr       r1,[sp,#36]
.   582  010002772      06008  str       r0,[r1]
.   584  010002774      0B00A  add       sp,#40
.   586  010002776      0BD00  pop       { pc }


  PROCEDURE IntToBinString*(int: INTEGER; VAR str: ARRAY OF CHAR; VAR slen: INTEGER);
    VAR
      i, j, k: INTEGER;
      bits: SET;
  BEGIN
.   588  010002778      0B50F  push      { r0, r1, r2, r3, lr }
.   590  01000277A      0B084  sub       sp,#16
    ASSERT(LEN(str) >= 36, Errors.PreCond);
.   592  01000277C      09806  ldr       r0,[sp,#24]
.   594  01000277E      02824  cmp       r0,#36
.   596  010002780      0DA01  bge.n     2 -> 602
.   598  010002782      0DF22  svc       34
.   600  010002784      0006A  <LineNo: 106>
    k := 0;
.   602  010002786      02000  movs      r0,#0
.   604  010002788      09002  str       r0,[sp,#8]
    FOR i := 0 TO 3 DO
.   606  01000278A      02000  movs      r0,#0
.   608  01000278C      09000  str       r0,[sp]
      bits := BITS(BFX(int, 31, 24));
.   610  01000278E      09800  ldr       r0,[sp]
.   612  010002790      02803  cmp       r0,#3
.   614  010002792  0F3008048  bgt.w     144 -> 762
.   618  010002796      09804  ldr       r0,[sp,#16]
.   620  010002798  0F3C06007  ubfx      r0,r0,24,8
.   624  01000279C      09003  str       r0,[sp,#12]
      int := LSL(int, 8);
.   626  01000279E      09804  ldr       r0,[sp,#16]
.   628  0100027A0      00200  lsls      r0,r0,#8
.   630  0100027A2      09004  str       r0,[sp,#16]
      FOR j := 7 TO 0 BY -1 DO
.   632  0100027A4      02007  movs      r0,#7
.   634  0100027A6      09001  str       r0,[sp,#4]
        IF j IN bits THEN str[k] := "1" ELSE str[k] := "0" END;
.   636  0100027A8      09801  ldr       r0,[sp,#4]
.   638  0100027AA      02800  cmp       r0,#0
.   640  0100027AC  0F2C08028  blt.w     80 -> 724
.   644  0100027B0      09803  ldr       r0,[sp,#12]
.   646  0100027B2      09901  ldr       r1,[sp,#4]
.   648  0100027B4      02201  movs      r2,#1
.   650  0100027B6      0408A  lsls      r2,r1
.   652  0100027B8  0EA100F02  tst.w     r0,r2
.   656  0100027BC  0F000800D  beq.w     26 -> 686
.   660  0100027C0      09802  ldr       r0,[sp,#8]
.   662  0100027C2      09906  ldr       r1,[sp,#24]
.   664  0100027C4      04288  cmp       r0,r1
.   666  0100027C6      0D301  bcc.n     2 -> 672
.   668  0100027C8      0DF01  svc       1
.   670  0100027CA      00070  <LineNo: 112>
.   672  0100027CC      09905  ldr       r1,[sp,#20]
.   674  0100027CE  0EB100001  adds.w    r0,r0,r1
.   678  0100027D2      02131  movs      r1,#49
.   680  0100027D4      07001  strb      r1,[r0]
.   682  0100027D6  0F000B80B  b.w       22 -> 708
.   686  0100027DA      09802  ldr       r0,[sp,#8]
.   688  0100027DC      09906  ldr       r1,[sp,#24]
.   690  0100027DE      04288  cmp       r0,r1
.   692  0100027E0      0D301  bcc.n     2 -> 698
.   694  0100027E2      0DF01  svc       1
.   696  0100027E4      00070  <LineNo: 112>
.   698  0100027E6      09905  ldr       r1,[sp,#20]
.   700  0100027E8  0EB100001  adds.w    r0,r0,r1
.   704  0100027EC      02130  movs      r1,#48
.   706  0100027EE      07001  strb      r1,[r0]
        INC(k)
      END;
.   708  0100027F0      09802  ldr       r0,[sp,#8]
.   710  0100027F2      03001  adds      r0,#1
.   712  0100027F4      09002  str       r0,[sp,#8]
.   714  0100027F6      09801  ldr       r0,[sp,#4]
.   716  0100027F8      03801  subs      r0,#1
.   718  0100027FA      09001  str       r0,[sp,#4]
.   720  0100027FC  0F7FFBFD4  b.w       -88 -> 636
      str[k] := " ";
.   724  010002800      09802  ldr       r0,[sp,#8]
.   726  010002802      09906  ldr       r1,[sp,#24]
.   728  010002804      04288  cmp       r0,r1
.   730  010002806      0D301  bcc.n     2 -> 736
.   732  010002808      0DF01  svc       1
.   734  01000280A      00073  <LineNo: 115>
.   736  01000280C      09905  ldr       r1,[sp,#20]
.   738  01000280E  0EB100001  adds.w    r0,r0,r1
.   742  010002812      02120  movs      r1,#32
.   744  010002814      07001  strb      r1,[r0]
      INC(k)
    END;
.   746  010002816      09802  ldr       r0,[sp,#8]
.   748  010002818      03001  adds      r0,#1
.   750  01000281A      09002  str       r0,[sp,#8]
.   752  01000281C      09800  ldr       r0,[sp]
.   754  01000281E      03001  adds      r0,#1
.   756  010002820      09000  str       r0,[sp]
.   758  010002822  0F7FFBFB4  b.w       -152 -> 610
    str[35] := 0X;
.   762  010002826      02023  movs      r0,#35
.   764  010002828      09906  ldr       r1,[sp,#24]
.   766  01000282A      04288  cmp       r0,r1
.   768  01000282C      0D301  bcc.n     2 -> 774
.   770  01000282E      0DF01  svc       1
.   772  010002830      00076  <LineNo: 118>
.   774  010002832      09905  ldr       r1,[sp,#20]
.   776  010002834  0EB100001  adds.w    r0,r0,r1
.   780  010002838      02100  movs      r1,#0
.   782  01000283A      07001  strb      r1,[r0]
    slen := 35
  END IntToBinString;
.   784  01000283C      02023  movs      r0,#35
.   786  01000283E      09907  ldr       r1,[sp,#28]
.   788  010002840      06008  str       r0,[r1]
.   790  010002842      0B008  add       sp,#32
.   792  010002844      0BD00  pop       { pc }
.   794  010002846      0BF00  nop       

  (* write *)

  PROCEDURE Write*(W: TextIO.Writer; ch: CHAR);
    VAR s: ARRAY 1 OF CHAR;
  BEGIN
.   796  010002848      0B503  push      { r0, r1, lr }
.   798  01000284A      0B081  sub       sp,#4
    s[0] := ch;
.   800  01000284C  0F89D0008  ldrb.w    r0,[sp,#8]
.   804  010002850  0F88D0000  strb.w    r0,[sp]
    W.putString(W.dev, s, 1)
.   808  010002854      09801  ldr       r0,[sp,#4]
.   810  010002856      06800  ldr       r0,[r0]
.   812  010002858      04669  mov       r1,sp
.   814  01000285A      02201  movs      r2,#1
.   816  01000285C      02301  movs      r3,#1
  END Write;
.   818  01000285E      09C01  ldr       r4,[sp,#4]
.   820  010002860      06864  ldr       r4,[r4,#4]
.   822  010002862  0F1B40F00  cmp.w     r4,#0
.   826  010002866      0D101  bne.n     2 -> 832
.   828  010002868      0DF05  svc       5
.   830  01000286A      00080  <LineNo: 128>
.   832  01000286C      03401  adds      r4,#1
.   834  01000286E      047A0  blx       r4
.   836  010002870      0E000  b         0 -> 840
.   838  010002872      00080  <LineNo: 128>
.   840  010002874      0B003  add       sp,#12
.   842  010002876      0BD00  pop       { pc }


  PROCEDURE WriteString*(W: TextIO.Writer; str: ARRAY OF CHAR);
    VAR i: INTEGER;
  BEGIN
.   844  010002878      0B507  push      { r0, r1, r2, lr }
.   846  01000287A      0B081  sub       sp,#4
    i := 0;
.   848  01000287C      02000  movs      r0,#0
.   850  01000287E      09000  str       r0,[sp]
    WHILE (i < LEN(str)) & (str[i] # 0X) DO INC(i) END;
.   852  010002880      09800  ldr       r0,[sp]
.   854  010002882      09903  ldr       r1,[sp,#12]
.   856  010002884      04288  cmp       r0,r1
.   858  010002886  0F2808012  bge.w     36 -> 898
.   862  01000288A      09800  ldr       r0,[sp]
.   864  01000288C      09903  ldr       r1,[sp,#12]
.   866  01000288E      04288  cmp       r0,r1
.   868  010002890      0D301  bcc.n     2 -> 874
.   870  010002892      0DF01  svc       1
.   872  010002894      00088  <LineNo: 136>
.   874  010002896      09902  ldr       r1,[sp,#8]
.   876  010002898  0EB100001  adds.w    r0,r0,r1
.   880  01000289C      07800  ldrb      r0,[r0]
.   882  01000289E      02800  cmp       r0,#0
.   884  0100028A0  0F0008005  beq.w     10 -> 898
.   888  0100028A4      09800  ldr       r0,[sp]
.   890  0100028A6      03001  adds      r0,#1
.   892  0100028A8      09000  str       r0,[sp]
.   894  0100028AA  0F7FFBFE9  b.w       -46 -> 852
    W.putString(W.dev, str, i)
.   898  0100028AE      09801  ldr       r0,[sp,#4]
.   900  0100028B0      06800  ldr       r0,[r0]
.   902  0100028B2      09902  ldr       r1,[sp,#8]
.   904  0100028B4      09A03  ldr       r2,[sp,#12]
.   906  0100028B6      09B00  ldr       r3,[sp]
  END WriteString;
.   908  0100028B8      09C01  ldr       r4,[sp,#4]
.   910  0100028BA      06864  ldr       r4,[r4,#4]
.   912  0100028BC  0F1B40F00  cmp.w     r4,#0
.   916  0100028C0      0D101  bne.n     2 -> 922
.   918  0100028C2      0DF05  svc       5
.   920  0100028C4      00089  <LineNo: 137>
.   922  0100028C6      03401  adds      r4,#1
.   924  0100028C8      047A0  blx       r4
.   926  0100028CA      0E000  b         0 -> 930
.   928  0100028CC      00089  <LineNo: 137>
.   930  0100028CE      0B004  add       sp,#16
.   932  0100028D0      0BD00  pop       { pc }
.   934  0100028D2      0BF00  nop       


  PROCEDURE WriteLn*(W: TextIO.Writer);
  BEGIN
.   936  0100028D4      0B501  push      { r0, lr }
    W.putString(W.dev, eol, 2)
.   938  0100028D6      09800  ldr       r0,[sp]
.   940  0100028D8      06800  ldr       r0,[r0]
.   942  0100028DA  0F8DF1020  ldr.w     r1,[pc,#32] -> 976
.   946  0100028DE      02202  movs      r2,#2
.   948  0100028E0      02302  movs      r3,#2
  END WriteLn;
.   950  0100028E2      09C00  ldr       r4,[sp]
.   952  0100028E4      06864  ldr       r4,[r4,#4]
.   954  0100028E6  0F1B40F00  cmp.w     r4,#0
.   958  0100028EA      0D101  bne.n     2 -> 964
.   960  0100028EC      0DF05  svc       5
.   962  0100028EE      0008F  <LineNo: 143>
.   964  0100028F0      03401  adds      r4,#1
.   966  0100028F2      047A0  blx       r4
.   968  0100028F4      0E000  b         0 -> 972
.   970  0100028F6      0008F  <LineNo: 143>
.   972  0100028F8      0B001  add       sp,#4
.   974  0100028FA      0BD00  pop       { pc }
.   976  0100028FC  02001FED0  <Global: Texts data>


  PROCEDURE writeNumString(W: TextIO.Writer; str: ARRAY OF CHAR; numChars, leftPadding: INTEGER);
  BEGIN
.   980  010002900      0B51F  push      { r0, r1, r2, r3, r4, lr }
    IF leftPadding > MaxBlanks THEN leftPadding := MaxBlanks END;
.   982  010002902      09804  ldr       r0,[sp,#16]
.   984  010002904      02820  cmp       r0,#32
.   986  010002906  0F3408002  ble.w     4 -> 994
.   990  01000290A      02020  movs      r0,#32
.   992  01000290C      09004  str       r0,[sp,#16]
    IF leftPadding > 0 THEN
.   994  01000290E      09804  ldr       r0,[sp,#16]
.   996  010002910      02800  cmp       r0,#0
.   998  010002912  0F3408013  ble.w     38 -> 1040
      W.putString(W.dev, Blanks, leftPadding)
.  1002  010002916      09800  ldr       r0,[sp]
.  1004  010002918      06800  ldr       r0,[r0]
.  1006  01000291A      0BF00  nop       
.  1008  01000291C      0467A  mov       r2,pc
.  1010  01000291E  0F5B2717C  subs.w    r1,r2,#1008
.  1014  010002922      02221  movs      r2,#33
.  1016  010002924      09B04  ldr       r3,[sp,#16]
    END;
.  1018  010002926      09C00  ldr       r4,[sp]
.  1020  010002928      06864  ldr       r4,[r4,#4]
.  1022  01000292A  0F1B40F00  cmp.w     r4,#0
.  1026  01000292E      0D101  bne.n     2 -> 1032
.  1028  010002930      0DF05  svc       5
.  1030  010002932      00097  <LineNo: 151>
.  1032  010002934      03401  adds      r4,#1
.  1034  010002936      047A0  blx       r4
.  1036  010002938      0E000  b         0 -> 1040
.  1038  01000293A      00097  <LineNo: 151>
    W.putString(W.dev, str, numChars)
.  1040  01000293C      09800  ldr       r0,[sp]
.  1042  01000293E      06800  ldr       r0,[r0]
.  1044  010002940      09901  ldr       r1,[sp,#4]
.  1046  010002942      09A02  ldr       r2,[sp,#8]
.  1048  010002944      09B03  ldr       r3,[sp,#12]
  END writeNumString;
.  1050  010002946      09C00  ldr       r4,[sp]
.  1052  010002948      06864  ldr       r4,[r4,#4]
.  1054  01000294A  0F1B40F00  cmp.w     r4,#0
.  1058  01000294E      0D101  bne.n     2 -> 1064
.  1060  010002950      0DF05  svc       5
.  1062  010002952      00099  <LineNo: 153>
.  1064  010002954      03401  adds      r4,#1
.  1066  010002956      047A0  blx       r4
.  1068  010002958      0E000  b         0 -> 1072
.  1070  01000295A      00099  <LineNo: 153>
.  1072  01000295C      0B005  add       sp,#20
.  1074  01000295E      0BD00  pop       { pc }


  PROCEDURE WriteInt*(W: TextIO.Writer; int, width: INTEGER);
    VAR buffer: ARRAY 12 OF CHAR; strLen: INTEGER;
  BEGIN
.  1076  010002960      0B507  push      { r0, r1, r2, lr }
.  1078  010002962      0B084  sub       sp,#16
    IntToString(int, buffer, strLen);
.  1080  010002964      09805  ldr       r0,[sp,#20]
.  1082  010002966      04669  mov       r1,sp
.  1084  010002968      0220C  movs      r2,#12
.  1086  01000296A  0F11D030C  adds.w    r3,sp,#12
.  1090  01000296E  0F7FFFDF1  bl.w      -1054 -> 40
.  1094  010002972      0E000  b         0 -> 1098
.  1096  010002974      000A0  <LineNo: 160>
    writeNumString(W, buffer, strLen, width - strLen)
.  1098  010002976      09804  ldr       r0,[sp,#16]
.  1100  010002978      04669  mov       r1,sp
.  1102  01000297A      0220C  movs      r2,#12
.  1104  01000297C      09B03  ldr       r3,[sp,#12]
.  1106  01000297E      09C06  ldr       r4,[sp,#24]
.  1108  010002980      09D03  ldr       r5,[sp,#12]
.  1110  010002982  0EBA40405  sub.w     r4,r4,r5
  END WriteInt;
.  1114  010002986  0F7FFFFBB  bl.w      -138 -> 980
.  1118  01000298A      0E000  b         0 -> 1122
.  1120  01000298C      000A1  <LineNo: 161>
.  1122  01000298E      0B007  add       sp,#28
.  1124  010002990      0BD00  pop       { pc }
.  1126  010002992      0BF00  nop       


  PROCEDURE WriteHex*(W: TextIO.Writer; int, width: INTEGER);
    VAR buffer: ARRAY 12 OF CHAR; strLen: INTEGER;
  BEGIN
.  1128  010002994      0B507  push      { r0, r1, r2, lr }
.  1130  010002996      0B084  sub       sp,#16
    IntToHexString(int, buffer, strLen);
.  1132  010002998      09805  ldr       r0,[sp,#20]
.  1134  01000299A      04669  mov       r1,sp
.  1136  01000299C      0220C  movs      r2,#12
.  1138  01000299E  0F11D030C  adds.w    r3,sp,#12
.  1142  0100029A2  0F7FFFE79  bl.w      -782 -> 364
.  1146  0100029A6      0E000  b         0 -> 1150
.  1148  0100029A8      000A8  <LineNo: 168>
    writeNumString(W, buffer, strLen, width - strLen)
.  1150  0100029AA      09804  ldr       r0,[sp,#16]
.  1152  0100029AC      04669  mov       r1,sp
.  1154  0100029AE      0220C  movs      r2,#12
.  1156  0100029B0      09B03  ldr       r3,[sp,#12]
.  1158  0100029B2      09C06  ldr       r4,[sp,#24]
.  1160  0100029B4      09D03  ldr       r5,[sp,#12]
.  1162  0100029B6  0EBA40405  sub.w     r4,r4,r5
  END WriteHex;
.  1166  0100029BA  0F7FFFFA1  bl.w      -190 -> 980
.  1170  0100029BE      0E000  b         0 -> 1174
.  1172  0100029C0      000A9  <LineNo: 169>
.  1174  0100029C2      0B007  add       sp,#28
.  1176  0100029C4      0BD00  pop       { pc }
.  1178  0100029C6      0BF00  nop       


  PROCEDURE WriteBin*(W: TextIO.Writer; int, width: INTEGER);
    VAR buffer: ARRAY 36 OF CHAR; strLen: INTEGER;
  BEGIN
.  1180  0100029C8      0B507  push      { r0, r1, r2, lr }
.  1182  0100029CA      0B08A  sub       sp,#40
    IntToBinString(int, buffer, strLen);
.  1184  0100029CC      0980B  ldr       r0,[sp,#44]
.  1186  0100029CE      04669  mov       r1,sp
.  1188  0100029D0      02224  movs      r2,#36
.  1190  0100029D2  0F11D0324  adds.w    r3,sp,#36
.  1194  0100029D6  0F7FFFECF  bl.w      -610 -> 588
.  1198  0100029DA      0E000  b         0 -> 1202
.  1200  0100029DC      000B0  <LineNo: 176>
    writeNumString(W, buffer, strLen, width - strLen)
.  1202  0100029DE      0980A  ldr       r0,[sp,#40]
.  1204  0100029E0      04669  mov       r1,sp
.  1206  0100029E2      02224  movs      r2,#36
.  1208  0100029E4      09B09  ldr       r3,[sp,#36]
.  1210  0100029E6      09C0C  ldr       r4,[sp,#48]
.  1212  0100029E8      09D09  ldr       r5,[sp,#36]
.  1214  0100029EA  0EBA40405  sub.w     r4,r4,r5
  END WriteBin;
.  1218  0100029EE  0F7FFFF87  bl.w      -242 -> 980
.  1222  0100029F2      0E000  b         0 -> 1226
.  1224  0100029F4      000B1  <LineNo: 177>
.  1226  0100029F6      0B00D  add       sp,#52
.  1228  0100029F8      0BD00  pop       { pc }
.  1230  0100029FA      0BF00  nop       

  (* read conversions *)

  PROCEDURE cleanLeft(str: ARRAY OF CHAR; VAR first: INTEGER; VAR neg: BOOLEAN);
    VAR ch: CHAR;
  BEGIN
.  1232  0100029FC      0B50F  push      { r0, r1, r2, r3, lr }
.  1234  0100029FE      0B081  sub       sp,#4
    first := 0;
.  1236  010002A00      02000  movs      r0,#0
.  1238  010002A02      09903  ldr       r1,[sp,#12]
.  1240  010002A04      06008  str       r0,[r1]
    WHILE str[first] = " " DO INC(first) END;
.  1242  010002A06      09803  ldr       r0,[sp,#12]
.  1244  010002A08      06800  ldr       r0,[r0]
.  1246  010002A0A      09902  ldr       r1,[sp,#8]
.  1248  010002A0C      04288  cmp       r0,r1
.  1250  010002A0E      0D301  bcc.n     2 -> 1256
.  1252  010002A10      0DF01  svc       1
.  1254  010002A12      000BA  <LineNo: 186>
.  1256  010002A14      09901  ldr       r1,[sp,#4]
.  1258  010002A16  0EB100001  adds.w    r0,r0,r1
.  1262  010002A1A      07800  ldrb      r0,[r0]
.  1264  010002A1C      02820  cmp       r0,#32
.  1266  010002A1E  0F0408006  bne.w     12 -> 1282
.  1270  010002A22      09803  ldr       r0,[sp,#12]
.  1272  010002A24      06801  ldr       r1,[r0]
.  1274  010002A26      03101  adds      r1,#1
.  1276  010002A28      06001  str       r1,[r0]
.  1278  010002A2A  0F7FFBFEC  b.w       -40 -> 1242
    ch := str[first];
.  1282  010002A2E      09803  ldr       r0,[sp,#12]
.  1284  010002A30      06800  ldr       r0,[r0]
.  1286  010002A32      09902  ldr       r1,[sp,#8]
.  1288  010002A34      04288  cmp       r0,r1
.  1290  010002A36      0D301  bcc.n     2 -> 1296
.  1292  010002A38      0DF01  svc       1
.  1294  010002A3A      000BB  <LineNo: 187>
.  1296  010002A3C      09901  ldr       r1,[sp,#4]
.  1298  010002A3E  0EB100001  adds.w    r0,r0,r1
.  1302  010002A42      07800  ldrb      r0,[r0]
.  1304  010002A44  0F88D0000  strb.w    r0,[sp]
    neg := ch = "-";
.  1308  010002A48  0F89D0000  ldrb.w    r0,[sp]
.  1312  010002A4C      0282D  cmp       r0,#45
.  1314  010002A4E      0BF0C  ite       eq
.  1316  010002A50  0F04F0001  moveq.w   r0,#1
.  1320  010002A54  0F04F0000  movne.w   r0,#0
.  1324  010002A58      09904  ldr       r1,[sp,#16]
.  1326  010002A5A      07008  strb      r0,[r1]
    IF (ch = "-") OR (ch = "+") THEN INC(first) END;
.  1328  010002A5C  0F89D0000  ldrb.w    r0,[sp]
.  1332  010002A60      0282D  cmp       r0,#45
.  1334  010002A62  0F0008005  beq.w     10 -> 1348
.  1338  010002A66  0F89D0000  ldrb.w    r0,[sp]
.  1342  010002A6A      0282B  cmp       r0,#43
.  1344  010002A6C  0F0408004  bne.w     8 -> 1356
.  1348  010002A70      09803  ldr       r0,[sp,#12]
.  1350  010002A72      06801  ldr       r1,[r0]
.  1352  010002A74      03101  adds      r1,#1
.  1354  010002A76      06001  str       r1,[r0]
    WHILE str[first] = " " DO INC(first) END;
.  1356  010002A78      09803  ldr       r0,[sp,#12]
.  1358  010002A7A      06800  ldr       r0,[r0]
.  1360  010002A7C      09902  ldr       r1,[sp,#8]
.  1362  010002A7E      04288  cmp       r0,r1
.  1364  010002A80      0D301  bcc.n     2 -> 1370
.  1366  010002A82      0DF01  svc       1
.  1368  010002A84      000BE  <LineNo: 190>
.  1370  010002A86      09901  ldr       r1,[sp,#4]
.  1372  010002A88  0EB100001  adds.w    r0,r0,r1
.  1376  010002A8C      07800  ldrb      r0,[r0]
.  1378  010002A8E      02820  cmp       r0,#32
.  1380  010002A90  0F0408006  bne.w     12 -> 1396
.  1384  010002A94      09803  ldr       r0,[sp,#12]
.  1386  010002A96      06801  ldr       r1,[r0]
.  1388  010002A98      03101  adds      r1,#1
.  1390  010002A9A      06001  str       r1,[r0]
.  1392  010002A9C  0F7FFBFEC  b.w       -40 -> 1356
    WHILE str[first] = "0" DO INC(first) END;
.  1396  010002AA0      09803  ldr       r0,[sp,#12]
.  1398  010002AA2      06800  ldr       r0,[r0]
.  1400  010002AA4      09902  ldr       r1,[sp,#8]
.  1402  010002AA6      04288  cmp       r0,r1
.  1404  010002AA8      0D301  bcc.n     2 -> 1410
.  1406  010002AAA      0DF01  svc       1
.  1408  010002AAC      000BF  <LineNo: 191>
.  1410  010002AAE      09901  ldr       r1,[sp,#4]
.  1412  010002AB0  0EB100001  adds.w    r0,r0,r1
.  1416  010002AB4      07800  ldrb      r0,[r0]
.  1418  010002AB6      02830  cmp       r0,#48
.  1420  010002AB8  0F0408006  bne.w     12 -> 1436
.  1424  010002ABC      09803  ldr       r0,[sp,#12]
.  1426  010002ABE      06801  ldr       r1,[r0]
.  1428  010002AC0      03101  adds      r1,#1
.  1430  010002AC2      06001  str       r1,[r0]
.  1432  010002AC4  0F7FFBFEC  b.w       -40 -> 1396
  END cleanLeft;
.  1436  010002AC8      0B005  add       sp,#20
.  1438  010002ACA      0BD00  pop       { pc }

  PROCEDURE cleanRight(str: ARRAY OF CHAR; numCh: INTEGER; VAR last: INTEGER);
  BEGIN
.  1440  010002ACC      0B50F  push      { r0, r1, r2, r3, lr }
    last := numCh - 1;
.  1442  010002ACE      09802  ldr       r0,[sp,#8]
.  1444  010002AD0      03801  subs      r0,#1
.  1446  010002AD2      09903  ldr       r1,[sp,#12]
.  1448  010002AD4      06008  str       r0,[r1]
    WHILE str[last] = " " DO
.  1450  010002AD6      09803  ldr       r0,[sp,#12]
.  1452  010002AD8      06800  ldr       r0,[r0]
.  1454  010002ADA      09901  ldr       r1,[sp,#4]
.  1456  010002ADC      04288  cmp       r0,r1
.  1458  010002ADE      0D301  bcc.n     2 -> 1464
.  1460  010002AE0      0DF01  svc       1
.  1462  010002AE2      000C5  <LineNo: 197>
.  1464  010002AE4      09900  ldr       r1,[sp]
.  1466  010002AE6  0EB100001  adds.w    r0,r0,r1
.  1470  010002AEA      07800  ldrb      r0,[r0]
.  1472  010002AEC      02820  cmp       r0,#32
.  1474  010002AEE  0F0408006  bne.w     12 -> 1490
      DEC(last)
    END
.  1478  010002AF2      09803  ldr       r0,[sp,#12]
.  1480  010002AF4      06801  ldr       r1,[r0]
.  1482  010002AF6      03901  subs      r1,#1
.  1484  010002AF8      06001  str       r1,[r0]
.  1486  010002AFA  0F7FFBFEC  b.w       -40 -> 1450
  END cleanRight;
.  1490  010002AFE      0B004  add       sp,#16
.  1492  010002B00      0BD00  pop       { pc }
.  1494  010002B02      0BF00  nop       


  PROCEDURE StrToInt*(str: ARRAY OF CHAR; numCh: INTEGER; VAR int: INTEGER; VAR res: INTEGER);
  (* rolls over at 0100000000H = 2^32 *)
    VAR first, last, digit: INTEGER; neg: BOOLEAN; ch: CHAR;
  BEGIN
.  1496  010002B04      0B51F  push      { r0, r1, r2, r3, r4, lr }
.  1498  010002B06      0B084  sub       sp,#16
    res := NoError;
.  1500  010002B08      02000  movs      r0,#0
.  1502  010002B0A      09908  ldr       r1,[sp,#32]
.  1504  010002B0C      06008  str       r0,[r1]
    cleanLeft(str, first, neg);
.  1506  010002B0E      09804  ldr       r0,[sp,#16]
.  1508  010002B10      09905  ldr       r1,[sp,#20]
.  1510  010002B12      0466A  mov       r2,sp
.  1512  010002B14  0F11D030C  adds.w    r3,sp,#12
.  1516  010002B18  0F7FFFF70  bl.w      -288 -> 1232
.  1520  010002B1C      0E000  b         0 -> 1524
.  1522  010002B1E      000D0  <LineNo: 208>
    IF numCh - first > MaxIntDigits THEN
.  1524  010002B20      09806  ldr       r0,[sp,#24]
.  1526  010002B22      09900  ldr       r1,[sp]
.  1528  010002B24  0EBA00001  sub.w     r0,r0,r1
.  1532  010002B28      0280A  cmp       r0,#10
.  1534  010002B2A  0F3408003  ble.w     6 -> 1544
      res := OutOfLimits;
.  1538  010002B2E      02003  movs      r0,#3
.  1540  010002B30      09908  ldr       r1,[sp,#32]
.  1542  010002B32      06008  str       r0,[r1]
    END;
    IF res = NoError THEN
.  1544  010002B34      09808  ldr       r0,[sp,#32]
.  1546  010002B36      06800  ldr       r0,[r0]
.  1548  010002B38      02800  cmp       r0,#0
.  1550  010002B3A  0F0408060  bne.w     192 -> 1746
      cleanRight(str, numCh, last);
.  1554  010002B3E      09804  ldr       r0,[sp,#16]
.  1556  010002B40      09905  ldr       r1,[sp,#20]
.  1558  010002B42      09A06  ldr       r2,[sp,#24]
.  1560  010002B44  0F11D0304  adds.w    r3,sp,#4
.  1564  010002B48  0F7FFFFC0  bl.w      -128 -> 1440
.  1568  010002B4C      0E000  b         0 -> 1572
.  1570  010002B4E      000D5  <LineNo: 213>
      int := 0;
.  1572  010002B50      02000  movs      r0,#0
.  1574  010002B52      09907  ldr       r1,[sp,#28]
.  1576  010002B54      06008  str       r0,[r1]
      WHILE (first <= last) & (res = NoError) DO
.  1578  010002B56      09800  ldr       r0,[sp]
.  1580  010002B58      09901  ldr       r1,[sp,#4]
.  1582  010002B5A      04288  cmp       r0,r1
.  1584  010002B5C  0F300804F  bgt.w     158 -> 1746
.  1588  010002B60      09808  ldr       r0,[sp,#32]
.  1590  010002B62      06800  ldr       r0,[r0]
.  1592  010002B64      02800  cmp       r0,#0
.  1594  010002B66  0F040804A  bne.w     148 -> 1746
        ch := str[first];
.  1598  010002B6A      09800  ldr       r0,[sp]
.  1600  010002B6C      09905  ldr       r1,[sp,#20]
.  1602  010002B6E      04288  cmp       r0,r1
.  1604  010002B70      0D301  bcc.n     2 -> 1610
.  1606  010002B72      0DF01  svc       1
.  1608  010002B74      000D8  <LineNo: 216>
.  1610  010002B76      09904  ldr       r1,[sp,#16]
.  1612  010002B78  0EB100001  adds.w    r0,r0,r1
.  1616  010002B7C      07800  ldrb      r0,[r0]
.  1618  010002B7E  0F88D000D  strb.w    r0,[sp,#13]
        IF (ch < "0") OR (ch > "9") THEN
.  1622  010002B82  0F89D000D  ldrb.w    r0,[sp,#13]
.  1626  010002B86      02830  cmp       r0,#48
.  1628  010002B88  0F2C08005  blt.w     10 -> 1642
.  1632  010002B8C  0F89D000D  ldrb.w    r0,[sp,#13]
.  1636  010002B90      02839  cmp       r0,#57
.  1638  010002B92  0F3408005  ble.w     10 -> 1652
          res := SyntaxError;
.  1642  010002B96      02002  movs      r0,#2
.  1644  010002B98      09908  ldr       r1,[sp,#32]
.  1646  010002B9A      06008  str       r0,[r1]
        ELSE
          digit := ORD(ch) - ORD("0");
.  1648  010002B9C  0F000B82D  b.w       90 -> 1742
.  1652  010002BA0  0F89D000D  ldrb.w    r0,[sp,#13]
.  1656  010002BA4      03830  subs      r0,#48
.  1658  010002BA6      09002  str       r0,[sp,#8]
          int := (int * 10) + digit;
.  1660  010002BA8      09807  ldr       r0,[sp,#28]
.  1662  010002BAA      06800  ldr       r0,[r0]
.  1664  010002BAC      0210A  movs      r1,#10
.  1666  010002BAE  0FB00F001  mul.w     r0,r0,r1
.  1670  010002BB2      09902  ldr       r1,[sp,#8]
.  1672  010002BB4      04408  add       r0,r1
.  1674  010002BB6      09907  ldr       r1,[sp,#28]
.  1676  010002BB8      06008  str       r0,[r1]
          IF MaxInt - int < 0 THEN  (* works across overflow *)
.  1678  010002BBA      09807  ldr       r0,[sp,#28]
.  1680  010002BBC      06800  ldr       r0,[r0]
.  1682  010002BBE  0F8DF1064  ldr.w     r1,[pc,#100] -> 1784
.  1686  010002BC2  0EBC00001  rsb.w     r0,r0,r1
.  1690  010002BC6      02800  cmp       r0,#0
.  1692  010002BC8  0F2808014  bge.w     40 -> 1736
            IF neg & (int = MinInt) THEN
.  1696  010002BCC  0F89D000C  ldrb.w    r0,[sp,#12]
.  1700  010002BD0  0F0100F01  tst.w     r0,#1
.  1704  010002BD4  0F000800B  beq.w     22 -> 1730
.  1708  010002BD8      09807  ldr       r0,[sp,#28]
.  1710  010002BDA      06800  ldr       r0,[r0]
.  1712  010002BDC  0F1104F00  cmn.w     r0,#080000000H
.  1716  010002BE0  0F0408005  bne.w     10 -> 1730
              neg := FALSE
            ELSE
.  1720  010002BE4      02000  movs      r0,#0
.  1722  010002BE6  0F88D000C  strb.w    r0,[sp,#12]
              res := OutOfLimits
.  1726  010002BEA  0F000B803  b.w       6 -> 1736
            END
.  1730  010002BEE      02003  movs      r0,#3
.  1732  010002BF0      09908  ldr       r1,[sp,#32]
.  1734  010002BF2      06008  str       r0,[r1]
          END;
          INC(first)
        END
.  1736  010002BF4      09800  ldr       r0,[sp]
.  1738  010002BF6      03001  adds      r0,#1
.  1740  010002BF8      09000  str       r0,[sp]
      END
.  1742  010002BFA  0F7FFBFAC  b.w       -168 -> 1578
    END;
    IF res = NoError THEN
.  1746  010002BFE      09808  ldr       r0,[sp,#32]
.  1748  010002C00      06800  ldr       r0,[r0]
.  1750  010002C02      02800  cmp       r0,#0
.  1752  010002C04  0F040800C  bne.w     24 -> 1780
      IF neg THEN int := -int END
.  1756  010002C08  0F89D000C  ldrb.w    r0,[sp,#12]
.  1760  010002C0C  0F0100F01  tst.w     r0,#1
.  1764  010002C10  0F0008006  beq.w     12 -> 1780
.  1768  010002C14      09807  ldr       r0,[sp,#28]
.  1770  010002C16      06800  ldr       r0,[r0]
.  1772  010002C18  0F1D00000  rsbs.w    r0,r0,#0
.  1776  010002C1C      09907  ldr       r1,[sp,#28]
.  1778  010002C1E      06008  str       r0,[r1]
    END
  END StrToInt;
.  1780  010002C20      0B009  add       sp,#36
.  1782  010002C22      0BD00  pop       { pc }
.  1784  010002C24  07FFFFFFF  <Const:  2147483647>

  (* read *)

  PROCEDURE ReadString*(R: TextIO.Reader; VAR s: ARRAY OF CHAR; VAR res: INTEGER);
  (**
    Read a string via 'R', terminated by 'TextIO.EOL'.
    Flush the rest of the input in case of buffer overflow.
    The string is truncated to the buffer length, terminated by 0X.
  **)
    VAR numCh: INTEGER;
  BEGIN
.  1788  010002C28      0B50F  push      { r0, r1, r2, r3, lr }
.  1790  010002C2A      0B081  sub       sp,#4
    R.getString(R.dev, s, numCh, res);
.  1792  010002C2C      09801  ldr       r0,[sp,#4]
.  1794  010002C2E      06800  ldr       r0,[r0]
.  1796  010002C30      09902  ldr       r1,[sp,#8]
.  1798  010002C32      09A03  ldr       r2,[sp,#12]
.  1800  010002C34      0466B  mov       r3,sp
.  1802  010002C36      09C04  ldr       r4,[sp,#16]
.  1804  010002C38      09D01  ldr       r5,[sp,#4]
.  1806  010002C3A      0686D  ldr       r5,[r5,#4]
.  1808  010002C3C  0F1B50F00  cmp.w     r5,#0
.  1812  010002C40      0D101  bne.n     2 -> 1818
.  1814  010002C42      0DF05  svc       5
.  1816  010002C44      000F8  <LineNo: 248>
.  1818  010002C46      03501  adds      r5,#1
.  1820  010002C48      047A8  blx       r5
.  1822  010002C4A      0E000  b         0 -> 1826
.  1824  010002C4C      000F8  <LineNo: 248>
    IF res = NoError THEN
.  1826  010002C4E      09804  ldr       r0,[sp,#16]
.  1828  010002C50      06800  ldr       r0,[r0]
.  1830  010002C52      02800  cmp       r0,#0
.  1832  010002C54  0F0408007  bne.w     14 -> 1850
      IF numCh = 0 THEN
.  1836  010002C58      09800  ldr       r0,[sp]
.  1838  010002C5A      02800  cmp       r0,#0
.  1840  010002C5C  0F0408003  bne.w     6 -> 1850
        res := NoInput
      END
.  1844  010002C60      02004  movs      r0,#4
.  1846  010002C62      09904  ldr       r1,[sp,#16]
.  1848  010002C64      06008  str       r0,[r1]
    END
  END ReadString;
.  1850  010002C66      0B005  add       sp,#20
.  1852  010002C68      0BD00  pop       { pc }
.  1854  010002C6A      0BF00  nop       


  PROCEDURE ReadInt*(R: TextIO.Reader; VAR int, res: INTEGER);
  (**
    Read an integer in decimal form via 'R', terminated by 'TextIO.EOL'.
    Flush the rest of the input in case of buffer overflow.
    The number is not valid in case of any error.
    As long as there's no buffer overflow or fifo overrrun, any number of leading
    blanks, blanks after the sign, leading zeros, and trailing blanks are permitted.
  **)
    VAR numCh: INTEGER; buf: ARRAY 32 OF CHAR;
  BEGIN
.  1856  010002C6C      0B507  push      { r0, r1, r2, lr }
.  1858  010002C6E      0B089  sub       sp,#36
    R.getString(R.dev, buf, numCh, res);
.  1860  010002C70      09809  ldr       r0,[sp,#36]
.  1862  010002C72      06800  ldr       r0,[r0]
.  1864  010002C74  0F11D0104  adds.w    r1,sp,#4
.  1868  010002C78      02220  movs      r2,#32
.  1870  010002C7A      0466B  mov       r3,sp
.  1872  010002C7C      09C0B  ldr       r4,[sp,#44]
.  1874  010002C7E      09D09  ldr       r5,[sp,#36]
.  1876  010002C80      0686D  ldr       r5,[r5,#4]
.  1878  010002C82  0F1B50F00  cmp.w     r5,#0
.  1882  010002C86      0D101  bne.n     2 -> 1888
.  1884  010002C88      0DF05  svc       5
.  1886  010002C8A      0010B  <LineNo: 267>
.  1888  010002C8C      03501  adds      r5,#1
.  1890  010002C8E      047A8  blx       r5
.  1892  010002C90      0E000  b         0 -> 1896
.  1894  010002C92      0010B  <LineNo: 267>
    IF res = NoError THEN
.  1896  010002C94      0980B  ldr       r0,[sp,#44]
.  1898  010002C96      06800  ldr       r0,[r0]
.  1900  010002C98      02800  cmp       r0,#0
.  1902  010002C9A  0F0408013  bne.w     38 -> 1944
      IF numCh > 0 THEN
.  1906  010002C9E      09800  ldr       r0,[sp]
.  1908  010002CA0      02800  cmp       r0,#0
.  1910  010002CA2  0F340800C  ble.w     24 -> 1938
        StrToInt(buf, numCh, int, res)
.  1914  010002CA6  0F11D0004  adds.w    r0,sp,#4
.  1918  010002CAA      02120  movs      r1,#32
.  1920  010002CAC      09A00  ldr       r2,[sp]
.  1922  010002CAE      09B0A  ldr       r3,[sp,#40]
.  1924  010002CB0      09C0B  ldr       r4,[sp,#44]
      ELSE
.  1926  010002CB2  0F7FFFF27  bl.w      -434 -> 1496
.  1930  010002CB6      0E000  b         0 -> 1934
.  1932  010002CB8      0010E  <LineNo: 270>
        res := NoInput
.  1934  010002CBA  0F000B803  b.w       6 -> 1944
      END
.  1938  010002CBE      02004  movs      r0,#4
.  1940  010002CC0      0990B  ldr       r1,[sp,#44]
.  1942  010002CC2      06008  str       r0,[r1]
    END
  END ReadInt;
.  1944  010002CC4      0B00C  add       sp,#48
.  1946  010002CC6      0BD00  pop       { pc }


  PROCEDURE FlushOut*(W: TextIO.Writer);
  (**
    Allow flushing on writers that don't need it to keep
    program code independent of output channel if needed.
  **)
  BEGIN
.  1948  010002CC8      0B501  push      { r0, lr }
    IF W.flush # NIL THEN
.  1950  010002CCA      09800  ldr       r0,[sp]
.  1952  010002CCC      06880  ldr       r0,[r0,#8]
.  1954  010002CCE      02800  cmp       r0,#0
.  1956  010002CD0  0F000800D  beq.w     26 -> 1986
      W.flush(W.dev)
.  1960  010002CD4      09800  ldr       r0,[sp]
.  1962  010002CD6      06800  ldr       r0,[r0]
    END
.  1964  010002CD8      09900  ldr       r1,[sp]
.  1966  010002CDA      06889  ldr       r1,[r1,#8]
.  1968  010002CDC  0F1B10F00  cmp.w     r1,#0
.  1972  010002CE0      0D101  bne.n     2 -> 1978
.  1974  010002CE2      0DF05  svc       5
.  1976  010002CE4      0011D  <LineNo: 285>
.  1978  010002CE6      03101  adds      r1,#1
.  1980  010002CE8      04788  blx       r1
.  1982  010002CEA      0E000  b         0 -> 1986
.  1984  010002CEC      0011D  <LineNo: 285>
  END FlushOut;
.  1986  010002CEE      0B001  add       sp,#4
.  1988  010002CF0      0BD00  pop       { pc }
.  1990  010002CF2      0BF00  nop       

BEGIN
.  1992  010002CF4      0B500  push      { lr }
  eol[0] := CR; eol[1] := LF
.  1994  010002CF6  0F8DF0010  ldr.w     r0,[pc,#16] -> 2012
.  1998  010002CFA      0210D  movs      r1,#13
.  2000  010002CFC      07001  strb      r1,[r0]
.  2002  010002CFE  0F8DF0008  ldr.w     r0,[pc,#8] -> 2012
END Texts.
.  2006  010002D02      0210A  movs      r1,#10
.  2008  010002D04      07041  strb      r1,[r0,#1]
.  2010  010002D06      0BD00  pop       { pc }
.  2012  010002D08  02001FED0  <Global: Texts data>
 