. <tool: Astrobe for RP2350>
. <prog: C:\Users\gray\Projects\oberon\dev\oberon-rtk\examples\v3.0\nxp\any\SignalSync\SignalSync.mod>

.     0  0000045B8              <Pad: 0>
MODULE Coroutines;
(**
  Oberon RTK Framework
  Version: v3.0
  --
  Simple coroutines
  --
  MCU: MCXA346, MCXN947
  --
  Copyright (c) 2020-2025 Gray, gray@grayraven.org
  https://oberon-rtk.org/licences/
**)

  IMPORT SYSTEM, Errors;

  TYPE
    PROC* = PROCEDURE;
    Coroutine* = POINTER TO CoroutineDesc;
    CoroutineDesc* = RECORD
      sp: INTEGER; (* stored stack pointer when transferring *)
      proc: PROC; (* the coroutine's code *)
      stAddr: INTEGER; (* stack address *)
      stSize: INTEGER; (* stack size *)
      id: INTEGER (* same as thread id *)
    END;
.     4  0000045BC      045BC      00014  <Type:   20>
.     8  0000045C0      045C0      00000  <Type:   0>
.    12  0000045C4      045C4      00000  <Type:   0>
.    16  0000045C8      045C8      00000  <Type:   0>
.    20  0000045CC      045CC      00000  <Type:   0>


  PROCEDURE* Reset*(cor: Coroutine);
    VAR addr: SET;
  BEGIN
.    24  0000045D0      0B500  push      { lr }
    ASSERT(cor # NIL, Errors.PreCond);
.    26  0000045D2      02800  cmp       r0,#0
.    28  0000045D4      0D101  bne.n     2 -> 34
.    30  0000045D6      0DF22  svc       34
.    32  0000045D8      0001F  <LineNo: 31>
    (* set up the stack memory for the initial 'Transfer' to 'cor' *)
    cor.sp := cor.stAddr + cor.stSize;
.    34  0000045DA      06882  ldr       r2,[r0,#8]
.    36  0000045DC      068C3  ldr       r3,[r0,#12]
.    38  0000045DE      0441A  add       r2,r3
.    40  0000045E0      06002  str       r2,[r0]
    (* skip top value = stack seal, see module Memory*)
    DEC(cor.sp, 4);
.    42  0000045E2      06802  ldr       r2,[r0]
.    44  0000045E4      03A04  subs      r2,#4
.    46  0000045E6      06002  str       r2,[r0]
    (* put 'lr' *)
    DEC(cor.sp, 4);
.    48  0000045E8      06802  ldr       r2,[r0]
.    50  0000045EA      03A04  subs      r2,#4
.    52  0000045EC      06002  str       r2,[r0]
    addr := SYSTEM.VAL(SET, cor.proc);
.    54  0000045EE      06842  ldr       r2,[r0,#4]
.    56  0000045F0      04611  mov       r1,r2
    INCL(addr, 0); (* thumb bit *)
.    58  0000045F2  0F0510101  orrs.w    r1,r1,#1
    SYSTEM.PUT(cor.sp, addr);
.    62  0000045F6      06802  ldr       r2,[r0]
.    64  0000045F8      06011  str       r1,[r2]
    (* keep slot for 't' *)
    DEC(cor.sp, 4);
.    66  0000045FA      06802  ldr       r2,[r0]
.    68  0000045FC      03A04  subs      r2,#4
.    70  0000045FE      06002  str       r2,[r0]
    (* put 'f', see 'Transfer' *)
    DEC(cor.sp, 4);
.    72  000004600      06802  ldr       r2,[r0]
.    74  000004602      03A04  subs      r2,#4
.    76  000004604      06002  str       r2,[r0]
    SYSTEM.PUT(cor.sp, SYSTEM.VAL(INTEGER, cor))
    (* initialised stack: with SP = 0: 'f' = 'cor', +4: don't care, +8: 'lr' *)
  END Reset;
.    78  000004606      06802  ldr       r2,[r0]
.    80  000004608      06010  str       r0,[r2]
.    82  00000460A      0BD00  pop       { pc }


  PROCEDURE Allocate*(cor: Coroutine; p: PROC);
  BEGIN
.    84  00000460C      0B503  push      { r0, r1, lr }
    ASSERT(cor # NIL, Errors.PreCond);
.    86  00000460E      09800  ldr       r0,[sp]
.    88  000004610      02800  cmp       r0,#0
.    90  000004612      0D101  bne.n     2 -> 96
.    92  000004614      0DF22  svc       34
.    94  000004616      00034  <LineNo: 52>
    cor.proc := p;
.    96  000004618      09801  ldr       r0,[sp,#4]
.    98  00000461A      09900  ldr       r1,[sp]
.   100  00000461C      06048  str       r0,[r1,#4]
    Reset(cor)
.   102  00000461E      09800  ldr       r0,[sp]
  END Allocate;
.   104  000004620  0F7FFFFD6  bl.w      -84 -> 24
.   108  000004624      0E000  b         0 -> 112
.   110  000004626      00036  <LineNo: 54>
.   112  000004628      0B002  add       sp,#8
.   114  00000462A      0BD00  pop       { pc }


  PROCEDURE* Init*(cor: Coroutine; stAddr, stSize, id: INTEGER);
  BEGIN
.   116  00000462C      0B500  push      { lr }
    ASSERT(cor # NIL, Errors.PreCond);
.   118  00000462E      02800  cmp       r0,#0
.   120  000004630      0D101  bne.n     2 -> 126
.   122  000004632      0DF22  svc       34
.   124  000004634      0003C  <LineNo: 60>
    cor.stAddr := stAddr;
.   126  000004636      06081  str       r1,[r0,#8]
    cor.stSize := stSize;
.   128  000004638      060C2  str       r2,[r0,#12]
    cor.id := id
  END Init;
.   130  00000463A      06103  str       r3,[r0,#16]
.   132  00000463C      0BD00  pop       { pc }
.   134  00000463E      0BF00  nop       


  PROCEDURE Transfer*(f, t: Coroutine);
    CONST SP = 13; LR = 14; R12 = 12;
  BEGIN
.   136  000004640      0B503  push      { r0, r1, lr }
    (* enter "as" f, f's stack in use *)
    (* prologue: push caller's 'lr' and parameters 'f' and 't' onto f's stack *)
    (* stack: 0: 'f', +4: 't', +8: 'lr' *)
    (* stack switching *)
    (* save f's SP *)
    f.sp := SYSTEM.REG(SP);
.   138  000004642      04668  mov       r0,sp
.   140  000004644      09900  ldr       r1,[sp]
.   142  000004646      06008  str       r0,[r1]
    (* switch stack: load t's SP *)
    (* 't' is still accessible on f's stack here *)
    SYSTEM.LDREG(SP, t.sp);
.   144  000004648      09801  ldr       r0,[sp,#4]
.   146  00000464A      06800  ldr       r0,[r0]
.   148  00000464C      04685  mov       sp,r0
    (* now t's stack in use *)
    (* stack: 0: 'f', +4: 't', +8: 'lr' *)
    (* note: meaning of 'f' and 't' as per the procedure call when transferring AWAY from 't' *)
    (* ie. 'f' is the coroutine on the stack here that we transfer to *)
    SYSTEM.LDREG(R12, f.id);
.   150  00000464E      09800  ldr       r0,[sp]
.   152  000004650      06900  ldr       r0,[r0,#16]
.   154  000004652      04684  mov       r12,r0
    SYSTEM.LDREG(LR, 0); (* get clean stack trace -- overkill? :) *)
.   156  000004654  0F2400E00  movw      lr,#0
    (* epilogue: adjust stack by +8, pop 'lr' from stack into 'pc' *)
    (* continue "as" t with 'lr' as 'pc' value *)
    (* Voila. *)
  END Transfer;
.   160  000004658      0B002  add       sp,#8
.   162  00000465A      0BD00  pop       { pc }

END Coroutines.
.   164  00000465C      0B500  push      { lr }
.   166  00000465E      0BD00  pop       { pc }
 