. <tool: Astrobe for RP2350>
. <prog: C:\Users\gray\Projects\oberon\dev\oberon-rtk\examples\v3.0\nxp\any\SignalSync\SignalSync.mod>

.     0  0000013FC              <Pad: 0>
MODULE Stacktrace;
(**
  Oberon RTK Framework
  Version: v3.0
  --
  Create stack trace amd read stack registers based on error data
  collected by run-time error handling RuntimeErrors.
  --
  MCU: MCXA346
  --
  Copyright (c) 2020-2025 Gray, gray@grayraven.org
  Portions copyright (c) 2008-2024 CFB Software, https://www.astrobe.com
  Used with permission.
  Please refer to the licensing conditions as defined at the end of this file.
**)

  IMPORT SYSTEM, MCU := MCU2, Config, RuntimeErrors;

  CONST
    TraceDepth = 16;

    ExcRetMask = 0FFFFFFE3H;
    ExcRetVal = 0FFFFFFA0H;

    AnnNone* = 0;
    AnnStackframe* = -1;

    StackTraceNotLR = 0;
    StackTraceLineNo = 1;
    StackTraceNoLineNo = 2;

    (* stack context sizes *)
    StateContextSize = 8 * 4;
    (* unused
    ExtStateContextSize = 10 * 4;
    *)
    FPcontextSize = 18 * 4;

    (* register offsets from stacked r0 *)
    PSRoffset = 28;
    PCoffset = 24;
    LRoffset = 20;

    StackSeal = 0FEF5EDA5H;


    (* EXC_RETURN bits *)
    (*EXC_RET_S     = 6;*)  (* = 1: secure stack frame, faulty code was running in secure domain *)
    (*EXC_RET_DCRS  = 5;*)  (* = 0: all CPU regs stacked by hardware, extended state context *)
    EXC_RET_FType = 4;  (* = 0: all FPU regs stacked by hardware, extended FPU context *)
    (*EXC_RET_Mode  = 3; *) (* = 1: thread mode, faulty code was running in thread mode *)
    (*EXC_RET_SPSEL = 2; *) (* = 1: PSP used for stacking *)
    (*EXC_RET_ES    = 0;*)  (* = 1: exception running in secure domain *)

  TYPE
    TracePoint* = RECORD
      address*: INTEGER;
      lineNo*: INTEGER;
      stackAddr*: INTEGER;
      annotation*: INTEGER
    END;
.     4  000001400      01400      00010  <Type:   16>
.     8  000001404      01404      00000  <Type:   0>
.    12  000001408      01408      00000  <Type:   0>
.    16  00000140C      0140C      00000  <Type:   0>
.    20  000001410      01410      00000  <Type:   0>

    Trace* = RECORD
      tp*: ARRAY TraceDepth OF TracePoint;
      count*: INTEGER;
      more*: BOOLEAN
    END;
.    24  000001414      01414      00108  <Type:   264>
.    28  000001418      01418      00000  <Type:   0>
.    32  00000141C      0141C      00000  <Type:   0>
.    36  000001420      01420      00000  <Type:   0>
.    40  000001424      01424      00000  <Type:   0>

    StackedRegs* = RECORD
      r0*, r1*, r2*, r3*, r12*: INTEGER;
      lr*, pc*, xpsr*, sp*: INTEGER
    END;
.    44  000001428      01428      00024  <Type:   36>
.    48  00000142C      0142C      00000  <Type:   0>
.    52  000001430      01430      00000  <Type:   0>
.    56  000001434      01434      00000  <Type:   0>
.    60  000001438      01438      00000  <Type:   0>


  (* --- Astrobe code begin --- *)

  PROCEDURE* getHalfWord(addr: INTEGER; VAR value: INTEGER);
  (* from Astrobe library, modified *)
  (* get 16-bit data from an address that is possibly not word-aligned *)
    VAR b1, b2: BYTE;
  BEGIN
.    64  00000143C      0B500  push      { lr }
    SYSTEM.GET(addr + 1, b1);
.    66  00000143E      01C44  adds      r4,r0,#1
.    68  000001440      07822  ldrb      r2,[r4]
    SYSTEM.GET(addr, b2);
.    70  000001442      07803  ldrb      r3,[r0]
    value := LSL(b1, 8) + b2;
.    72  000001444      00214  lsls      r4,r2,#8
.    74  000001446      0441C  add       r4,r3
.    76  000001448      0600C  str       r4,[r1]
  END getHalfWord;
.    78  00000144A      0BD00  pop       { pc }

  PROCEDURE isBL(codeAddr: INTEGER): BOOLEAN;
  (* from Astrobe library *)
  (* check if the instruction at 'codeAddr' is a BL instruction: [31:27] = 11110 *)
  (* note how the 32 bit code is stored as two 16 bit values:
      addr[x]   = [31:16]
      addr[x+2] = [15:0]
    since we have little endian encoding, it's physically:
      addr[x]   = [23:16][31:24]
      addr[x+2] = [7:0][15:8]
    but the load instruction takes care of *that* conversion.
  *)
    VAR instr: INTEGER;
  BEGIN
.    80  00000144C      0B501  push      { r0, lr }
.    82  00000144E      0B081  sub       sp,#4
    getHalfWord(codeAddr, instr);
.    84  000001450      09801  ldr       r0,[sp,#4]
.    86  000001452      04669  mov       r1,sp
.    88  000001454  0F7FFFFF2  bl.w      -28 -> 64
.    92  000001458      0E000  b         0 -> 96
.    94  00000145A      00064  <LineNo: 100>
    RETURN BFX(instr, 15, 11) = 01EH
.    96  00000145C      09800  ldr       r0,[sp]
.    98  00000145E  0F3C020C4  ubfx      r0,r0,11,5
  END isBL;
.   102  000001462      0281E  cmp       r0,#30
.   104  000001464      0BF0C  ite       eq
.   106  000001466  0F04F0001  moveq.w   r0,#1
.   110  00000146A  0F04F0000  movne.w   r0,#0
.   114  00000146E      0B002  add       sp,#8
.   116  000001470      0BD00  pop       { pc }
.   118  000001472      0BF00  nop       

  PROCEDURE isBLX(codeAddr: INTEGER): BOOLEAN;
  (* from Astrobe library, modified *)
  (* check if the instruction at 'codeAddr' is a BLX instruction: 010001111rrrr000 *)
    CONST
      BLXmask = 0FF87H; (* 1111 1111 1000 0111 *)
      BLXval  = 04780H; (* 0100 0111 1000 0000 *)
    VAR instr: INTEGER;
  BEGIN
.   120  000001474      0B501  push      { r0, lr }
.   122  000001476      0B081  sub       sp,#4
    getHalfWord(codeAddr, instr);
.   124  000001478      09801  ldr       r0,[sp,#4]
.   126  00000147A      04669  mov       r1,sp
.   128  00000147C  0F7FFFFDE  bl.w      -68 -> 64
.   132  000001480      0E000  b         0 -> 136
.   134  000001482      00070  <LineNo: 112>
    RETURN BITS(instr) * BITS(BLXmask) = BITS(BLXval)
.   136  000001484      09800  ldr       r0,[sp]
.   138  000001486  0F64F7187  movw      r1,#000FF87H
.   142  00000148A      04008  ands      r0,r1
    (*RETURN (BFX(instr, 15, 7) = 08FH) & (BFX(instr, 2, 0) = 0)*)
  END isBLX;
.   144  00000148C  0F2447180  movw      r1,#18304
.   148  000001490  0EA900F01  teq.w     r0,r1
.   152  000001494      0BF0C  ite       eq
.   154  000001496  0F04F0001  moveq.w   r0,#1
.   158  00000149A  0F04F0000  movne.w   r0,#0
.   162  00000149E      0B002  add       sp,#8
.   164  0000014A0      0BD00  pop       { pc }
.   166  0000014A2      0BF00  nop       

  PROCEDURE getLR(stackAddr: INTEGER; VAR lr, res: INTEGER);
  (* from Astrobe library, modified *)
  (* Check if the value at 'stackAddr' on the stack is a link register address.
  If yes, it will point to a code address (+1 for thumb mode) which
  is preceded by a BL or BLX instruction. *)
    VAR nextInstr: INTEGER;
  BEGIN
.   168  0000014A4      0B507  push      { r0, r1, r2, lr }
.   170  0000014A6      0B081  sub       sp,#4
    res := StackTraceNotLR;
.   172  0000014A8      02000  movs      r0,#0
.   174  0000014AA      09903  ldr       r1,[sp,#12]
.   176  0000014AC      06008  str       r0,[r1]
    SYSTEM.GET(stackAddr, lr);
.   178  0000014AE      09801  ldr       r0,[sp,#4]
.   180  0000014B0      06801  ldr       r1,[r0]
.   182  0000014B2      09A02  ldr       r2,[sp,#8]
.   184  0000014B4      06011  str       r1,[r2]
    (* must be Thumb mode *)
    IF ODD(lr) THEN
.   186  0000014B6      09802  ldr       r0,[sp,#8]
.   188  0000014B8      06800  ldr       r0,[r0]
.   190  0000014BA  0F0100F01  tst.w     r0,#1
.   194  0000014BE  0F0008040  beq.w     128 -> 326
      DEC(lr, 1);
.   198  0000014C2      09802  ldr       r0,[sp,#8]
.   200  0000014C4      06801  ldr       r1,[r0]
.   202  0000014C6      03901  subs      r1,#1
.   204  0000014C8      06001  str       r1,[r0]
      IF (lr >= Config.CodeMem.start + 100H) & (lr < Config.CodeMem.end) THEN
.   206  0000014CA  0F8DF007C  ldr.w     r0,[pc,#124] -> 332
.   210  0000014CE      06800  ldr       r0,[r0]
.   212  0000014D0  0F5007080  add.w     r0,r0,#256
.   216  0000014D4      09902  ldr       r1,[sp,#8]
.   218  0000014D6      06809  ldr       r1,[r1]
.   220  0000014D8      04281  cmp       r1,r0
.   222  0000014DA  0F2C08032  blt.w     100 -> 326
.   226  0000014DE  0F8DF0068  ldr.w     r0,[pc,#104] -> 332
.   230  0000014E2      09902  ldr       r1,[sp,#8]
.   232  0000014E4      06809  ldr       r1,[r1]
.   234  0000014E6      06840  ldr       r0,[r0,#4]
.   236  0000014E8      04281  cmp       r1,r0
.   238  0000014EA  0F280802A  bge.w     84 -> 326
        IF isBL(lr - 4) OR isBLX(lr - 2) THEN
.   242  0000014EE      09802  ldr       r0,[sp,#8]
.   244  0000014F0      06800  ldr       r0,[r0]
.   246  0000014F2      03804  subs      r0,#4
.   248  0000014F4  0F7FFFFAA  bl.w      -172 -> 80
.   252  0000014F8      0E000  b         0 -> 256
.   254  0000014FA      00082  <LineNo: 130>
.   256  0000014FC  0F0100F01  tst.w     r0,#1
.   260  000001500  0F040800B  bne.w     22 -> 286
.   264  000001504      09802  ldr       r0,[sp,#8]
.   266  000001506      06800  ldr       r0,[r0]
.   268  000001508      03802  subs      r0,#2
.   270  00000150A  0F7FFFFB3  bl.w      -154 -> 120
.   274  00000150E      0E000  b         0 -> 278
.   276  000001510      00082  <LineNo: 130>
.   278  000001512  0F0100F01  tst.w     r0,#1
.   282  000001516  0F0008014  beq.w     40 -> 326
          getHalfWord(lr, nextInstr);
.   286  00000151A      09802  ldr       r0,[sp,#8]
.   288  00000151C      06800  ldr       r0,[r0]
.   290  00000151E      04669  mov       r1,sp
.   292  000001520  0F7FFFF8C  bl.w      -232 -> 64
.   296  000001524      0E000  b         0 -> 300
.   298  000001526      00083  <LineNo: 131>
          (* if stack trace is enabled there is a B,0 instruction (0E0000H)
          that skips the line number after the BL or BLX instruction *)
          IF nextInstr = 0E000H THEN
.   300  000001528      09800  ldr       r0,[sp]
.   302  00000152A  0F5B04F60  cmp.w     r0,#000E000H
.   306  00000152E  0F0408005  bne.w     10 -> 320
            res := StackTraceLineNo
          ELSE
.   310  000001532      02001  movs      r0,#1
.   312  000001534      09903  ldr       r1,[sp,#12]
.   314  000001536      06008  str       r0,[r1]
            res := StackTraceNoLineNo
.   316  000001538  0F000B803  b.w       6 -> 326
          END
.   320  00000153C      02002  movs      r0,#2
.   322  00000153E      09903  ldr       r1,[sp,#12]
.   324  000001540      06008  str       r0,[r1]
        END
      END
    END
  END getLR;
.   326  000001542      0B004  add       sp,#16
.   328  000001544      0BD00  pop       { pc }
.   330  000001546      0BF00  nop       
.   332  000001548  020027FA8  <Global: Config data>

  (* --- Astrobe code end --- *)

  PROCEDURE* traceStart(stackframeBase, excRetVal: INTEGER): INTEGER;
    CONST StackAlign = 9; (* in stacked PSR *)
    VAR startAddr: INTEGER;
  BEGIN
.   336  00000154C      0B500  push      { lr }
    startAddr := stackframeBase + StateContextSize;
.   338  00000154E  0F1000220  add.w     r2,r0,#32
    IF ~(EXC_RET_FType IN BITS(excRetVal)) THEN (* FP context *)
.   342  000001552  0F0110F10  tst.w     r1,#16
.   346  000001556  0F0408002  bne.w     4 -> 354
      startAddr := startAddr + FPcontextSize
    END;
.   350  00000155A  0F1020248  add.w     r2,r2,#72
    IF SYSTEM.BIT(stackframeBase + PSRoffset, StackAlign) THEN
.   354  00000155E  0F100031C  add.w     r3,r0,#28
.   358  000001562      0681C  ldr       r4,[r3]
.   360  000001564      005A4  lsls      r4,r4,#22
.   362  000001566  0F1408001  bpl.w     2 -> 368
      INC(startAddr, 4)
    END
.   366  00000156A      03204  adds      r2,#4
    RETURN startAddr
  END traceStart;
.   368  00000156C      04610  mov       r0,r2
.   370  00000156E      0BD00  pop       { pc }


  PROCEDURE getAddr(VAR stackAddr, excRetVal: INTEGER; VAR isStackFrame: BOOLEAN);
    CONST R11 = 11;
    VAR stackVal, lr, res: INTEGER;
  BEGIN
.   372  000001570      0B507  push      { r0, r1, r2, lr }
.   374  000001572      0B083  sub       sp,#12
    isStackFrame := FALSE;
.   376  000001574      02000  movs      r0,#0
.   378  000001576      09905  ldr       r1,[sp,#20]
.   380  000001578      07008  strb      r0,[r1]
    SYSTEM.GET(stackAddr, stackVal);
.   382  00000157A      09803  ldr       r0,[sp,#12]
.   384  00000157C      06800  ldr       r0,[r0]
.   386  00000157E      06801  ldr       r1,[r0]
.   388  000001580      09100  str       r1,[sp]
    IF BITS(stackVal) * BITS(ExcRetMask) = BITS(ExcRetVal) THEN
.   390  000001582      09800  ldr       r0,[sp]
.   392  000001584  0F06F011C  mvn.w     r1,#28
.   396  000001588      04008  ands      r0,r1
.   398  00000158A  0F06F015F  mvn.w     r1,#95
.   402  00000158E  0EA900F01  teq.w     r0,r1
.   406  000001592  0F040804A  bne.w     148 -> 558
      (* if a potential EXC_RETURN value *)
      excRetVal := stackVal; (* only valid if 'isStackFrame' *)
.   410  000001596      09800  ldr       r0,[sp]
.   412  000001598      09904  ldr       r1,[sp,#16]
.   414  00000159A      06008  str       r0,[r1]
      SYSTEM.GET(stackAddr + 4, stackVal);
.   416  00000159C      09803  ldr       r0,[sp,#12]
.   418  00000159E      06800  ldr       r0,[r0]
.   420  0000015A0      03004  adds      r0,#4
.   422  0000015A2      06801  ldr       r1,[r0]
.   424  0000015A4      09100  str       r1,[sp]
      IF stackVal = StackSeal THEN
.   426  0000015A6      09800  ldr       r0,[sp]
.   428  0000015A8  0F8DF1084  ldr.w     r1,[pc,#132] -> 564
.   432  0000015AC      042C8  cmn       r0,r1
.   434  0000015AE  0F040800A  bne.w     20 -> 458
        (* at top of main stack: we have an EXC_RETURN value with 'PSP used for stacking' *)
        (* switch stacks, point to stacked regs on process stack *)
        SYSTEM.EMIT(MCU.MRS_R11_PSP);
.   438  0000015B2  0F3EF8B09  .word     0x8B09F3EF /* EMIT */
        stackAddr := SYSTEM.REG(R11);
.   442  0000015B6      04658  mov       r0,r11
.   444  0000015B8      09903  ldr       r1,[sp,#12]
.   446  0000015BA      06008  str       r0,[r1]
        isStackFrame := TRUE
      ELSE
.   448  0000015BC      02001  movs      r0,#1
.   450  0000015BE      09905  ldr       r1,[sp,#20]
.   452  0000015C0      07008  strb      r0,[r1]
        (* point to potential stack frame on main stack*)
        INC(stackAddr, 4);
.   454  0000015C2  0F000B832  b.w       100 -> 558
.   458  0000015C6      09803  ldr       r0,[sp,#12]
.   460  0000015C8      06801  ldr       r1,[r0]
.   462  0000015CA      03104  adds      r1,#4
.   464  0000015CC      06001  str       r1,[r0]
        (* stacked value at LRoffset must be either a valid LR value... *)
        getLR(stackAddr + LRoffset, lr, res);
.   466  0000015CE      09803  ldr       r0,[sp,#12]
.   468  0000015D0      06800  ldr       r0,[r0]
.   470  0000015D2      03014  adds      r0,#20
.   472  0000015D4  0F11D0104  adds.w    r1,sp,#4
.   476  0000015D8  0F11D0208  adds.w    r2,sp,#8
.   480  0000015DC  0F7FFFF62  bl.w      -316 -> 168
.   484  0000015E0      0E000  b         0 -> 488
.   486  0000015E2      000B5  <LineNo: 181>
        isStackFrame := res > StackTraceNotLR;
.   488  0000015E4      09802  ldr       r0,[sp,#8]
.   490  0000015E6      02800  cmp       r0,#0
.   492  0000015E8      0BFCC  ite       gt
.   494  0000015EA  0F04F0001  movgt.w   r0,#1
.   498  0000015EE  0F04F0000  movle.w   r0,#0
.   502  0000015F2      09905  ldr       r1,[sp,#20]
.   504  0000015F4      07008  strb      r0,[r1]
        (* ... or an EXC_RETURN value *)
        IF ~isStackFrame THEN
.   506  0000015F6      09805  ldr       r0,[sp,#20]
.   508  0000015F8      07800  ldrb      r0,[r0]
.   510  0000015FA  0F0100F01  tst.w     r0,#1
.   514  0000015FE  0F0408014  bne.w     40 -> 558
          SYSTEM.GET(stackAddr + LRoffset, stackVal);
.   518  000001602      09803  ldr       r0,[sp,#12]
.   520  000001604      06800  ldr       r0,[r0]
.   522  000001606      03014  adds      r0,#20
.   524  000001608      06801  ldr       r1,[r0]
.   526  00000160A      09100  str       r1,[sp]
          isStackFrame := BITS(stackVal) * BITS(ExcRetMask) = BITS(ExcRetVal)
.   528  00000160C      09800  ldr       r0,[sp]
.   530  00000160E  0F06F011C  mvn.w     r1,#28
.   534  000001612      04008  ands      r0,r1
        END
.   536  000001614  0F06F015F  mvn.w     r1,#95
.   540  000001618  0EA900F01  teq.w     r0,r1
.   544  00000161C      0BF0C  ite       eq
.   546  00000161E  0F04F0001  moveq.w   r0,#1
.   550  000001622  0F04F0000  movne.w   r0,#0
.   554  000001626      09905  ldr       r1,[sp,#20]
.   556  000001628      07008  strb      r0,[r1]
      END
    END;

  END getAddr;
.   558  00000162A      0B006  add       sp,#24
.   560  00000162C      0BD00  pop       { pc }
.   562  00000162E      0BF00  nop       
.   564  000001630  0010A125B  <Const:  17437275>


  PROCEDURE stacktrace(stackAddr: INTEGER; VAR trace: Trace);
    VAR
      stackVal, retAddr, excRetVal, res, lr, traceDepth: INTEGER;
      (*addr, val: INTEGER; (* debug *)*)
      tp: TracePoint; isStackFrame: BOOLEAN;
  BEGIN
.   568  000001634      0B507  push      { r0, r1, r2, lr }
.   570  000001636      0B08B  sub       sp,#44
    CLEAR(tp);
.   572  000001638  0F11D0018  adds.w    r0,sp,#24
.   576  00000163C      02100  movs      r1,#0
.   578  00000163E      02204  movs      r2,#4
.   580  000001640  0F8401B04  str.w     r1,[r0],#4
.   584  000001644      03A01  subs      r2,#1
.   586  000001646      0DCFB  bgt.n     -10 -> 580
    traceDepth := LEN(trace.tp);
.   588  000001648      02010  movs      r0,#16
.   590  00000164A      09005  str       r0,[sp,#20]
    SYSTEM.GET(stackAddr, stackVal);
.   592  00000164C      0980B  ldr       r0,[sp,#44]
.   594  00000164E      06801  ldr       r1,[r0]
.   596  000001650      09100  str       r1,[sp]
    WHILE (stackVal # StackSeal) & (trace.count <= traceDepth) DO
.   598  000001652      09800  ldr       r0,[sp]
.   600  000001654  0F8DF1114  ldr.w     r1,[pc,#276] -> 880
.   604  000001658      042C8  cmn       r0,r1
.   606  00000165A  0F0008084  beq.w     264 -> 874
.   610  00000165E      0980C  ldr       r0,[sp,#48]
.   612  000001660  0F8D00100  ldr.w     r0,[r0,#256]
.   616  000001664      09905  ldr       r1,[sp,#20]
.   618  000001666      04288  cmp       r0,r1
.   620  000001668  0F300807D  bgt.w     250 -> 874
      (* debug *)
      (*
      Out.Hex(stackAddr, 13); Out.Hex(stackVal, 13); Out.Ln;
      *)
      (* debug end *)
      getAddr(stackAddr, excRetVal, isStackFrame);
.   624  00000166C  0F11D002C  adds.w    r0,sp,#44
.   628  000001670  0F11D0108  adds.w    r1,sp,#8
.   632  000001674  0F11D0228  adds.w    r2,sp,#40
.   636  000001678  0F7FFFF7A  bl.w      -268 -> 372
.   640  00000167C      0E000  b         0 -> 644
.   642  00000167E      000D1  <LineNo: 209>
      IF isStackFrame THEN
.   644  000001680  0F89D0028  ldrb.w    r0,[sp,#40]
.   648  000001684  0F0100F01  tst.w     r0,#1
.   652  000001688  0F0008014  beq.w     40 -> 696
        SYSTEM.GET(stackAddr + PCoffset, retAddr);
.   656  00000168C      0980B  ldr       r0,[sp,#44]
.   658  00000168E      03018  adds      r0,#24
.   660  000001690      06801  ldr       r1,[r0]
.   662  000001692      09101  str       r1,[sp,#4]
        tp.address := retAddr;
.   664  000001694      09801  ldr       r0,[sp,#4]
.   666  000001696      09006  str       r0,[sp,#24]
        tp.annotation := AnnStackframe;
.   668  000001698  0F8DF00D4  ldr.w     r0,[pc,#212] -> 884
.   672  00000169C      09009  str       r0,[sp,#36]
        tp.stackAddr := stackAddr;
.   674  00000169E      0980B  ldr       r0,[sp,#44]
.   676  0000016A0      09008  str       r0,[sp,#32]
        (* addr := stackAddr; (* debug *) *)
        stackAddr := traceStart(stackAddr, excRetVal);
.   678  0000016A2      0980B  ldr       r0,[sp,#44]
.   680  0000016A4      09902  ldr       r1,[sp,#8]
.   682  0000016A6  0F7FFFF51  bl.w      -350 -> 336
.   686  0000016AA      0E000  b         0 -> 690
.   688  0000016AC      000D8  <LineNo: 216>
.   690  0000016AE      0900B  str       r0,[sp,#44]
        (* debug: print stack dump *)
        (*
        WHILE addr < stackAddr DO
          SYSTEM.GET(addr, val);
          Out.String("> "); Out.Hex(addr, 13); Out.Hex(val, 13); Out.Ln;
          INC(addr, 4)
        END
        *)
        (* debug end *)
      ELSE
        getLR(stackAddr, lr, res);
.   692  0000016B0  0F000B821  b.w       66 -> 762
.   696  0000016B4      0980B  ldr       r0,[sp,#44]
.   698  0000016B6  0F11D0110  adds.w    r1,sp,#16
.   702  0000016BA  0F11D020C  adds.w    r2,sp,#12
.   706  0000016BE  0F7FFFEF1  bl.w      -542 -> 168
.   710  0000016C2      0E000  b         0 -> 714
.   712  0000016C4      000E3  <LineNo: 227>
        IF res > StackTraceNotLR THEN
.   714  0000016C6      09803  ldr       r0,[sp,#12]
.   716  0000016C8      02800  cmp       r0,#0
.   718  0000016CA  0F3408011  ble.w     34 -> 756
          tp.address := lr - 4;
.   722  0000016CE      09804  ldr       r0,[sp,#16]
.   724  0000016D0      03804  subs      r0,#4
.   726  0000016D2      09006  str       r0,[sp,#24]
          tp.stackAddr := stackAddr;
.   728  0000016D4      0980B  ldr       r0,[sp,#44]
.   730  0000016D6      09008  str       r0,[sp,#32]
          IF res = StackTraceLineNo THEN
.   732  0000016D8      09803  ldr       r0,[sp,#12]
.   734  0000016DA      02801  cmp       r0,#1
.   736  0000016DC  0F0408008  bne.w     16 -> 756
            getHalfWord(lr + 2, tp.lineNo)
.   740  0000016E0      09804  ldr       r0,[sp,#16]
.   742  0000016E2      03002  adds      r0,#2
.   744  0000016E4  0F11D011C  adds.w    r1,sp,#28
          END
.   748  0000016E8  0F7FFFEA8  bl.w      -688 -> 64
.   752  0000016EC      0E000  b         0 -> 756
.   754  0000016EE      000E8  <LineNo: 232>
        END;
        INC(stackAddr, 4)
      END;
.   756  0000016F0      0980B  ldr       r0,[sp,#44]
.   758  0000016F2      03004  adds      r0,#4
.   760  0000016F4      0900B  str       r0,[sp,#44]
      IF tp.address # 0 THEN (* tp is valid *)
.   762  0000016F6      09806  ldr       r0,[sp,#24]
.   764  0000016F8      02800  cmp       r0,#0
.   766  0000016FA  0F000802F  beq.w     94 -> 864
        IF trace.count < TraceDepth THEN
.   770  0000016FE      0980C  ldr       r0,[sp,#48]
.   772  000001700  0F8D00100  ldr.w     r0,[r0,#256]
.   776  000001704      02810  cmp       r0,#16
.   778  000001706  0F2808025  bge.w     74 -> 856
          trace.tp[trace.count] := tp;
.   782  00000170A      0980C  ldr       r0,[sp,#48]
.   784  00000170C  0F8D00100  ldr.w     r0,[r0,#256]
.   788  000001710      02810  cmp       r0,#16
.   790  000001712      0D301  bcc.n     2 -> 796
.   792  000001714      0DF01  svc       1
.   794  000001716      000EF  <LineNo: 239>
.   796  000001718      0990C  ldr       r1,[sp,#48]
.   798  00000171A      00102  lsls      r2,r0,#4
.   800  00000171C  0EB020001  add.w     r0,r2,r1
.   804  000001720      02104  movs      r1,#4
.   806  000001722  0F11D0218  adds.w    r2,sp,#24
.   810  000001726  0F8523B04  ldr.w     r3,[r2],#4
.   814  00000172A  0F8403B04  str.w     r3,[r0],#4
.   818  00000172E      03901  subs      r1,#1
.   820  000001730      0D1F9  bne.n     -14 -> 810
          INC(trace.count);
.   822  000001732      0980C  ldr       r0,[sp,#48]
.   824  000001734  0F8D01100  ldr.w     r1,[r0,#256]
.   828  000001738      03101  adds      r1,#1
.   830  00000173A  0F8C01100  str.w     r1,[r0,#256]
          CLEAR(tp)
        ELSE
.   834  00000173E  0F11D0018  adds.w    r0,sp,#24
.   838  000001742      02100  movs      r1,#0
.   840  000001744      02204  movs      r2,#4
.   842  000001746      0BF00  nop       
.   844  000001748  0F8401B04  str.w     r1,[r0],#4
.   848  00000174C      03A01  subs      r2,#1
.   850  00000174E      0DCFB  bgt.n     -10 -> 844
          trace.more := TRUE
.   852  000001750  0F000B804  b.w       8 -> 864
        END
.   856  000001754      02001  movs      r0,#1
.   858  000001756      0990C  ldr       r1,[sp,#48]
.   860  000001758  0F8810104  strb.w    r0,[r1,#260]
      END;
      SYSTEM.GET(stackAddr, stackVal);
.   864  00000175C      0980B  ldr       r0,[sp,#44]
.   866  00000175E      06801  ldr       r1,[r0]
.   868  000001760      09100  str       r1,[sp]
    END
.   870  000001762  0F7FFBF76  b.w       -276 -> 598
  END stacktrace;
.   874  000001766      0B00E  add       sp,#56
.   876  000001768      0BD00  pop       { pc }
.   878  00000176A      0BF00  nop       
.   880  00000176C  0010A125B  <Const:  17437275>
.   884  000001770  0FFFFFFFF  <Const:  -1>


  PROCEDURE CreateTrace*(er: RuntimeErrors.ErrorDesc; VAR tr: Trace);
    VAR tp: TracePoint;
  BEGIN
.   888  000001774      0B50F  push      { r0, r1, r2, r3, lr }
.   890  000001776      0B084  sub       sp,#16
    tp.address := er.errAddr;
.   892  000001778      09804  ldr       r0,[sp,#16]
.   894  00000177A      06840  ldr       r0,[r0,#4]
.   896  00000177C      09000  str       r0,[sp]
    tp.lineNo := er.errLineNo;
.   898  00000177E      09804  ldr       r0,[sp,#16]
.   900  000001780      06880  ldr       r0,[r0,#8]
.   902  000001782      09001  str       r0,[sp,#4]
    tp.stackAddr := 0;
.   904  000001784      02000  movs      r0,#0
.   906  000001786      09002  str       r0,[sp,#8]
    tp.annotation := 0;
.   908  000001788      02000  movs      r0,#0
.   910  00000178A      09003  str       r0,[sp,#12]
    tr.tp[0] := tp;
.   912  00000178C      02004  movs      r0,#4
.   914  00000178E      09906  ldr       r1,[sp,#24]
.   916  000001790      0466A  mov       r2,sp
.   918  000001792  0F8523B04  ldr.w     r3,[r2],#4
.   922  000001796  0F8413B04  str.w     r3,[r1],#4
.   926  00000179A      03801  subs      r0,#1
.   928  00000179C      0D1F9  bne.n     -14 -> 918
    tr.count := 1;
.   930  00000179E      02001  movs      r0,#1
.   932  0000017A0      09906  ldr       r1,[sp,#24]
.   934  0000017A2  0F8C10100  str.w     r0,[r1,#256]
    tr.more := FALSE;
.   938  0000017A6      02000  movs      r0,#0
.   940  0000017A8      09906  ldr       r1,[sp,#24]
.   942  0000017AA  0F8810104  strb.w    r0,[r1,#260]
    stacktrace(traceStart(er.stackframeBase, er.excRetVal), tr)
.   946  0000017AE      09804  ldr       r0,[sp,#16]
.   948  0000017B0      068C0  ldr       r0,[r0,#12]
.   950  0000017B2      09904  ldr       r1,[sp,#16]
.   952  0000017B4      06909  ldr       r1,[r1,#16]
.   954  0000017B6  0F7FFFEC9  bl.w      -622 -> 336
.   958  0000017BA      0E000  b         0 -> 962
.   960  0000017BC      00105  <LineNo: 261>
.   962  0000017BE      09906  ldr       r1,[sp,#24]
.   964  0000017C0      09A07  ldr       r2,[sp,#28]
  END CreateTrace;
.   966  0000017C2  0F7FFFF37  bl.w      -402 -> 568
.   970  0000017C6      0E000  b         0 -> 974
.   972  0000017C8      00105  <LineNo: 261>
.   974  0000017CA      0B008  add       sp,#32
.   976  0000017CC      0BD00  pop       { pc }
.   978  0000017CE      0BF00  nop       


  PROCEDURE ReadRegisters*(er: RuntimeErrors.ErrorDesc; VAR sr: StackedRegs);
    VAR stackframeBase: INTEGER;
  BEGIN
.   980  0000017D0      0B50F  push      { r0, r1, r2, r3, lr }
.   982  0000017D2      0B081  sub       sp,#4
    stackframeBase := er.stackframeBase;
.   984  0000017D4      09801  ldr       r0,[sp,#4]
.   986  0000017D6      068C0  ldr       r0,[r0,#12]
.   988  0000017D8      09000  str       r0,[sp]
    SYSTEM.GET(stackframeBase, sr.r0);
.   990  0000017DA      09800  ldr       r0,[sp]
.   992  0000017DC      06801  ldr       r1,[r0]
.   994  0000017DE      09A03  ldr       r2,[sp,#12]
.   996  0000017E0      06011  str       r1,[r2]
    SYSTEM.GET(stackframeBase + 4, sr.r1);
.   998  0000017E2      09800  ldr       r0,[sp]
.  1000  0000017E4      03004  adds      r0,#4
.  1002  0000017E6      06801  ldr       r1,[r0]
.  1004  0000017E8      09A03  ldr       r2,[sp,#12]
.  1006  0000017EA      06051  str       r1,[r2,#4]
    SYSTEM.GET(stackframeBase + 8, sr.r2);
.  1008  0000017EC      09800  ldr       r0,[sp]
.  1010  0000017EE      03008  adds      r0,#8
.  1012  0000017F0      06801  ldr       r1,[r0]
.  1014  0000017F2      09A03  ldr       r2,[sp,#12]
.  1016  0000017F4      06091  str       r1,[r2,#8]
    SYSTEM.GET(stackframeBase + 12, sr.r3);
.  1018  0000017F6      09800  ldr       r0,[sp]
.  1020  0000017F8      0300C  adds      r0,#12
.  1022  0000017FA      06801  ldr       r1,[r0]
.  1024  0000017FC      09A03  ldr       r2,[sp,#12]
.  1026  0000017FE      060D1  str       r1,[r2,#12]
    SYSTEM.GET(stackframeBase + 16, sr.r12);
.  1028  000001800      09800  ldr       r0,[sp]
.  1030  000001802      03010  adds      r0,#16
.  1032  000001804      06801  ldr       r1,[r0]
.  1034  000001806      09A03  ldr       r2,[sp,#12]
.  1036  000001808      06111  str       r1,[r2,#16]
    SYSTEM.GET(stackframeBase + 20, sr.lr);
.  1038  00000180A      09800  ldr       r0,[sp]
.  1040  00000180C      03014  adds      r0,#20
.  1042  00000180E      06801  ldr       r1,[r0]
.  1044  000001810      09A03  ldr       r2,[sp,#12]
.  1046  000001812      06151  str       r1,[r2,#20]
    SYSTEM.GET(stackframeBase + 24, sr.pc);
.  1048  000001814      09800  ldr       r0,[sp]
.  1050  000001816      03018  adds      r0,#24
.  1052  000001818      06801  ldr       r1,[r0]
.  1054  00000181A      09A03  ldr       r2,[sp,#12]
.  1056  00000181C      06191  str       r1,[r2,#24]
    SYSTEM.GET(stackframeBase + 28, sr.xpsr);
.  1058  00000181E      09800  ldr       r0,[sp]
.  1060  000001820      0301C  adds      r0,#28
.  1062  000001822      06801  ldr       r1,[r0]
.  1064  000001824      09A03  ldr       r2,[sp,#12]
.  1066  000001826      061D1  str       r1,[r2,#28]
    sr.sp := stackframeBase
  END ReadRegisters;
.  1068  000001828      09800  ldr       r0,[sp]
.  1070  00000182A      09903  ldr       r1,[sp,#12]
.  1072  00000182C      06208  str       r0,[r1,#32]
.  1074  00000182E      0B005  add       sp,#20
.  1076  000001830      0BD00  pop       { pc }
.  1078  000001832      0BF00  nop       

END Stacktrace.
.  1080  000001834      0B500  push      { lr }
.  1082  000001836      0BD00  pop       { pc }
 