. <tool: Astrobe for RP2350>
. <prog: C:\Users\gray\Projects\oberon\dev\oberon-rtk\examples\v3.0\nxp\any\SignalSync\SignalSync.mod>

.     0  010001474              <Pad: 0>
MODULE Stacktrace;
(**
  Oberon RTK Framework
  Version: v3.0
  --
  Create stack trace amd read stack registers based on error data
  collected by run-time error handling RuntimeErrors.
  --
  MCU: MCX-N947
  --
  Copyright (c) 2020-2025 Gray, gray@grayraven.org
  Portions copyright (c) 2008-2024 CFB Software, https://www.astrobe.com
  Used with permission.
  Please refer to the licensing conditions as defined at the end of this file.
**)

  IMPORT SYSTEM, MCU := MCU2, Config, RuntimeErrors;

  CONST
    TraceDepth = 16;

    ExcRetMask = 0FFFFFF82H;
    ExcRetVal = 0FFFFFF80H;

    AnnNone* = 0;
    AnnStackframe* = -1;

    StackTraceNotLR = 0;
    StackTraceLineNo = 1;
    StackTraceNoLineNo = 2;

    (* stack context sizes *)
    StateContextSize = 8 * 4;
    (* unused
    ExtStateContextSize = 10 * 4;
    *)
    FPcontextSize = 18 * 4;

    (* register offsets from stacked r0 *)
    PSRoffset = 28;
    PCoffset = 24;
    LRoffset = 20;

    StackSeal = 0FEF5EDA5H;


    (* EXC_RETURN bits *)
    (*EXC_RET_S     = 6;*)  (* = 1: secure stack frame, faulty code was running in secure domain *)
    (*EXC_RET_DCRS  = 5;*)  (* = 0: all CPU regs stacked by hardware, extended state context *)
    EXC_RET_FType = 4;  (* = 0: all FPU regs stacked by hardware, extended FPU context *)
    (*EXC_RET_Mode  = 3; *) (* = 1: thread mode, faulty code was running in thread mode *)
    (*EXC_RET_SPSEL = 2; *) (* = 1: PSP used for stacking *)
    (*EXC_RET_ES    = 0;*)  (* = 1: exception running in secure domain *)

  TYPE
    TracePoint* = RECORD
      address*: INTEGER;
      lineNo*: INTEGER;
      stackAddr*: INTEGER;
      annotation*: INTEGER
    END;
.     4  010001478  010001478      00010  <Type:   16>
.     8  01000147C  01000147C      00000  <Type:   0>
.    12  010001480  010001480      00000  <Type:   0>
.    16  010001484  010001484      00000  <Type:   0>
.    20  010001488  010001488      00000  <Type:   0>

    Trace* = RECORD
      tp*: ARRAY TraceDepth OF TracePoint;
      count*: INTEGER;
      more*: BOOLEAN
    END;
.    24  01000148C  01000148C      00108  <Type:   264>
.    28  010001490  010001490      00000  <Type:   0>
.    32  010001494  010001494      00000  <Type:   0>
.    36  010001498  010001498      00000  <Type:   0>
.    40  01000149C  01000149C      00000  <Type:   0>

    StackedRegs* = RECORD
      r0*, r1*, r2*, r3*, r12*: INTEGER;
      lr*, pc*, xpsr*, sp*: INTEGER
    END;
.    44  0100014A0  0100014A0      00024  <Type:   36>
.    48  0100014A4  0100014A4      00000  <Type:   0>
.    52  0100014A8  0100014A8      00000  <Type:   0>
.    56  0100014AC  0100014AC      00000  <Type:   0>
.    60  0100014B0  0100014B0      00000  <Type:   0>


  (* --- Astrobe code begin --- *)

  PROCEDURE* getHalfWord(addr: INTEGER; VAR value: INTEGER);
  (* from Astrobe library, modified *)
  (* get 16-bit data from an address that is possibly not word-aligned *)
    VAR b1, b2: BYTE;
  BEGIN
.    64  0100014B4      0B500  push      { lr }
    SYSTEM.GET(addr + 1, b1);
.    66  0100014B6      01C44  adds      r4,r0,#1
.    68  0100014B8      07822  ldrb      r2,[r4]
    SYSTEM.GET(addr, b2);
.    70  0100014BA      07803  ldrb      r3,[r0]
    value := LSL(b1, 8) + b2;
.    72  0100014BC      00214  lsls      r4,r2,#8
.    74  0100014BE      0441C  add       r4,r3
.    76  0100014C0      0600C  str       r4,[r1]
  END getHalfWord;
.    78  0100014C2      0BD00  pop       { pc }

  PROCEDURE isBL(codeAddr: INTEGER): BOOLEAN;
  (* from Astrobe library *)
  (* check if the instruction at 'codeAddr' is a BL instruction: [31:27] = 11110 *)
  (* note how the 32 bit code is stored as two 16 bit values:
      addr[x]   = [31:16]
      addr[x+2] = [15:0]
    since we have little endian encoding, it's physically:
      addr[x]   = [23:16][31:24]
      addr[x+2] = [7:0][15:8]
    but the load instruction takes care of *that* conversion.
  *)
    VAR instr: INTEGER;
  BEGIN
.    80  0100014C4      0B501  push      { r0, lr }
.    82  0100014C6      0B081  sub       sp,#4
    getHalfWord(codeAddr, instr);
.    84  0100014C8      09801  ldr       r0,[sp,#4]
.    86  0100014CA      04669  mov       r1,sp
.    88  0100014CC  0F7FFFFF2  bl.w      -28 -> 64
.    92  0100014D0      0E000  b         0 -> 96
.    94  0100014D2      00064  <LineNo: 100>
    RETURN BFX(instr, 15, 11) = 01EH
.    96  0100014D4      09800  ldr       r0,[sp]
.    98  0100014D6  0F3C020C4  ubfx      r0,r0,11,5
  END isBL;
.   102  0100014DA      0281E  cmp       r0,#30
.   104  0100014DC      0BF0C  ite       eq
.   106  0100014DE  0F04F0001  moveq.w   r0,#1
.   110  0100014E2  0F04F0000  movne.w   r0,#0
.   114  0100014E6      0B002  add       sp,#8
.   116  0100014E8      0BD00  pop       { pc }
.   118  0100014EA      0BF00  nop       

  PROCEDURE isBLX(codeAddr: INTEGER): BOOLEAN;
  (* from Astrobe library, modified *)
  (* check if the instruction at 'codeAddr' is a BLX instruction: 010001111rrrr000 *)
    CONST
      BLXmask = 0FF87H; (* 1111 1111 1000 0111 *)
      BLXval  = 04780H; (* 0100 0111 1000 0000 *)
    VAR instr: INTEGER;
  BEGIN
.   120  0100014EC      0B501  push      { r0, lr }
.   122  0100014EE      0B081  sub       sp,#4
    getHalfWord(codeAddr, instr);
.   124  0100014F0      09801  ldr       r0,[sp,#4]
.   126  0100014F2      04669  mov       r1,sp
.   128  0100014F4  0F7FFFFDE  bl.w      -68 -> 64
.   132  0100014F8      0E000  b         0 -> 136
.   134  0100014FA      00070  <LineNo: 112>
    RETURN BITS(instr) * BITS(BLXmask) = BITS(BLXval)
.   136  0100014FC      09800  ldr       r0,[sp]
.   138  0100014FE  0F64F7187  movw      r1,#000FF87H
.   142  010001502      04008  ands      r0,r1
    (*RETURN (BFX(instr, 15, 7) = 08FH) & (BFX(instr, 2, 0) = 0)*)
  END isBLX;
.   144  010001504  0F2447180  movw      r1,#18304
.   148  010001508  0EA900F01  teq.w     r0,r1
.   152  01000150C      0BF0C  ite       eq
.   154  01000150E  0F04F0001  moveq.w   r0,#1
.   158  010001512  0F04F0000  movne.w   r0,#0
.   162  010001516      0B002  add       sp,#8
.   164  010001518      0BD00  pop       { pc }
.   166  01000151A      0BF00  nop       

  PROCEDURE getLR(stackAddr: INTEGER; VAR lr, res: INTEGER);
  (* from Astrobe library, modified *)
  (* Check if the value at 'stackAddr' on the stack is a link register address.
  If yes, it will point to a code address (+1 for thumb mode) which
  is preceded by a BL or BLX instruction. *)
    VAR nextInstr: INTEGER;
  BEGIN
.   168  01000151C      0B507  push      { r0, r1, r2, lr }
.   170  01000151E      0B081  sub       sp,#4
    res := StackTraceNotLR;
.   172  010001520      02000  movs      r0,#0
.   174  010001522      09903  ldr       r1,[sp,#12]
.   176  010001524      06008  str       r0,[r1]
    SYSTEM.GET(stackAddr, lr);
.   178  010001526      09801  ldr       r0,[sp,#4]
.   180  010001528      06801  ldr       r1,[r0]
.   182  01000152A      09A02  ldr       r2,[sp,#8]
.   184  01000152C      06011  str       r1,[r2]
    (* must be Thumb mode *)
    IF ODD(lr) THEN
.   186  01000152E      09802  ldr       r0,[sp,#8]
.   188  010001530      06800  ldr       r0,[r0]
.   190  010001532  0F0100F01  tst.w     r0,#1
.   194  010001536  0F0008040  beq.w     128 -> 326
      DEC(lr, 1);
.   198  01000153A      09802  ldr       r0,[sp,#8]
.   200  01000153C      06801  ldr       r1,[r0]
.   202  01000153E      03901  subs      r1,#1
.   204  010001540      06001  str       r1,[r0]
      IF (lr >= Config.CodeMem.start + 100H) & (lr < Config.CodeMem.end) THEN
.   206  010001542  0F8DF007C  ldr.w     r0,[pc,#124] -> 332
.   210  010001546      06800  ldr       r0,[r0]
.   212  010001548  0F5007080  add.w     r0,r0,#256
.   216  01000154C      09902  ldr       r1,[sp,#8]
.   218  01000154E      06809  ldr       r1,[r1]
.   220  010001550      04281  cmp       r1,r0
.   222  010001552  0F2C08032  blt.w     100 -> 326
.   226  010001556  0F8DF0068  ldr.w     r0,[pc,#104] -> 332
.   230  01000155A      09902  ldr       r1,[sp,#8]
.   232  01000155C      06809  ldr       r1,[r1]
.   234  01000155E      06840  ldr       r0,[r0,#4]
.   236  010001560      04281  cmp       r1,r0
.   238  010001562  0F280802A  bge.w     84 -> 326
        IF isBL(lr - 4) OR isBLX(lr - 2) THEN
.   242  010001566      09802  ldr       r0,[sp,#8]
.   244  010001568      06800  ldr       r0,[r0]
.   246  01000156A      03804  subs      r0,#4
.   248  01000156C  0F7FFFFAA  bl.w      -172 -> 80
.   252  010001570      0E000  b         0 -> 256
.   254  010001572      00082  <LineNo: 130>
.   256  010001574  0F0100F01  tst.w     r0,#1
.   260  010001578  0F040800B  bne.w     22 -> 286
.   264  01000157C      09802  ldr       r0,[sp,#8]
.   266  01000157E      06800  ldr       r0,[r0]
.   268  010001580      03802  subs      r0,#2
.   270  010001582  0F7FFFFB3  bl.w      -154 -> 120
.   274  010001586      0E000  b         0 -> 278
.   276  010001588      00082  <LineNo: 130>
.   278  01000158A  0F0100F01  tst.w     r0,#1
.   282  01000158E  0F0008014  beq.w     40 -> 326
          getHalfWord(lr, nextInstr);
.   286  010001592      09802  ldr       r0,[sp,#8]
.   288  010001594      06800  ldr       r0,[r0]
.   290  010001596      04669  mov       r1,sp
.   292  010001598  0F7FFFF8C  bl.w      -232 -> 64
.   296  01000159C      0E000  b         0 -> 300
.   298  01000159E      00083  <LineNo: 131>
          (* if stack trace is enabled there is a B,0 instruction (0E0000H)
          that skips the line number after the BL or BLX instruction *)
          IF nextInstr = 0E000H THEN
.   300  0100015A0      09800  ldr       r0,[sp]
.   302  0100015A2  0F5B04F60  cmp.w     r0,#000E000H
.   306  0100015A6  0F0408005  bne.w     10 -> 320
            res := StackTraceLineNo
          ELSE
.   310  0100015AA      02001  movs      r0,#1
.   312  0100015AC      09903  ldr       r1,[sp,#12]
.   314  0100015AE      06008  str       r0,[r1]
            res := StackTraceNoLineNo
.   316  0100015B0  0F000B803  b.w       6 -> 326
          END
.   320  0100015B4      02002  movs      r0,#2
.   322  0100015B6      09903  ldr       r1,[sp,#12]
.   324  0100015B8      06008  str       r0,[r1]
        END
      END
    END
  END getLR;
.   326  0100015BA      0B004  add       sp,#16
.   328  0100015BC      0BD00  pop       { pc }
.   330  0100015BE      0BF00  nop       
.   332  0100015C0  02001FFA8  <Global: Config data>

  (* --- Astrobe code end --- *)

  PROCEDURE* traceStart(stackframeBase, excRetVal: INTEGER): INTEGER;
    CONST StackAlign = 9; (* in stacked PSR *)
    VAR startAddr: INTEGER;
  BEGIN
.   336  0100015C4      0B500  push      { lr }
    startAddr := stackframeBase + StateContextSize;
.   338  0100015C6  0F1000220  add.w     r2,r0,#32
    IF ~(EXC_RET_FType IN BITS(excRetVal)) THEN (* FP context *)
.   342  0100015CA  0F0110F10  tst.w     r1,#16
.   346  0100015CE  0F0408002  bne.w     4 -> 354
      startAddr := startAddr + FPcontextSize
    END;
.   350  0100015D2  0F1020248  add.w     r2,r2,#72
    IF SYSTEM.BIT(stackframeBase + PSRoffset, StackAlign) THEN
.   354  0100015D6  0F100031C  add.w     r3,r0,#28
.   358  0100015DA      0681C  ldr       r4,[r3]
.   360  0100015DC      005A4  lsls      r4,r4,#22
.   362  0100015DE  0F1408001  bpl.w     2 -> 368
      INC(startAddr, 4)
    END
.   366  0100015E2      03204  adds      r2,#4
    RETURN startAddr
  END traceStart;
.   368  0100015E4      04610  mov       r0,r2
.   370  0100015E6      0BD00  pop       { pc }


  PROCEDURE getAddr(VAR stackAddr, excRetVal: INTEGER; VAR isStackFrame: BOOLEAN);
    CONST R11 = 11;
    VAR stackVal, lr, res: INTEGER;
  BEGIN
.   372  0100015E8      0B507  push      { r0, r1, r2, lr }
.   374  0100015EA      0B083  sub       sp,#12
    isStackFrame := FALSE;
.   376  0100015EC      02000  movs      r0,#0
.   378  0100015EE      09905  ldr       r1,[sp,#20]
.   380  0100015F0      07008  strb      r0,[r1]
    SYSTEM.GET(stackAddr, stackVal);
.   382  0100015F2      09803  ldr       r0,[sp,#12]
.   384  0100015F4      06800  ldr       r0,[r0]
.   386  0100015F6      06801  ldr       r1,[r0]
.   388  0100015F8      09100  str       r1,[sp]
    IF BITS(stackVal) * BITS(ExcRetMask) = BITS(ExcRetVal) THEN
.   390  0100015FA      09800  ldr       r0,[sp]
.   392  0100015FC  0F06F017D  mvn.w     r1,#125
.   396  010001600      04008  ands      r0,r1
.   398  010001602  0F06F017F  mvn.w     r1,#127
.   402  010001606  0EA900F01  teq.w     r0,r1
.   406  01000160A  0F040804A  bne.w     148 -> 558
      (* if a potential EXC_RETURN value *)
      excRetVal := stackVal; (* only valid if 'isStackFrame' *)
.   410  01000160E      09800  ldr       r0,[sp]
.   412  010001610      09904  ldr       r1,[sp,#16]
.   414  010001612      06008  str       r0,[r1]
      SYSTEM.GET(stackAddr + 4, stackVal);
.   416  010001614      09803  ldr       r0,[sp,#12]
.   418  010001616      06800  ldr       r0,[r0]
.   420  010001618      03004  adds      r0,#4
.   422  01000161A      06801  ldr       r1,[r0]
.   424  01000161C      09100  str       r1,[sp]
      IF stackVal = StackSeal THEN
.   426  01000161E      09800  ldr       r0,[sp]
.   428  010001620  0F8DF1084  ldr.w     r1,[pc,#132] -> 564
.   432  010001624      042C8  cmn       r0,r1
.   434  010001626  0F040800A  bne.w     20 -> 458
        (* at top of main stack: we have an EXC_RETURN value with 'PSP used for stacking' *)
        (* switch stacks, point to stacked regs on process stack *)
        SYSTEM.EMIT(MCU.MRS_R11_PSP);
.   438  01000162A  0F3EF8B09  .word     0x8B09F3EF /* EMIT */
        stackAddr := SYSTEM.REG(R11);
.   442  01000162E      04658  mov       r0,r11
.   444  010001630      09903  ldr       r1,[sp,#12]
.   446  010001632      06008  str       r0,[r1]
        isStackFrame := TRUE
      ELSE
.   448  010001634      02001  movs      r0,#1
.   450  010001636      09905  ldr       r1,[sp,#20]
.   452  010001638      07008  strb      r0,[r1]
        (* point to potential stack frame on main stack*)
        INC(stackAddr, 4);
.   454  01000163A  0F000B832  b.w       100 -> 558
.   458  01000163E      09803  ldr       r0,[sp,#12]
.   460  010001640      06801  ldr       r1,[r0]
.   462  010001642      03104  adds      r1,#4
.   464  010001644      06001  str       r1,[r0]
        (* stacked value at LRoffset must be either a valid LR value... *)
        getLR(stackAddr + LRoffset, lr, res);
.   466  010001646      09803  ldr       r0,[sp,#12]
.   468  010001648      06800  ldr       r0,[r0]
.   470  01000164A      03014  adds      r0,#20
.   472  01000164C  0F11D0104  adds.w    r1,sp,#4
.   476  010001650  0F11D0208  adds.w    r2,sp,#8
.   480  010001654  0F7FFFF62  bl.w      -316 -> 168
.   484  010001658      0E000  b         0 -> 488
.   486  01000165A      000B5  <LineNo: 181>
        isStackFrame := res > StackTraceNotLR;
.   488  01000165C      09802  ldr       r0,[sp,#8]
.   490  01000165E      02800  cmp       r0,#0
.   492  010001660      0BFCC  ite       gt
.   494  010001662  0F04F0001  movgt.w   r0,#1
.   498  010001666  0F04F0000  movle.w   r0,#0
.   502  01000166A      09905  ldr       r1,[sp,#20]
.   504  01000166C      07008  strb      r0,[r1]
        (* ... or an EXC_RETURN value *)
        IF ~isStackFrame THEN
.   506  01000166E      09805  ldr       r0,[sp,#20]
.   508  010001670      07800  ldrb      r0,[r0]
.   510  010001672  0F0100F01  tst.w     r0,#1
.   514  010001676  0F0408014  bne.w     40 -> 558
          SYSTEM.GET(stackAddr + LRoffset, stackVal);
.   518  01000167A      09803  ldr       r0,[sp,#12]
.   520  01000167C      06800  ldr       r0,[r0]
.   522  01000167E      03014  adds      r0,#20
.   524  010001680      06801  ldr       r1,[r0]
.   526  010001682      09100  str       r1,[sp]
          isStackFrame := BITS(stackVal) * BITS(ExcRetMask) = BITS(ExcRetVal)
.   528  010001684      09800  ldr       r0,[sp]
.   530  010001686  0F06F017D  mvn.w     r1,#125
.   534  01000168A      04008  ands      r0,r1
        END
.   536  01000168C  0F06F017F  mvn.w     r1,#127
.   540  010001690  0EA900F01  teq.w     r0,r1
.   544  010001694      0BF0C  ite       eq
.   546  010001696  0F04F0001  moveq.w   r0,#1
.   550  01000169A  0F04F0000  movne.w   r0,#0
.   554  01000169E      09905  ldr       r1,[sp,#20]
.   556  0100016A0      07008  strb      r0,[r1]
      END
    END;

  END getAddr;
.   558  0100016A2      0B006  add       sp,#24
.   560  0100016A4      0BD00  pop       { pc }
.   562  0100016A6      0BF00  nop       
.   564  0100016A8  0010A125B  <Const:  17437275>


  PROCEDURE stacktrace(stackAddr: INTEGER; VAR trace: Trace);
    VAR
      stackVal, retAddr, excRetVal, res, lr, traceDepth: INTEGER;
      (*addr, val: INTEGER; (* debug *)*)
      tp: TracePoint; isStackFrame: BOOLEAN;
  BEGIN
.   568  0100016AC      0B507  push      { r0, r1, r2, lr }
.   570  0100016AE      0B08B  sub       sp,#44
    CLEAR(tp);
.   572  0100016B0  0F11D0018  adds.w    r0,sp,#24
.   576  0100016B4      02100  movs      r1,#0
.   578  0100016B6      02204  movs      r2,#4
.   580  0100016B8  0F8401B04  str.w     r1,[r0],#4
.   584  0100016BC      03A01  subs      r2,#1
.   586  0100016BE      0DCFB  bgt.n     -10 -> 580
    traceDepth := LEN(trace.tp);
.   588  0100016C0      02010  movs      r0,#16
.   590  0100016C2      09005  str       r0,[sp,#20]
    SYSTEM.GET(stackAddr, stackVal);
.   592  0100016C4      0980B  ldr       r0,[sp,#44]
.   594  0100016C6      06801  ldr       r1,[r0]
.   596  0100016C8      09100  str       r1,[sp]
    WHILE (stackVal # StackSeal) & (trace.count <= traceDepth) DO
.   598  0100016CA      09800  ldr       r0,[sp]
.   600  0100016CC  0F8DF1114  ldr.w     r1,[pc,#276] -> 880
.   604  0100016D0      042C8  cmn       r0,r1
.   606  0100016D2  0F0008084  beq.w     264 -> 874
.   610  0100016D6      0980C  ldr       r0,[sp,#48]
.   612  0100016D8  0F8D00100  ldr.w     r0,[r0,#256]
.   616  0100016DC      09905  ldr       r1,[sp,#20]
.   618  0100016DE      04288  cmp       r0,r1
.   620  0100016E0  0F300807D  bgt.w     250 -> 874
      (* debug *)
      (*
      Out.Hex(stackAddr, 13); Out.Hex(stackVal, 13); Out.Ln;
      *)
      (* debug end *)
      getAddr(stackAddr, excRetVal, isStackFrame);
.   624  0100016E4  0F11D002C  adds.w    r0,sp,#44
.   628  0100016E8  0F11D0108  adds.w    r1,sp,#8
.   632  0100016EC  0F11D0228  adds.w    r2,sp,#40
.   636  0100016F0  0F7FFFF7A  bl.w      -268 -> 372
.   640  0100016F4      0E000  b         0 -> 644
.   642  0100016F6      000D1  <LineNo: 209>
      IF isStackFrame THEN
.   644  0100016F8  0F89D0028  ldrb.w    r0,[sp,#40]
.   648  0100016FC  0F0100F01  tst.w     r0,#1
.   652  010001700  0F0008014  beq.w     40 -> 696
        SYSTEM.GET(stackAddr + PCoffset, retAddr);
.   656  010001704      0980B  ldr       r0,[sp,#44]
.   658  010001706      03018  adds      r0,#24
.   660  010001708      06801  ldr       r1,[r0]
.   662  01000170A      09101  str       r1,[sp,#4]
        tp.address := retAddr;
.   664  01000170C      09801  ldr       r0,[sp,#4]
.   666  01000170E      09006  str       r0,[sp,#24]
        tp.annotation := AnnStackframe;
.   668  010001710  0F8DF00D4  ldr.w     r0,[pc,#212] -> 884
.   672  010001714      09009  str       r0,[sp,#36]
        tp.stackAddr := stackAddr;
.   674  010001716      0980B  ldr       r0,[sp,#44]
.   676  010001718      09008  str       r0,[sp,#32]
        (* addr := stackAddr; (* debug *) *)
        stackAddr := traceStart(stackAddr, excRetVal);
.   678  01000171A      0980B  ldr       r0,[sp,#44]
.   680  01000171C      09902  ldr       r1,[sp,#8]
.   682  01000171E  0F7FFFF51  bl.w      -350 -> 336
.   686  010001722      0E000  b         0 -> 690
.   688  010001724      000D8  <LineNo: 216>
.   690  010001726      0900B  str       r0,[sp,#44]
        (* debug: print stack dump *)
        (*
        WHILE addr < stackAddr DO
          SYSTEM.GET(addr, val);
          Out.String("> "); Out.Hex(addr, 13); Out.Hex(val, 13); Out.Ln;
          INC(addr, 4)
        END
        *)
        (* debug end *)
      ELSE
        getLR(stackAddr, lr, res);
.   692  010001728  0F000B821  b.w       66 -> 762
.   696  01000172C      0980B  ldr       r0,[sp,#44]
.   698  01000172E  0F11D0110  adds.w    r1,sp,#16
.   702  010001732  0F11D020C  adds.w    r2,sp,#12
.   706  010001736  0F7FFFEF1  bl.w      -542 -> 168
.   710  01000173A      0E000  b         0 -> 714
.   712  01000173C      000E3  <LineNo: 227>
        IF res > StackTraceNotLR THEN
.   714  01000173E      09803  ldr       r0,[sp,#12]
.   716  010001740      02800  cmp       r0,#0
.   718  010001742  0F3408011  ble.w     34 -> 756
          tp.address := lr - 4;
.   722  010001746      09804  ldr       r0,[sp,#16]
.   724  010001748      03804  subs      r0,#4
.   726  01000174A      09006  str       r0,[sp,#24]
          tp.stackAddr := stackAddr;
.   728  01000174C      0980B  ldr       r0,[sp,#44]
.   730  01000174E      09008  str       r0,[sp,#32]
          IF res = StackTraceLineNo THEN
.   732  010001750      09803  ldr       r0,[sp,#12]
.   734  010001752      02801  cmp       r0,#1
.   736  010001754  0F0408008  bne.w     16 -> 756
            getHalfWord(lr + 2, tp.lineNo)
.   740  010001758      09804  ldr       r0,[sp,#16]
.   742  01000175A      03002  adds      r0,#2
.   744  01000175C  0F11D011C  adds.w    r1,sp,#28
          END
.   748  010001760  0F7FFFEA8  bl.w      -688 -> 64
.   752  010001764      0E000  b         0 -> 756
.   754  010001766      000E8  <LineNo: 232>
        END;
        INC(stackAddr, 4)
      END;
.   756  010001768      0980B  ldr       r0,[sp,#44]
.   758  01000176A      03004  adds      r0,#4
.   760  01000176C      0900B  str       r0,[sp,#44]
      IF tp.address # 0 THEN (* tp is valid *)
.   762  01000176E      09806  ldr       r0,[sp,#24]
.   764  010001770      02800  cmp       r0,#0
.   766  010001772  0F000802F  beq.w     94 -> 864
        IF trace.count < TraceDepth THEN
.   770  010001776      0980C  ldr       r0,[sp,#48]
.   772  010001778  0F8D00100  ldr.w     r0,[r0,#256]
.   776  01000177C      02810  cmp       r0,#16
.   778  01000177E  0F2808025  bge.w     74 -> 856
          trace.tp[trace.count] := tp;
.   782  010001782      0980C  ldr       r0,[sp,#48]
.   784  010001784  0F8D00100  ldr.w     r0,[r0,#256]
.   788  010001788      02810  cmp       r0,#16
.   790  01000178A      0D301  bcc.n     2 -> 796
.   792  01000178C      0DF01  svc       1
.   794  01000178E      000EF  <LineNo: 239>
.   796  010001790      0990C  ldr       r1,[sp,#48]
.   798  010001792      00102  lsls      r2,r0,#4
.   800  010001794  0EB020001  add.w     r0,r2,r1
.   804  010001798      02104  movs      r1,#4
.   806  01000179A  0F11D0218  adds.w    r2,sp,#24
.   810  01000179E  0F8523B04  ldr.w     r3,[r2],#4
.   814  0100017A2  0F8403B04  str.w     r3,[r0],#4
.   818  0100017A6      03901  subs      r1,#1
.   820  0100017A8      0D1F9  bne.n     -14 -> 810
          INC(trace.count);
.   822  0100017AA      0980C  ldr       r0,[sp,#48]
.   824  0100017AC  0F8D01100  ldr.w     r1,[r0,#256]
.   828  0100017B0      03101  adds      r1,#1
.   830  0100017B2  0F8C01100  str.w     r1,[r0,#256]
          CLEAR(tp)
        ELSE
.   834  0100017B6  0F11D0018  adds.w    r0,sp,#24
.   838  0100017BA      02100  movs      r1,#0
.   840  0100017BC      02204  movs      r2,#4
.   842  0100017BE      0BF00  nop       
.   844  0100017C0  0F8401B04  str.w     r1,[r0],#4
.   848  0100017C4      03A01  subs      r2,#1
.   850  0100017C6      0DCFB  bgt.n     -10 -> 844
          trace.more := TRUE
.   852  0100017C8  0F000B804  b.w       8 -> 864
        END
.   856  0100017CC      02001  movs      r0,#1
.   858  0100017CE      0990C  ldr       r1,[sp,#48]
.   860  0100017D0  0F8810104  strb.w    r0,[r1,#260]
      END;
      SYSTEM.GET(stackAddr, stackVal);
.   864  0100017D4      0980B  ldr       r0,[sp,#44]
.   866  0100017D6      06801  ldr       r1,[r0]
.   868  0100017D8      09100  str       r1,[sp]
    END
.   870  0100017DA  0F7FFBF76  b.w       -276 -> 598
  END stacktrace;
.   874  0100017DE      0B00E  add       sp,#56
.   876  0100017E0      0BD00  pop       { pc }
.   878  0100017E2      0BF00  nop       
.   880  0100017E4  0010A125B  <Const:  17437275>
.   884  0100017E8  0FFFFFFFF  <Const:  -1>


  PROCEDURE CreateTrace*(er: RuntimeErrors.ErrorDesc; VAR tr: Trace);
    VAR tp: TracePoint;
  BEGIN
.   888  0100017EC      0B50F  push      { r0, r1, r2, r3, lr }
.   890  0100017EE      0B084  sub       sp,#16
    tp.address := er.errAddr;
.   892  0100017F0      09804  ldr       r0,[sp,#16]
.   894  0100017F2      06840  ldr       r0,[r0,#4]
.   896  0100017F4      09000  str       r0,[sp]
    tp.lineNo := er.errLineNo;
.   898  0100017F6      09804  ldr       r0,[sp,#16]
.   900  0100017F8      06880  ldr       r0,[r0,#8]
.   902  0100017FA      09001  str       r0,[sp,#4]
    tp.stackAddr := 0;
.   904  0100017FC      02000  movs      r0,#0
.   906  0100017FE      09002  str       r0,[sp,#8]
    tp.annotation := 0;
.   908  010001800      02000  movs      r0,#0
.   910  010001802      09003  str       r0,[sp,#12]
    tr.tp[0] := tp;
.   912  010001804      02004  movs      r0,#4
.   914  010001806      09906  ldr       r1,[sp,#24]
.   916  010001808      0466A  mov       r2,sp
.   918  01000180A  0F8523B04  ldr.w     r3,[r2],#4
.   922  01000180E  0F8413B04  str.w     r3,[r1],#4
.   926  010001812      03801  subs      r0,#1
.   928  010001814      0D1F9  bne.n     -14 -> 918
    tr.count := 1;
.   930  010001816      02001  movs      r0,#1
.   932  010001818      09906  ldr       r1,[sp,#24]
.   934  01000181A  0F8C10100  str.w     r0,[r1,#256]
    tr.more := FALSE;
.   938  01000181E      02000  movs      r0,#0
.   940  010001820      09906  ldr       r1,[sp,#24]
.   942  010001822  0F8810104  strb.w    r0,[r1,#260]
    stacktrace(traceStart(er.stackframeBase, er.excRetVal), tr)
.   946  010001826      09804  ldr       r0,[sp,#16]
.   948  010001828      068C0  ldr       r0,[r0,#12]
.   950  01000182A      09904  ldr       r1,[sp,#16]
.   952  01000182C      06909  ldr       r1,[r1,#16]
.   954  01000182E  0F7FFFEC9  bl.w      -622 -> 336
.   958  010001832      0E000  b         0 -> 962
.   960  010001834      00105  <LineNo: 261>
.   962  010001836      09906  ldr       r1,[sp,#24]
.   964  010001838      09A07  ldr       r2,[sp,#28]
  END CreateTrace;
.   966  01000183A  0F7FFFF37  bl.w      -402 -> 568
.   970  01000183E      0E000  b         0 -> 974
.   972  010001840      00105  <LineNo: 261>
.   974  010001842      0B008  add       sp,#32
.   976  010001844      0BD00  pop       { pc }
.   978  010001846      0BF00  nop       


  PROCEDURE ReadRegisters*(er: RuntimeErrors.ErrorDesc; VAR sr: StackedRegs);
    VAR stackframeBase: INTEGER;
  BEGIN
.   980  010001848      0B50F  push      { r0, r1, r2, r3, lr }
.   982  01000184A      0B081  sub       sp,#4
    stackframeBase := er.stackframeBase;
.   984  01000184C      09801  ldr       r0,[sp,#4]
.   986  01000184E      068C0  ldr       r0,[r0,#12]
.   988  010001850      09000  str       r0,[sp]
    SYSTEM.GET(stackframeBase, sr.r0);
.   990  010001852      09800  ldr       r0,[sp]
.   992  010001854      06801  ldr       r1,[r0]
.   994  010001856      09A03  ldr       r2,[sp,#12]
.   996  010001858      06011  str       r1,[r2]
    SYSTEM.GET(stackframeBase + 4, sr.r1);
.   998  01000185A      09800  ldr       r0,[sp]
.  1000  01000185C      03004  adds      r0,#4
.  1002  01000185E      06801  ldr       r1,[r0]
.  1004  010001860      09A03  ldr       r2,[sp,#12]
.  1006  010001862      06051  str       r1,[r2,#4]
    SYSTEM.GET(stackframeBase + 8, sr.r2);
.  1008  010001864      09800  ldr       r0,[sp]
.  1010  010001866      03008  adds      r0,#8
.  1012  010001868      06801  ldr       r1,[r0]
.  1014  01000186A      09A03  ldr       r2,[sp,#12]
.  1016  01000186C      06091  str       r1,[r2,#8]
    SYSTEM.GET(stackframeBase + 12, sr.r3);
.  1018  01000186E      09800  ldr       r0,[sp]
.  1020  010001870      0300C  adds      r0,#12
.  1022  010001872      06801  ldr       r1,[r0]
.  1024  010001874      09A03  ldr       r2,[sp,#12]
.  1026  010001876      060D1  str       r1,[r2,#12]
    SYSTEM.GET(stackframeBase + 16, sr.r12);
.  1028  010001878      09800  ldr       r0,[sp]
.  1030  01000187A      03010  adds      r0,#16
.  1032  01000187C      06801  ldr       r1,[r0]
.  1034  01000187E      09A03  ldr       r2,[sp,#12]
.  1036  010001880      06111  str       r1,[r2,#16]
    SYSTEM.GET(stackframeBase + 20, sr.lr);
.  1038  010001882      09800  ldr       r0,[sp]
.  1040  010001884      03014  adds      r0,#20
.  1042  010001886      06801  ldr       r1,[r0]
.  1044  010001888      09A03  ldr       r2,[sp,#12]
.  1046  01000188A      06151  str       r1,[r2,#20]
    SYSTEM.GET(stackframeBase + 24, sr.pc);
.  1048  01000188C      09800  ldr       r0,[sp]
.  1050  01000188E      03018  adds      r0,#24
.  1052  010001890      06801  ldr       r1,[r0]
.  1054  010001892      09A03  ldr       r2,[sp,#12]
.  1056  010001894      06191  str       r1,[r2,#24]
    SYSTEM.GET(stackframeBase + 28, sr.xpsr);
.  1058  010001896      09800  ldr       r0,[sp]
.  1060  010001898      0301C  adds      r0,#28
.  1062  01000189A      06801  ldr       r1,[r0]
.  1064  01000189C      09A03  ldr       r2,[sp,#12]
.  1066  01000189E      061D1  str       r1,[r2,#28]
    sr.sp := stackframeBase
  END ReadRegisters;
.  1068  0100018A0      09800  ldr       r0,[sp]
.  1070  0100018A2      09903  ldr       r1,[sp,#12]
.  1072  0100018A4      06208  str       r0,[r1,#32]
.  1074  0100018A6      0B005  add       sp,#20
.  1076  0100018A8      0BD00  pop       { pc }
.  1078  0100018AA      0BF00  nop       

END Stacktrace.
.  1080  0100018AC      0B500  push      { lr }
.  1082  0100018AE      0BD00  pop       { pc }
 