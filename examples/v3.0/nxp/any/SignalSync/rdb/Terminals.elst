. <tool: Astrobe for RP2350>
. <prog: C:\Users\gray\Projects\oberon\dev\oberon-rtk\examples\v3.0\nxp\any\SignalSync\SignalSync.mod>

.     0  010003C10              <Pad: 0>
MODULE Terminals;
(**
  Oberon RTK Framework
  Version: v3.0
  --
  Max two text terminals via TextIO.Device, eg. UART
  --
  Use module Texts to write/read to/from any open terminal
  See module Out for a use case
  Each terminal can only be opened once.
  --
  MCU: MCXA346, MCXN947
  --
  Copyright (c) 2020-2025 Gray gray@grayraven.org
  https://oberon-rtk.org/licences/
**)

  IMPORT TextIO, UART, Errors;

  CONST
    TERM0* = 0;
    TERM1* = 1;
    NumTerms = 2;

  TYPE
    Ws* = ARRAY NumTerms OF TextIO.Writer;
    Rs* = ARRAY NumTerms OF TextIO.Reader;

  VAR
    W*, Werr*: Ws;
    R*: Rs;


  PROCEDURE InitUART*(uartNo: INTEGER; uartCfg: UART.DeviceCfg; baudrate: INTEGER; VAR dev: UART.Device);
  (* utility procedure *)
  BEGIN
.     4  010003C14      0B51F  push      { r0, r1, r2, r3, r4, lr }
    NEW(dev); ASSERT(dev # NIL, Errors.HeapOverflow);
.     6  010003C16      09804  ldr       r0,[sp,#16]
.     8  010003C18  0F8DF1044  ldr.w     r1,[pc,#68] -> 80
.    12  010003C1C  0F7FCFE50  bl.w      Ext Proc #1
.    16  010003C20      0E000  b         0 -> 20
.    18  010003C22      00025  <LineNo: 37>
.    20  010003C24      09804  ldr       r0,[sp,#16]
.    22  010003C26      06800  ldr       r0,[r0]
.    24  010003C28      02800  cmp       r0,#0
.    26  010003C2A      0D101  bne.n     2 -> 32
.    28  010003C2C      0DF29  svc       41
.    30  010003C2E      00025  <LineNo: 37>
    UART.Init(dev, uartNo);
.    32  010003C30      09804  ldr       r0,[sp,#16]
.    34  010003C32      06800  ldr       r0,[r0]
.    36  010003C34      09900  ldr       r1,[sp]
.    38  010003C36  0F7FFFED7  bl.w      Ext Proc #3
.    42  010003C3A      0E000  b         0 -> 46
.    44  010003C3C      00026  <LineNo: 38>
    UART.Configure(dev, uartCfg, baudrate);
.    46  010003C3E      09804  ldr       r0,[sp,#16]
.    48  010003C40      06800  ldr       r0,[r0]
.    50  010003C42      09901  ldr       r1,[sp,#4]
.    52  010003C44      09A02  ldr       r2,[sp,#8]
.    54  010003C46      09B03  ldr       r3,[sp,#12]
.    56  010003C48  0F7FFFF2C  bl.w      Ext Proc #4
.    60  010003C4C      0E000  b         0 -> 64
.    62  010003C4E      00027  <LineNo: 39>
    UART.Enable(dev)
.    64  010003C50      09804  ldr       r0,[sp,#16]
.    66  010003C52      06800  ldr       r0,[r0]
  END InitUART;
.    68  010003C54  0F7FFFFD0  bl.w      Ext Proc #6
.    72  010003C58      0E000  b         0 -> 76
.    74  010003C5A      00028  <LineNo: 40>
.    76  010003C5C      0B005  add       sp,#20
.    78  010003C5E      0BD00  pop       { pc }
.    80  010003C60  0100039C0  <Global: UART code>


  PROCEDURE Open*(termNo: INTEGER; dev: TextIO.Device; psp: TextIO.PutStringProc; gsp: TextIO.GetStringProc);
  BEGIN
.    84  010003C64      0B50F  push      { r0, r1, r2, r3, lr }
    ASSERT(termNo IN {TERM0, TERM1}, Errors.PreCond);
.    86  010003C66      02003  movs      r0,#3
.    88  010003C68      09900  ldr       r1,[sp]
.    90  010003C6A      02201  movs      r2,#1
.    92  010003C6C      0408A  lsls      r2,r1
.    94  010003C6E  0EA100F02  tst.w     r0,r2
.    98  010003C72      0D101  bne.n     2 -> 104
.   100  010003C74      0DF22  svc       34
.   102  010003C76      0002E  <LineNo: 46>
    ASSERT(dev # NIL, Errors.PreCond);
.   104  010003C78      09801  ldr       r0,[sp,#4]
.   106  010003C7A      02800  cmp       r0,#0
.   108  010003C7C      0D101  bne.n     2 -> 114
.   110  010003C7E      0DF22  svc       34
.   112  010003C80      0002F  <LineNo: 47>
    IF W[termNo] = NIL THEN
.   114  010003C82      09800  ldr       r0,[sp]
.   116  010003C84      02802  cmp       r0,#2
.   118  010003C86      0D301  bcc.n     2 -> 124
.   120  010003C88      0DF01  svc       1
.   122  010003C8A      00030  <LineNo: 48>
.   124  010003C8C  0F8DF10DC  ldr.w     r1,[pc,#220] -> 348
.   128  010003C90      00082  lsls      r2,r0,#2
.   130  010003C92  0EB020001  add.w     r0,r2,r1
.   134  010003C96      06800  ldr       r0,[r0]
.   136  010003C98      02800  cmp       r0,#0
.   138  010003C9A  0F0408060  bne.w     192 -> 334
      NEW(W[termNo]); ASSERT(W[termNo] # NIL, Errors.HeapOverflow);
.   142  010003C9E      09800  ldr       r0,[sp]
.   144  010003CA0      02802  cmp       r0,#2
.   146  010003CA2      0D301  bcc.n     2 -> 152
.   148  010003CA4      0DF01  svc       1
.   150  010003CA6      00031  <LineNo: 49>
.   152  010003CA8  0F8DF10C0  ldr.w     r1,[pc,#192] -> 348
.   156  010003CAC      00082  lsls      r2,r0,#2
.   158  010003CAE  0EB020001  add.w     r0,r2,r1
.   162  010003CB2  0F8DF10B0  ldr.w     r1,[pc,#176] -> 340
.   166  010003CB6  0F7FCFE03  bl.w      Ext Proc #1
.   170  010003CBA      0E000  b         0 -> 174
.   172  010003CBC      00031  <LineNo: 49>
.   174  010003CBE      09800  ldr       r0,[sp]
.   176  010003CC0      02802  cmp       r0,#2
.   178  010003CC2      0D301  bcc.n     2 -> 184
.   180  010003CC4      0DF01  svc       1
.   182  010003CC6      00031  <LineNo: 49>
.   184  010003CC8  0F8DF10A0  ldr.w     r1,[pc,#160] -> 348
.   188  010003CCC      00082  lsls      r2,r0,#2
.   190  010003CCE  0EB020001  add.w     r0,r2,r1
.   194  010003CD2      06800  ldr       r0,[r0]
.   196  010003CD4      02800  cmp       r0,#0
.   198  010003CD6      0D101  bne.n     2 -> 204
.   200  010003CD8      0DF29  svc       41
.   202  010003CDA      00031  <LineNo: 49>
      NEW(R[termNo]); ASSERT(R[termNo] # NIL, Errors.HeapOverflow);
.   204  010003CDC      09800  ldr       r0,[sp]
.   206  010003CDE      02802  cmp       r0,#2
.   208  010003CE0      0D301  bcc.n     2 -> 214
.   210  010003CE2      0DF01  svc       1
.   212  010003CE4      00032  <LineNo: 50>
.   214  010003CE6  0F8DF1088  ldr.w     r1,[pc,#136] -> 352
.   218  010003CEA      00082  lsls      r2,r0,#2
.   220  010003CEC  0EB020001  add.w     r0,r2,r1
.   224  010003CF0  0F8DF1074  ldr.w     r1,[pc,#116] -> 344
.   228  010003CF4  0F7FCFDE4  bl.w      Ext Proc #1
.   232  010003CF8      0E000  b         0 -> 236
.   234  010003CFA      00032  <LineNo: 50>
.   236  010003CFC      09800  ldr       r0,[sp]
.   238  010003CFE      02802  cmp       r0,#2
.   240  010003D00      0D301  bcc.n     2 -> 246
.   242  010003D02      0DF01  svc       1
.   244  010003D04      00032  <LineNo: 50>
.   246  010003D06  0F8DF1068  ldr.w     r1,[pc,#104] -> 352
.   250  010003D0A      00082  lsls      r2,r0,#2
.   252  010003D0C  0EB020001  add.w     r0,r2,r1
.   256  010003D10      06800  ldr       r0,[r0]
.   258  010003D12      02800  cmp       r0,#0
.   260  010003D14      0D101  bne.n     2 -> 266
.   262  010003D16      0DF29  svc       41
.   264  010003D18      00032  <LineNo: 50>
      TextIO.OpenWriter(W[termNo], dev, psp);
.   266  010003D1A      09800  ldr       r0,[sp]
.   268  010003D1C      02802  cmp       r0,#2
.   270  010003D1E      0D301  bcc.n     2 -> 276
.   272  010003D20      0DF01  svc       1
.   274  010003D22      00033  <LineNo: 51>
.   276  010003D24  0F8DF1044  ldr.w     r1,[pc,#68] -> 348
.   280  010003D28      00082  lsls      r2,r0,#2
.   282  010003D2A  0EB020001  add.w     r0,r2,r1
.   286  010003D2E      06800  ldr       r0,[r0]
.   288  010003D30      09901  ldr       r1,[sp,#4]
.   290  010003D32      09A02  ldr       r2,[sp,#8]
.   292  010003D34  0F7FEFBD0  bl.w      Ext Proc #4
.   296  010003D38      0E000  b         0 -> 300
.   298  010003D3A      00033  <LineNo: 51>
      TextIO.OpenReader(R[termNo], dev, gsp)
.   300  010003D3C      09800  ldr       r0,[sp]
.   302  010003D3E      02802  cmp       r0,#2
.   304  010003D40      0D301  bcc.n     2 -> 310
.   306  010003D42      0DF01  svc       1
.   308  010003D44      00034  <LineNo: 52>
.   310  010003D46  0F8DF1028  ldr.w     r1,[pc,#40] -> 352
.   314  010003D4A      00082  lsls      r2,r0,#2
.   316  010003D4C  0EB020001  add.w     r0,r2,r1
.   320  010003D50      06800  ldr       r0,[r0]
.   322  010003D52      09901  ldr       r1,[sp,#4]
.   324  010003D54      09A03  ldr       r2,[sp,#12]
    END
.   326  010003D56  0F7FEFBD9  bl.w      Ext Proc #6
.   330  010003D5A      0E000  b         0 -> 334
.   332  010003D5C      00034  <LineNo: 52>
  END Open;
.   334  010003D5E      0B004  add       sp,#16
.   336  010003D60      0BD00  pop       { pc }
.   338  010003D62      0BF00  nop       
.   340  010003D64  0100024B0  <Global: TextIO code>
.   344  010003D68  0100024C4  <Global: TextIO code>
.   348  010003D6C  02001FEB4  <Global: Terminals data>
.   352  010003D70  02001FEA4  <Global: Terminals data>


  PROCEDURE* Close*(termNo: INTEGER; VAR dev: TextIO.Device);
  BEGIN
.   356  010003D74      0B500  push      { lr }
    dev := W[termNo].dev;
.   358  010003D76  0F8DF2020  ldr.w     r2,[pc,#32] -> 392
.   362  010003D7A      00083  lsls      r3,r0,#2
.   364  010003D7C  0EB030202  add.w     r2,r3,r2
.   368  010003D80      06812  ldr       r2,[r2]
.   370  010003D82      06812  ldr       r2,[r2]
.   372  010003D84      0600A  str       r2,[r1]
    W[termNo] := NIL
.   374  010003D86  0F8DF2010  ldr.w     r2,[pc,#16] -> 392
.   378  010003D8A      00083  lsls      r3,r0,#2
.   380  010003D8C  0EB030202  add.w     r2,r3,r2
  END Close;
.   384  010003D90      02300  movs      r3,#0
.   386  010003D92      06013  str       r3,[r2]
.   388  010003D94      0BD00  pop       { pc }
.   390  010003D96      0BF00  nop       
.   392  010003D98  02001FEB4  <Global: Terminals data>


  PROCEDURE OpenErr*(termNo: INTEGER; psp: TextIO.PutStringProc);
  (**
    Add an error output terminal, eg. using a simple busy-wait output.
    Not much worries about thread mis-timing in case of an error, better get that
    error message out intact. :)
    See module Main for an example.
  **)
  BEGIN
.   396  010003D9C      0B503  push      { r0, r1, lr }
    ASSERT(termNo IN {TERM0, TERM1}, Errors.PreCond);
.   398  010003D9E      02003  movs      r0,#3
.   400  010003DA0      09900  ldr       r1,[sp]
.   402  010003DA2      02201  movs      r2,#1
.   404  010003DA4      0408A  lsls      r2,r1
.   406  010003DA6  0EA100F02  tst.w     r0,r2
.   410  010003DAA      0D101  bne.n     2 -> 416
.   412  010003DAC      0DF22  svc       34
.   414  010003DAE      00048  <LineNo: 72>
    ASSERT(W[termNo] # NIL, Errors.ProgError); (* main terminal must be open *)
.   416  010003DB0      09800  ldr       r0,[sp]
.   418  010003DB2      02802  cmp       r0,#2
.   420  010003DB4      0D301  bcc.n     2 -> 426
.   422  010003DB6      0DF01  svc       1
.   424  010003DB8      00049  <LineNo: 73>
.   426  010003DBA  0F8DF10AC  ldr.w     r1,[pc,#172] -> 600
.   430  010003DBE      00082  lsls      r2,r0,#2
.   432  010003DC0  0EB020001  add.w     r0,r2,r1
.   436  010003DC4      06800  ldr       r0,[r0]
.   438  010003DC6      02800  cmp       r0,#0
.   440  010003DC8      0D101  bne.n     2 -> 446
.   442  010003DCA      0DF25  svc       37
.   444  010003DCC      00049  <LineNo: 73>
    IF Werr[termNo] = NIL THEN
.   446  010003DCE      09800  ldr       r0,[sp]
.   448  010003DD0      02802  cmp       r0,#2
.   450  010003DD2      0D301  bcc.n     2 -> 456
.   452  010003DD4      0DF01  svc       1
.   454  010003DD6      0004A  <LineNo: 74>
.   456  010003DD8  0F8DF1090  ldr.w     r1,[pc,#144] -> 604
.   460  010003DDC      00082  lsls      r2,r0,#2
.   462  010003DDE  0EB020001  add.w     r0,r2,r1
.   466  010003DE2      06800  ldr       r0,[r0]
.   468  010003DE4      02800  cmp       r0,#0
.   470  010003DE6  0F040803B  bne.w     118 -> 592
      NEW(Werr[termNo]); ASSERT(Werr[termNo] # NIL, Errors.HeapOverflow);
.   474  010003DEA      09800  ldr       r0,[sp]
.   476  010003DEC      02802  cmp       r0,#2
.   478  010003DEE      0D301  bcc.n     2 -> 484
.   480  010003DF0      0DF01  svc       1
.   482  010003DF2      0004B  <LineNo: 75>
.   484  010003DF4  0F8DF1074  ldr.w     r1,[pc,#116] -> 604
.   488  010003DF8      00082  lsls      r2,r0,#2
.   490  010003DFA  0EB020001  add.w     r0,r2,r1
.   494  010003DFE  0F8DF1064  ldr.w     r1,[pc,#100] -> 596
.   498  010003E02  0F7FCFD5D  bl.w      Ext Proc #1
.   502  010003E06      0E000  b         0 -> 506
.   504  010003E08      0004B  <LineNo: 75>
.   506  010003E0A      09800  ldr       r0,[sp]
.   508  010003E0C      02802  cmp       r0,#2
.   510  010003E0E      0D301  bcc.n     2 -> 516
.   512  010003E10      0DF01  svc       1
.   514  010003E12      0004B  <LineNo: 75>
.   516  010003E14  0F8DF1054  ldr.w     r1,[pc,#84] -> 604
.   520  010003E18      00082  lsls      r2,r0,#2
.   522  010003E1A  0EB020001  add.w     r0,r2,r1
.   526  010003E1E      06800  ldr       r0,[r0]
.   528  010003E20      02800  cmp       r0,#0
.   530  010003E22      0D101  bne.n     2 -> 536
.   532  010003E24      0DF29  svc       41
.   534  010003E26      0004B  <LineNo: 75>
      TextIO.OpenWriter(Werr[termNo], W[termNo].dev, psp);
.   536  010003E28      09800  ldr       r0,[sp]
.   538  010003E2A      02802  cmp       r0,#2
.   540  010003E2C      0D301  bcc.n     2 -> 546
.   542  010003E2E      0DF01  svc       1
.   544  010003E30      0004C  <LineNo: 76>
.   546  010003E32  0F8DF1038  ldr.w     r1,[pc,#56] -> 604
.   550  010003E36      00082  lsls      r2,r0,#2
.   552  010003E38  0EB020001  add.w     r0,r2,r1
.   556  010003E3C      06800  ldr       r0,[r0]
.   558  010003E3E      09900  ldr       r1,[sp]
.   560  010003E40      02902  cmp       r1,#2
.   562  010003E42      0D301  bcc.n     2 -> 568
.   564  010003E44      0DF01  svc       1
.   566  010003E46      0004C  <LineNo: 76>
.   568  010003E48  0F8DF201C  ldr.w     r2,[pc,#28] -> 600
.   572  010003E4C      0008B  lsls      r3,r1,#2
.   574  010003E4E  0EB030102  add.w     r1,r3,r2
.   578  010003E52      06809  ldr       r1,[r1]
.   580  010003E54      06809  ldr       r1,[r1]
.   582  010003E56      09A01  ldr       r2,[sp,#4]
.   584  010003E58  0F7FEFB3E  bl.w      Ext Proc #4
.   588  010003E5C      0E000  b         0 -> 592
.   590  010003E5E      0004C  <LineNo: 76>
    END
  END OpenErr;
.   592  010003E60      0B002  add       sp,#8
.   594  010003E62      0BD00  pop       { pc }
.   596  010003E64  0100024B0  <Global: TextIO code>
.   600  010003E68  02001FEB4  <Global: Terminals data>
.   604  010003E6C  02001FEAC  <Global: Terminals data>


BEGIN
.   608  010003E70      0B500  push      { lr }
  W[0] := NIL; W[1] := NIL;
.   610  010003E72  0F8DF0030  ldr.w     r0,[pc,#48] -> 660
.   614  010003E76      02100  movs      r1,#0
.   616  010003E78      06001  str       r1,[r0]
.   618  010003E7A  0F8DF0028  ldr.w     r0,[pc,#40] -> 660
.   622  010003E7E      02100  movs      r1,#0
.   624  010003E80      06041  str       r1,[r0,#4]
  R[0] := NIL; R[1] := NIL;
.   626  010003E82  0F8DF0024  ldr.w     r0,[pc,#36] -> 664
.   630  010003E86      02100  movs      r1,#0
.   632  010003E88      06001  str       r1,[r0]
.   634  010003E8A  0F8DF001C  ldr.w     r0,[pc,#28] -> 664
.   638  010003E8E      02100  movs      r1,#0
.   640  010003E90      06041  str       r1,[r0,#4]
  Werr[0] := NIL; Werr[1] := NIL
.   642  010003E92  0F8DF0018  ldr.w     r0,[pc,#24] -> 668
.   646  010003E96      02100  movs      r1,#0
.   648  010003E98      06001  str       r1,[r0]
.   650  010003E9A  0F8DF0010  ldr.w     r0,[pc,#16] -> 668
END Terminals.
.   654  010003E9E      02100  movs      r1,#0
.   656  010003EA0      06041  str       r1,[r0,#4]
.   658  010003EA2      0BD00  pop       { pc }
.   660  010003EA4  02001FEB4  <Global: Terminals data>
.   664  010003EA8  02001FEA4  <Global: Terminals data>
.   668  010003EAC  02001FEAC  <Global: Terminals data>
 