. <tool: Astrobe for RP2350>
. <prog: C:\Users\gray\Projects\oberon\dev\oberon-rtk\examples\v3.0\nxp\any\SignalSync\SignalSync.mod>

.     0  010000A7C              <Pad: 0>
MODULE Memory;
(**
  Oberon RTK Framework
  Version: v3.0
  --
  * heap memory allocation
  * stacks allocation
  --
  MCU: MCXA346, MCXN947
  --
  Copyright (c) 2023-2025 Gray, gray@grayraven.org
  Portions copyright (c) 2012-2021 CFB Software, https://www.astrobe.com
  Used with permission.
  Please refer to the licensing conditions as defined at the end of this file.
**)

  IMPORT SYSTEM, MCU := MCU2, Config, MAU, Cores;

  CONST
    NumCores = Config.NumCoresUsed;
    NumThreadStacks = 16;
    MainStackSize* = 2048; (* default, see SetMainStackSize below *)
    StackSeal* = 0FEF5EDA5H;

  TYPE
    CoreHeap = RECORD
      heapLimit: INTEGER;
      heapTop: INTEGER
    END;
.     4  010000A80  010000A80      00008  <Type:   8>
.     8  010000A84  010000A84      00000  <Type:   0>
.    12  010000A88  010000A88      00000  <Type:   0>
.    16  010000A8C  010000A8C      00000  <Type:   0>
.    20  010000A90  010000A90      00000  <Type:   0>

    Stack = RECORD
      addr: INTEGER;
      size: INTEGER
    END;
.    24  010000A94  010000A94      00008  <Type:   8>
.    28  010000A98  010000A98      00000  <Type:   0>
.    32  010000A9C  010000A9C      00000  <Type:   0>
.    36  010000AA0  010000AA0      00000  <Type:   0>
.    40  010000AA4  010000AA4      00000  <Type:   0>

    CoreStacks = RECORD
      threadStacks: ARRAY NumThreadStacks OF Stack;
      loopStack: Stack;
      stacksBottom, stacksTop: INTEGER;
      stackCheckEnabled: BOOLEAN
    END;
.    44  010000AA8  010000AA8      00094  <Type:   148>
.    48  010000AAC  010000AAC      00000  <Type:   0>
.    52  010000AB0  010000AB0      00000  <Type:   0>
.    56  010000AB4  010000AB4      00000  <Type:   0>
.    60  010000AB8  010000AB8      00000  <Type:   0>

  VAR
    heaps: ARRAY NumCores OF CoreHeap;
    stacks: ARRAY NumCores OF CoreStacks;

  (* === heap memory === *)

  (* --- Astrobe code begin --- *)

  PROCEDURE Allocate*(VAR p: INTEGER; typeDesc: INTEGER);
  (* from Astrobe library, modified *)
  (* allocate record, prefix with typeDesc field of 1 word with offset -4 *)
    VAR cid, h, size, limit: INTEGER;
  BEGIN
.    64  010000ABC      0B503  push      { r0, r1, lr }
.    66  010000ABE      0B084  sub       sp,#16
    Cores.GetCoreId(cid);
.    68  010000AC0      04668  mov       r0,sp
.    70  010000AC2  0F7FFFFC5  bl.w      Ext Proc #2
.    74  010000AC6      0E000  b         0 -> 78
.    76  010000AC8      00038  <LineNo: 56>
    limit := heaps[cid].heapLimit;
.    78  010000ACA      09800  ldr       r0,[sp]
.    80  010000ACC      02801  cmp       r0,#1
.    82  010000ACE      0D301  bcc.n     2 -> 88
.    84  010000AD0      0DF01  svc       1
.    86  010000AD2      00039  <LineNo: 57>
.    88  010000AD4  0F8DF10B8  ldr.w     r1,[pc,#184] -> 276
.    92  010000AD8      000C2  lsls      r2,r0,#3
.    94  010000ADA  0EB020001  add.w     r0,r2,r1
.    98  010000ADE      06800  ldr       r0,[r0]
.   100  010000AE0      09003  str       r0,[sp,#12]
    IF limit = 0 THEN
.   102  010000AE2      09803  ldr       r0,[sp,#12]
.   104  010000AE4      02800  cmp       r0,#0
.   106  010000AE6  0F040800D  bne.w     26 -> 136
      limit := stacks[cid].stacksBottom
.   110  010000AEA      09800  ldr       r0,[sp]
.   112  010000AEC      02801  cmp       r0,#1
.   114  010000AEE      0D301  bcc.n     2 -> 120
.   116  010000AF0      0DF01  svc       1
.   118  010000AF2      0003B  <LineNo: 59>
.   120  010000AF4  0F8DF109C  ldr.w     r1,[pc,#156] -> 280
.   124  010000AF8      02294  movs      r2,#148
.   126  010000AFA  0FB021000  mla.w     r0,r2,r0,r1
    END;
.   130  010000AFE  0F8D00088  ldr.w     r0,[r0,#136]
.   134  010000B02      09003  str       r0,[sp,#12]
    (* obtain record size from type descriptor, usually in flash *)
    SYSTEM.GET(typeDesc, size);
.   136  010000B04      09805  ldr       r0,[sp,#20]
.   138  010000B06      06801  ldr       r1,[r0]
.   140  010000B08      09102  str       r1,[sp,#8]
    h := heaps[cid].heapTop + 4 + size;
.   142  010000B0A      09800  ldr       r0,[sp]
.   144  010000B0C      02801  cmp       r0,#1
.   146  010000B0E      0D301  bcc.n     2 -> 152
.   148  010000B10      0DF01  svc       1
.   150  010000B12      0003F  <LineNo: 63>
.   152  010000B14  0F8DF1078  ldr.w     r1,[pc,#120] -> 276
.   156  010000B18      000C2  lsls      r2,r0,#3
.   158  010000B1A  0EB020001  add.w     r0,r2,r1
.   162  010000B1E      06840  ldr       r0,[r0,#4]
.   164  010000B20      03004  adds      r0,#4
.   166  010000B22      09902  ldr       r1,[sp,#8]
.   168  010000B24      04408  add       r0,r1
.   170  010000B26      09001  str       r0,[sp,#4]
    IF h > limit THEN
.   172  010000B28      09801  ldr       r0,[sp,#4]
.   174  010000B2A      09903  ldr       r1,[sp,#12]
.   176  010000B2C      04288  cmp       r0,r1
.   178  010000B2E  0F3408005  ble.w     10 -> 192
      p := 0
    ELSE
.   182  010000B32      02000  movs      r0,#0
.   184  010000B34      09904  ldr       r1,[sp,#16]
.   186  010000B36      06008  str       r0,[r1]
      p := heaps[cid].heapTop + 4;
.   188  010000B38  0F000B827  b.w       78 -> 270
.   192  010000B3C      09800  ldr       r0,[sp]
.   194  010000B3E      02801  cmp       r0,#1
.   196  010000B40      0D301  bcc.n     2 -> 202
.   198  010000B42      0DF01  svc       1
.   200  010000B44      00043  <LineNo: 67>
.   202  010000B46  0F8DF1048  ldr.w     r1,[pc,#72] -> 276
.   206  010000B4A      000C2  lsls      r2,r0,#3
.   208  010000B4C  0EB020001  add.w     r0,r2,r1
.   212  010000B50      06840  ldr       r0,[r0,#4]
.   214  010000B52      03004  adds      r0,#4
.   216  010000B54      09904  ldr       r1,[sp,#16]
.   218  010000B56      06008  str       r0,[r1]
      (* address of type descriptor to tagfield of new record *)
      SYSTEM.PUT(heaps[cid].heapTop, typeDesc);
.   220  010000B58      09800  ldr       r0,[sp]
.   222  010000B5A      02801  cmp       r0,#1
.   224  010000B5C      0D301  bcc.n     2 -> 230
.   226  010000B5E      0DF01  svc       1
.   228  010000B60      00045  <LineNo: 69>
.   230  010000B62  0F8DF102C  ldr.w     r1,[pc,#44] -> 276
.   234  010000B66      000C2  lsls      r2,r0,#3
.   236  010000B68  0EB020001  add.w     r0,r2,r1
.   240  010000B6C      06840  ldr       r0,[r0,#4]
.   242  010000B6E      09905  ldr       r1,[sp,#20]
.   244  010000B70      06001  str       r1,[r0]
      heaps[cid].heapTop := h
.   246  010000B72      09800  ldr       r0,[sp]
.   248  010000B74      02801  cmp       r0,#1
.   250  010000B76      0D301  bcc.n     2 -> 256
.   252  010000B78      0DF01  svc       1
.   254  010000B7A      00046  <LineNo: 70>
.   256  010000B7C  0F8DF1010  ldr.w     r1,[pc,#16] -> 276
.   260  010000B80      000C2  lsls      r2,r0,#3
.   262  010000B82  0EB020001  add.w     r0,r2,r1
    END;
.   266  010000B86      09901  ldr       r1,[sp,#4]
.   268  010000B88      06041  str       r1,[r0,#4]
  END Allocate;
.   270  010000B8A      0B006  add       sp,#24
.   272  010000B8C      0BD00  pop       { pc }
.   274  010000B8E      0BF00  nop       
.   276  010000B90  02001FF84  <Global: Memory data>
.   280  010000B94  02001FEF0  <Global: Memory data>


  PROCEDURE Deallocate*(VAR p: INTEGER; typeDesc: INTEGER);
  (* from Astrobe Library, modified *)
  (* Assign NIL = 0 to the pointer 'p'. Reclaim the space if this was the most
     recent allocation, otherwise do nothing. *)
    VAR cid, h, size: INTEGER;
  BEGIN
.   284  010000B98      0B503  push      { r0, r1, lr }
.   286  010000B9A      0B083  sub       sp,#12
    ASSERT(p # 0, 12);
.   288  010000B9C      09803  ldr       r0,[sp,#12]
.   290  010000B9E      06800  ldr       r0,[r0]
.   292  010000BA0      02800  cmp       r0,#0
.   294  010000BA2      0D101  bne.n     2 -> 300
.   296  010000BA4      0DF0C  svc       12
.   298  010000BA6      00051  <LineNo: 81>
    Cores.GetCoreId(cid);
.   300  010000BA8      04668  mov       r0,sp
.   302  010000BAA  0F7FFFF51  bl.w      Ext Proc #2
.   306  010000BAE      0E000  b         0 -> 310
.   308  010000BB0      00052  <LineNo: 82>
    (* obtain record size from type descriptor, usually in flash *)
    SYSTEM.GET(typeDesc, size);
.   310  010000BB2      09804  ldr       r0,[sp,#16]
.   312  010000BB4      06801  ldr       r1,[r0]
.   314  010000BB6      09102  str       r1,[sp,#8]
    h := heaps[cid].heapTop - size;
.   316  010000BB8      09800  ldr       r0,[sp]
.   318  010000BBA      02801  cmp       r0,#1
.   320  010000BBC      0D301  bcc.n     2 -> 326
.   322  010000BBE      0DF01  svc       1
.   324  010000BC0      00055  <LineNo: 85>
.   326  010000BC2  0F8DF1044  ldr.w     r1,[pc,#68] -> 396
.   330  010000BC6      000C2  lsls      r2,r0,#3
.   332  010000BC8  0EB020001  add.w     r0,r2,r1
.   336  010000BCC      06840  ldr       r0,[r0,#4]
.   338  010000BCE      09902  ldr       r1,[sp,#8]
.   340  010000BD0  0EBA00001  sub.w     r0,r0,r1
.   344  010000BD4      09001  str       r0,[sp,#4]
    IF h = p THEN heaps[cid].heapTop := h - 4 END;
.   346  010000BD6      09801  ldr       r0,[sp,#4]
.   348  010000BD8      09903  ldr       r1,[sp,#12]
.   350  010000BDA      06809  ldr       r1,[r1]
.   352  010000BDC      04288  cmp       r0,r1
.   354  010000BDE  0F040800D  bne.w     26 -> 384
.   358  010000BE2      09800  ldr       r0,[sp]
.   360  010000BE4      02801  cmp       r0,#1
.   362  010000BE6      0D301  bcc.n     2 -> 368
.   364  010000BE8      0DF01  svc       1
.   366  010000BEA      00056  <LineNo: 86>
.   368  010000BEC  0F8DF1018  ldr.w     r1,[pc,#24] -> 396
.   372  010000BF0      000C2  lsls      r2,r0,#3
.   374  010000BF2  0EB020001  add.w     r0,r2,r1
.   378  010000BF6      09901  ldr       r1,[sp,#4]
.   380  010000BF8      03904  subs      r1,#4
.   382  010000BFA      06041  str       r1,[r0,#4]
    p := 0
  END Deallocate;
.   384  010000BFC      02000  movs      r0,#0
.   386  010000BFE      09903  ldr       r1,[sp,#12]
.   388  010000C00      06008  str       r0,[r1]
.   390  010000C02      0B005  add       sp,#20
.   392  010000C04      0BD00  pop       { pc }
.   394  010000C06      0BF00  nop       
.   396  010000C08  02001FF84  <Global: Memory data>

  (* --- Astrobe code end --- *)

  PROCEDURE* LockHeaps*;
    VAR cid: INTEGER;
  BEGIN
.   400  010000C0C      0B500  push      { lr }
    cid := 0;
.   402  010000C0E      02100  movs      r1,#0
.   404  010000C10      04608  mov       r0,r1
    WHILE cid < NumCores DO
.   406  010000C12      02801  cmp       r0,#1
.   408  010000C14  0F280800F  bge.w     30 -> 442
      heaps[cid].heapLimit := heaps[cid].heapTop;
.   412  010000C18  0F8DF101C  ldr.w     r1,[pc,#28] -> 444
.   416  010000C1C      000C2  lsls      r2,r0,#3
.   418  010000C1E  0EB020101  add.w     r1,r2,r1
.   422  010000C22  0F8DF2014  ldr.w     r2,[pc,#20] -> 444
.   426  010000C26      000C3  lsls      r3,r0,#3
.   428  010000C28  0EB030202  add.w     r2,r3,r2
.   432  010000C2C      06852  ldr       r2,[r2,#4]
.   434  010000C2E      0600A  str       r2,[r1]
      INC(cid)
    END
.   436  010000C30      03001  adds      r0,#1
.   438  010000C32  0F7FFBFEE  b.w       -36 -> 406
  END LockHeaps;
.   442  010000C36      0BD00  pop       { pc }
.   444  010000C38  02001FF84  <Global: Memory data>

  (* === thread & loop stacks === *)

  PROCEDURE* initStackCheck(addr, limit: INTEGER);
  BEGIN
.   448  010000C3C      0B500  push      { lr }
    WHILE addr < limit DO
.   450  010000C3E      04288  cmp       r0,r1
.   452  010000C40  0F2808005  bge.w     10 -> 466
      SYSTEM.PUT(addr, addr + 3);
.   456  010000C44      01CC2  adds      r2,r0,#3
.   458  010000C46      06002  str       r2,[r0]
      INC(addr, 4)
    END
.   460  010000C48      03004  adds      r0,#4
.   462  010000C4A  0F7FFBFF8  b.w       -16 -> 450
  END initStackCheck;
.   466  010000C4E      0BD00  pop       { pc }


  PROCEDURE* checkStackUsage(addr, limit: INTEGER; VAR unused: INTEGER);
    VAR value: INTEGER;
  BEGIN
.   468  010000C50      0B500  push      { lr }
    SYSTEM.GET(addr, value);
.   470  010000C52      06803  ldr       r3,[r0]
    unused := 0;
.   472  010000C54      02400  movs      r4,#0
.   474  010000C56      06014  str       r4,[r2]
    WHILE (value = addr + 3) & (addr < limit) DO
.   476  010000C58      01CC4  adds      r4,r0,#3
.   478  010000C5A      042A3  cmp       r3,r4
.   480  010000C5C  0F040800A  bne.w     20 -> 504
.   484  010000C60      04288  cmp       r0,r1
.   486  010000C62  0F2808007  bge.w     14 -> 504
      INC(addr, 4); INC(unused, 4);
.   490  010000C66      03004  adds      r0,#4
.   492  010000C68      06814  ldr       r4,[r2]
.   494  010000C6A      03404  adds      r4,#4
.   496  010000C6C      06014  str       r4,[r2]
      SYSTEM.GET(addr, value)
    END
.   498  010000C6E      06803  ldr       r3,[r0]
.   500  010000C70  0F7FFBFF2  b.w       -28 -> 476
  END checkStackUsage;
.   504  010000C74      0BD00  pop       { pc }
.   506  010000C76      0BF00  nop       


  PROCEDURE CheckLoopStackUsage*(VAR size, used: INTEGER);
    VAR cid, addr, limit, unused: INTEGER;
  BEGIN
.   508  010000C78      0B503  push      { r0, r1, lr }
.   510  010000C7A      0B084  sub       sp,#16
    Cores.GetCoreId(cid);
.   512  010000C7C      04668  mov       r0,sp
.   514  010000C7E  0F7FFFEE7  bl.w      Ext Proc #2
.   518  010000C82      0E000  b         0 -> 522
.   520  010000C84      00080  <LineNo: 128>
    addr := stacks[cid].loopStack.addr;
.   522  010000C86      09800  ldr       r0,[sp]
.   524  010000C88      02801  cmp       r0,#1
.   526  010000C8A      0D301  bcc.n     2 -> 532
.   528  010000C8C      0DF01  svc       1
.   530  010000C8E      00081  <LineNo: 129>
.   532  010000C90  0F8DF1054  ldr.w     r1,[pc,#84] -> 620
.   536  010000C94      02294  movs      r2,#148
.   538  010000C96  0FB021000  mla.w     r0,r2,r0,r1
.   542  010000C9A  0F8D00080  ldr.w     r0,[r0,#128]
.   546  010000C9E      09001  str       r0,[sp,#4]
    size := stacks[cid].loopStack.size;
.   548  010000CA0      09800  ldr       r0,[sp]
.   550  010000CA2      02801  cmp       r0,#1
.   552  010000CA4      0D301  bcc.n     2 -> 558
.   554  010000CA6      0DF01  svc       1
.   556  010000CA8      00082  <LineNo: 130>
.   558  010000CAA  0F8DF103C  ldr.w     r1,[pc,#60] -> 620
.   562  010000CAE      02294  movs      r2,#148
.   564  010000CB0  0FB021000  mla.w     r0,r2,r0,r1
.   568  010000CB4  0F8D00084  ldr.w     r0,[r0,#132]
.   572  010000CB8      09904  ldr       r1,[sp,#16]
.   574  010000CBA      06008  str       r0,[r1]
    limit := addr + size;
.   576  010000CBC      09801  ldr       r0,[sp,#4]
.   578  010000CBE      09904  ldr       r1,[sp,#16]
.   580  010000CC0      06809  ldr       r1,[r1]
.   582  010000CC2      04408  add       r0,r1
.   584  010000CC4      09002  str       r0,[sp,#8]
    checkStackUsage(addr, limit, unused);
.   586  010000CC6      09801  ldr       r0,[sp,#4]
.   588  010000CC8      09902  ldr       r1,[sp,#8]
.   590  010000CCA  0F11D020C  adds.w    r2,sp,#12
.   594  010000CCE  0F7FFFFBF  bl.w      -130 -> 468
.   598  010000CD2      0E000  b         0 -> 602
.   600  010000CD4      00084  <LineNo: 132>
    used := size - unused
  END CheckLoopStackUsage;
.   602  010000CD6      09804  ldr       r0,[sp,#16]
.   604  010000CD8      06800  ldr       r0,[r0]
.   606  010000CDA      09903  ldr       r1,[sp,#12]
.   608  010000CDC  0EBA00001  sub.w     r0,r0,r1
.   612  010000CE0      09905  ldr       r1,[sp,#20]
.   614  010000CE2      06008  str       r0,[r1]
.   616  010000CE4      0B006  add       sp,#24
.   618  010000CE6      0BD00  pop       { pc }
.   620  010000CE8  02001FEF0  <Global: Memory data>


  PROCEDURE CheckThreadStackUsage*(id: INTEGER; VAR size, used: INTEGER);
    VAR cid, addr, limit, unused: INTEGER;
  BEGIN
.   624  010000CEC      0B507  push      { r0, r1, r2, lr }
.   626  010000CEE      0B084  sub       sp,#16
    Cores.GetCoreId(cid);
.   628  010000CF0      04668  mov       r0,sp
.   630  010000CF2  0F7FFFEAD  bl.w      Ext Proc #2
.   634  010000CF6      0E000  b         0 -> 638
.   636  010000CF8      0008C  <LineNo: 140>
    addr := stacks[cid].threadStacks[id].addr;
.   638  010000CFA      09800  ldr       r0,[sp]
.   640  010000CFC      02801  cmp       r0,#1
.   642  010000CFE      0D301  bcc.n     2 -> 648
.   644  010000D00      0DF01  svc       1
.   646  010000D02      0008D  <LineNo: 141>
.   648  010000D04  0F8DF1070  ldr.w     r1,[pc,#112] -> 764
.   652  010000D08      02294  movs      r2,#148
.   654  010000D0A  0FB021000  mla.w     r0,r2,r0,r1
.   658  010000D0E      09904  ldr       r1,[sp,#16]
.   660  010000D10      02910  cmp       r1,#16
.   662  010000D12      0D301  bcc.n     2 -> 668
.   664  010000D14      0DF01  svc       1
.   666  010000D16      0008D  <LineNo: 141>
.   668  010000D18      000CA  lsls      r2,r1,#3
.   670  010000D1A  0EB020000  add.w     r0,r2,r0
.   674  010000D1E      06800  ldr       r0,[r0]
.   676  010000D20      09001  str       r0,[sp,#4]
    size := stacks[cid].threadStacks[id].size;
.   678  010000D22      09800  ldr       r0,[sp]
.   680  010000D24      02801  cmp       r0,#1
.   682  010000D26      0D301  bcc.n     2 -> 688
.   684  010000D28      0DF01  svc       1
.   686  010000D2A      0008E  <LineNo: 142>
.   688  010000D2C  0F8DF1048  ldr.w     r1,[pc,#72] -> 764
.   692  010000D30      02294  movs      r2,#148
.   694  010000D32  0FB021000  mla.w     r0,r2,r0,r1
.   698  010000D36      09904  ldr       r1,[sp,#16]
.   700  010000D38      02910  cmp       r1,#16
.   702  010000D3A      0D301  bcc.n     2 -> 708
.   704  010000D3C      0DF01  svc       1
.   706  010000D3E      0008E  <LineNo: 142>
.   708  010000D40      000CA  lsls      r2,r1,#3
.   710  010000D42  0EB020000  add.w     r0,r2,r0
.   714  010000D46      06840  ldr       r0,[r0,#4]
.   716  010000D48      09905  ldr       r1,[sp,#20]
.   718  010000D4A      06008  str       r0,[r1]
    limit := addr + size;
.   720  010000D4C      09801  ldr       r0,[sp,#4]
.   722  010000D4E      09905  ldr       r1,[sp,#20]
.   724  010000D50      06809  ldr       r1,[r1]
.   726  010000D52      04408  add       r0,r1
.   728  010000D54      09002  str       r0,[sp,#8]
    checkStackUsage(addr, limit, unused);
.   730  010000D56      09801  ldr       r0,[sp,#4]
.   732  010000D58      09902  ldr       r1,[sp,#8]
.   734  010000D5A  0F11D020C  adds.w    r2,sp,#12
.   738  010000D5E  0F7FFFF77  bl.w      -274 -> 468
.   742  010000D62      0E000  b         0 -> 746
.   744  010000D64      00090  <LineNo: 144>
    used := size - unused
  END CheckThreadStackUsage;
.   746  010000D66      09805  ldr       r0,[sp,#20]
.   748  010000D68      06800  ldr       r0,[r0]
.   750  010000D6A      09903  ldr       r1,[sp,#12]
.   752  010000D6C  0EBA00001  sub.w     r0,r0,r1
.   756  010000D70      09906  ldr       r1,[sp,#24]
.   758  010000D72      06008  str       r0,[r1]
.   760  010000D74      0B007  add       sp,#28
.   762  010000D76      0BD00  pop       { pc }
.   764  010000D78  02001FEF0  <Global: Memory data>


  PROCEDURE* allocStack(VAR stkAddr: INTEGER; cid, stkSize: INTEGER);
    VAR limit: INTEGER;
  BEGIN
.   768  010000D7C      0B500  push      { lr }
    limit := heaps[cid].heapLimit;
.   770  010000D7E  0F8DF4080  ldr.w     r4,[pc,#128] -> 900
.   774  010000D82      000CD  lsls      r5,r1,#3
.   776  010000D84  0EB050404  add.w     r4,r5,r4
.   780  010000D88      06824  ldr       r4,[r4]
.   782  010000D8A      04623  mov       r3,r4
    IF limit = 0 THEN
.   784  010000D8C      02B00  cmp       r3,#0
.   786  010000D8E  0F0408007  bne.w     14 -> 804
      limit := heaps[cid].heapTop
.   790  010000D92  0F8DF406C  ldr.w     r4,[pc,#108] -> 900
.   794  010000D96      000CD  lsls      r5,r1,#3
.   796  010000D98  0EB050404  add.w     r4,r5,r4
    END;
.   800  010000D9C      06864  ldr       r4,[r4,#4]
.   802  010000D9E      04623  mov       r3,r4
    IF stacks[cid].stacksBottom - stkSize > limit THEN
.   804  010000DA0  0F8DF4060  ldr.w     r4,[pc,#96] -> 904
.   808  010000DA4      02594  movs      r5,#148
.   810  010000DA6  0FB054401  mla.w     r4,r5,r1,r4
.   814  010000DAA  0F8D44088  ldr.w     r4,[r4,#136]
.   818  010000DAE  0EBA40402  sub.w     r4,r4,r2
.   822  010000DB2      0429C  cmp       r4,r3
.   824  010000DB4  0F340801F  ble.w     62 -> 890
      SYSTEM.PUT(stacks[cid].stacksBottom - 4, StackSeal);
.   828  010000DB8  0F8DF4048  ldr.w     r4,[pc,#72] -> 904
.   832  010000DBC      02594  movs      r5,#148
.   834  010000DBE  0FB054401  mla.w     r4,r5,r1,r4
.   838  010000DC2  0F8D44088  ldr.w     r4,[r4,#136]
.   842  010000DC6      03C04  subs      r4,#4
.   844  010000DC8  0F8DF5030  ldr.w     r5,[pc,#48] -> 896
.   848  010000DCC      06025  str       r5,[r4]
      DEC(stacks[cid].stacksBottom, stkSize);
.   850  010000DCE  0F8DF4034  ldr.w     r4,[pc,#52] -> 904
.   854  010000DD2      02594  movs      r5,#148
.   856  010000DD4  0FB054401  mla.w     r4,r5,r1,r4
.   860  010000DD8      03488  adds      r4,#136
.   862  010000DDA      06825  ldr       r5,[r4]
.   864  010000DDC  0EBA50502  sub.w     r5,r5,r2
.   868  010000DE0      06025  str       r5,[r4]
      stkAddr := stacks[cid].stacksBottom
.   870  010000DE2  0F8DF4020  ldr.w     r4,[pc,#32] -> 904
.   874  010000DE6      02594  movs      r5,#148
.   876  010000DE8  0FB054401  mla.w     r4,r5,r1,r4
    ELSE
.   880  010000DEC  0F8D44088  ldr.w     r4,[r4,#136]
.   884  010000DF0      06004  str       r4,[r0]
      stkAddr := 0
.   886  010000DF2  0F000B802  b.w       4 -> 894
    END
.   890  010000DF6      02400  movs      r4,#0
.   892  010000DF8      06004  str       r4,[r0]
  END allocStack;
.   894  010000DFA      0BD00  pop       { pc }
.   896  010000DFC  0FEF5EDA5  <Const:  -17437275>
.   900  010000E00  02001FF84  <Global: Memory data>
.   904  010000E04  02001FEF0  <Global: Memory data>


  PROCEDURE AllocThreadStack*(VAR stkAddr: INTEGER; id, stkSize: INTEGER);
    VAR cid: INTEGER;
  BEGIN
.   908  010000E08      0B507  push      { r0, r1, r2, lr }
.   910  010000E0A      0B081  sub       sp,#4
    Cores.GetCoreId(cid);
.   912  010000E0C      04668  mov       r0,sp
.   914  010000E0E  0F7FFFE1F  bl.w      Ext Proc #2
.   918  010000E12      0E000  b         0 -> 922
.   920  010000E14      000A9  <LineNo: 169>
    allocStack(stkAddr, cid, stkSize);
.   922  010000E16      09801  ldr       r0,[sp,#4]
.   924  010000E18      09900  ldr       r1,[sp]
.   926  010000E1A      09A03  ldr       r2,[sp,#12]
.   928  010000E1C  0F7FFFFAE  bl.w      -164 -> 768
.   932  010000E20      0E000  b         0 -> 936
.   934  010000E22      000AA  <LineNo: 170>
    IF stkAddr # 0 THEN
.   936  010000E24      09801  ldr       r0,[sp,#4]
.   938  010000E26      06800  ldr       r0,[r0]
.   940  010000E28      02800  cmp       r0,#0
.   942  010000E2A  0F0008043  beq.w     134 -> 1080
      stacks[cid].threadStacks[id].addr := stkAddr;
.   946  010000E2E      09800  ldr       r0,[sp]
.   948  010000E30      02801  cmp       r0,#1
.   950  010000E32      0D301  bcc.n     2 -> 956
.   952  010000E34      0DF01  svc       1
.   954  010000E36      000AC  <LineNo: 172>
.   956  010000E38  0F8DF107C  ldr.w     r1,[pc,#124] -> 1084
.   960  010000E3C      02294  movs      r2,#148
.   962  010000E3E  0FB021000  mla.w     r0,r2,r0,r1
.   966  010000E42      09902  ldr       r1,[sp,#8]
.   968  010000E44      02910  cmp       r1,#16
.   970  010000E46      0D301  bcc.n     2 -> 976
.   972  010000E48      0DF01  svc       1
.   974  010000E4A      000AC  <LineNo: 172>
.   976  010000E4C      000CA  lsls      r2,r1,#3
.   978  010000E4E  0EB020000  add.w     r0,r2,r0
.   982  010000E52      09901  ldr       r1,[sp,#4]
.   984  010000E54      06809  ldr       r1,[r1]
.   986  010000E56      06001  str       r1,[r0]
      stacks[cid].threadStacks[id].size := stkSize;
.   988  010000E58      09800  ldr       r0,[sp]
.   990  010000E5A      02801  cmp       r0,#1
.   992  010000E5C      0D301  bcc.n     2 -> 998
.   994  010000E5E      0DF01  svc       1
.   996  010000E60      000AD  <LineNo: 173>
.   998  010000E62  0F8DF1054  ldr.w     r1,[pc,#84] -> 1084
.  1002  010000E66      02294  movs      r2,#148
.  1004  010000E68  0FB021000  mla.w     r0,r2,r0,r1
.  1008  010000E6C      09902  ldr       r1,[sp,#8]
.  1010  010000E6E      02910  cmp       r1,#16
.  1012  010000E70      0D301  bcc.n     2 -> 1018
.  1014  010000E72      0DF01  svc       1
.  1016  010000E74      000AD  <LineNo: 173>
.  1018  010000E76      000CA  lsls      r2,r1,#3
.  1020  010000E78  0EB020000  add.w     r0,r2,r0
.  1024  010000E7C      09903  ldr       r1,[sp,#12]
.  1026  010000E7E      06041  str       r1,[r0,#4]
      IF stacks[cid].stackCheckEnabled THEN
.  1028  010000E80      09800  ldr       r0,[sp]
.  1030  010000E82      02801  cmp       r0,#1
.  1032  010000E84      0D301  bcc.n     2 -> 1038
.  1034  010000E86      0DF01  svc       1
.  1036  010000E88      000AE  <LineNo: 174>
.  1038  010000E8A  0F8DF102C  ldr.w     r1,[pc,#44] -> 1084
.  1042  010000E8E      02294  movs      r2,#148
.  1044  010000E90  0FB021000  mla.w     r0,r2,r0,r1
.  1048  010000E94  0F8900090  ldrb.w    r0,[r0,#144]
.  1052  010000E98  0F0100F01  tst.w     r0,#1
.  1056  010000E9C  0F000800A  beq.w     20 -> 1080
        initStackCheck(stkAddr, stkAddr + stkSize)
.  1060  010000EA0      09801  ldr       r0,[sp,#4]
.  1062  010000EA2      06800  ldr       r0,[r0]
.  1064  010000EA4      09901  ldr       r1,[sp,#4]
.  1066  010000EA6      06809  ldr       r1,[r1]
.  1068  010000EA8      09A03  ldr       r2,[sp,#12]
.  1070  010000EAA      04411  add       r1,r2
      END
.  1072  010000EAC  0F7FFFEC6  bl.w      -628 -> 448
.  1076  010000EB0      0E000  b         0 -> 1080
.  1078  010000EB2      000AF  <LineNo: 175>
    END
  END AllocThreadStack;
.  1080  010000EB4      0B004  add       sp,#16
.  1082  010000EB6      0BD00  pop       { pc }
.  1084  010000EB8  02001FEF0  <Global: Memory data>


  PROCEDURE AllocLoopStack*(VAR stkAddr: INTEGER; stkSize: INTEGER);
    VAR cid: INTEGER;
  BEGIN
.  1088  010000EBC      0B503  push      { r0, r1, lr }
.  1090  010000EBE      0B081  sub       sp,#4
    Cores.GetCoreId(cid);
.  1092  010000EC0      04668  mov       r0,sp
.  1094  010000EC2  0F7FFFDC5  bl.w      Ext Proc #2
.  1098  010000EC6      0E000  b         0 -> 1102
.  1100  010000EC8      000B8  <LineNo: 184>
    allocStack(stkAddr, cid, stkSize);
.  1102  010000ECA      09801  ldr       r0,[sp,#4]
.  1104  010000ECC      09900  ldr       r1,[sp]
.  1106  010000ECE      09A02  ldr       r2,[sp,#8]
.  1108  010000ED0  0F7FFFF54  bl.w      -344 -> 768
.  1112  010000ED4      0E000  b         0 -> 1116
.  1114  010000ED6      000B9  <LineNo: 185>
    IF stkAddr # 0 THEN
.  1116  010000ED8      09801  ldr       r0,[sp,#4]
.  1118  010000EDA      06800  ldr       r0,[r0]
.  1120  010000EDC      02800  cmp       r0,#0
.  1122  010000EDE  0F0008035  beq.w     106 -> 1232
      stacks[cid].loopStack.addr := stkAddr;
.  1126  010000EE2      09800  ldr       r0,[sp]
.  1128  010000EE4      02801  cmp       r0,#1
.  1130  010000EE6      0D301  bcc.n     2 -> 1136
.  1132  010000EE8      0DF01  svc       1
.  1134  010000EEA      000BB  <LineNo: 187>
.  1136  010000EEC  0F8DF1060  ldr.w     r1,[pc,#96] -> 1236
.  1140  010000EF0      02294  movs      r2,#148
.  1142  010000EF2  0FB021000  mla.w     r0,r2,r0,r1
.  1146  010000EF6      09901  ldr       r1,[sp,#4]
.  1148  010000EF8      06809  ldr       r1,[r1]
.  1150  010000EFA  0F8C01080  str.w     r1,[r0,#128]
      stacks[cid].loopStack.size := stkSize;
.  1154  010000EFE      09800  ldr       r0,[sp]
.  1156  010000F00      02801  cmp       r0,#1
.  1158  010000F02      0D301  bcc.n     2 -> 1164
.  1160  010000F04      0DF01  svc       1
.  1162  010000F06      000BC  <LineNo: 188>
.  1164  010000F08  0F8DF1044  ldr.w     r1,[pc,#68] -> 1236
.  1168  010000F0C      02294  movs      r2,#148
.  1170  010000F0E  0FB021000  mla.w     r0,r2,r0,r1
.  1174  010000F12      09902  ldr       r1,[sp,#8]
.  1176  010000F14  0F8C01084  str.w     r1,[r0,#132]
      IF stacks[cid].stackCheckEnabled THEN
.  1180  010000F18      09800  ldr       r0,[sp]
.  1182  010000F1A      02801  cmp       r0,#1
.  1184  010000F1C      0D301  bcc.n     2 -> 1190
.  1186  010000F1E      0DF01  svc       1
.  1188  010000F20      000BD  <LineNo: 189>
.  1190  010000F22  0F8DF102C  ldr.w     r1,[pc,#44] -> 1236
.  1194  010000F26      02294  movs      r2,#148
.  1196  010000F28  0FB021000  mla.w     r0,r2,r0,r1
.  1200  010000F2C  0F8900090  ldrb.w    r0,[r0,#144]
.  1204  010000F30  0F0100F01  tst.w     r0,#1
.  1208  010000F34  0F000800A  beq.w     20 -> 1232
        initStackCheck(stkAddr, stkAddr + stkSize)
.  1212  010000F38      09801  ldr       r0,[sp,#4]
.  1214  010000F3A      06800  ldr       r0,[r0]
.  1216  010000F3C      09901  ldr       r1,[sp,#4]
.  1218  010000F3E      06809  ldr       r1,[r1]
.  1220  010000F40      09A02  ldr       r2,[sp,#8]
.  1222  010000F42      04411  add       r1,r2
      END
.  1224  010000F44  0F7FFFE7A  bl.w      -780 -> 448
.  1228  010000F48      0E000  b         0 -> 1232
.  1230  010000F4A      000BE  <LineNo: 190>
    END
  END AllocLoopStack;
.  1232  010000F4C      0B003  add       sp,#12
.  1234  010000F4E      0BD00  pop       { pc }
.  1236  010000F50  02001FEF0  <Global: Memory data>


  PROCEDURE EnableStackCheck*(on: BOOLEAN);
    VAR cid: INTEGER;
  BEGIN
.  1240  010000F54      0B501  push      { r0, lr }
.  1242  010000F56      0B081  sub       sp,#4
    Cores.GetCoreId(cid);
.  1244  010000F58      04668  mov       r0,sp
.  1246  010000F5A  0F7FFFD79  bl.w      Ext Proc #2
.  1250  010000F5E      0E000  b         0 -> 1254
.  1252  010000F60      000C7  <LineNo: 199>
    stacks[cid].stackCheckEnabled := on
.  1254  010000F62      09800  ldr       r0,[sp]
.  1256  010000F64      02801  cmp       r0,#1
.  1258  010000F66      0D301  bcc.n     2 -> 1264
.  1260  010000F68      0DF01  svc       1
.  1262  010000F6A      000C8  <LineNo: 200>
.  1264  010000F6C  0F8DF1014  ldr.w     r1,[pc,#20] -> 1288
.  1268  010000F70      02294  movs      r2,#148
.  1270  010000F72  0FB021000  mla.w     r0,r2,r0,r1
  END EnableStackCheck;
.  1274  010000F76  0F89D1004  ldrb.w    r1,[sp,#4]
.  1278  010000F7A  0F8801090  strb.w    r1,[r0,#144]
.  1282  010000F7E      0B002  add       sp,#8
.  1284  010000F80      0BD00  pop       { pc }
.  1286  010000F82      0BF00  nop       
.  1288  010000F84  02001FEF0  <Global: Memory data>


  PROCEDURE ResetMainStack*;
  (* set MSP to top of stack memory from kernel loopc *)
  (* clear out the top of the main stack to get clean stack traces *)
    CONST R11 = 11;
    VAR cid, addr: INTEGER;
  BEGIN
.  1292  010000F88      0B500  push      { lr }
.  1294  010000F8A      0B082  sub       sp,#8
    Cores.GetCoreId(cid);
.  1296  010000F8C      04668  mov       r0,sp
.  1298  010000F8E  0F7FFFD5F  bl.w      Ext Proc #2
.  1302  010000F92      0E000  b         0 -> 1306
.  1304  010000F94      000D2  <LineNo: 210>
    addr := Config.StackMem[cid].start;
.  1306  010000F96      09800  ldr       r0,[sp]
.  1308  010000F98      02801  cmp       r0,#1
.  1310  010000F9A      0D301  bcc.n     2 -> 1316
.  1312  010000F9C      0DF01  svc       1
.  1314  010000F9E      000D3  <LineNo: 211>
.  1316  010000FA0  0F8DF1018  ldr.w     r1,[pc,#24] -> 1344
.  1320  010000FA4      00082  lsls      r2,r0,#2
.  1322  010000FA6  0EB020001  add.w     r0,r2,r1
.  1326  010000FAA      06800  ldr       r0,[r0]
.  1328  010000FAC      09001  str       r0,[sp,#4]
    SYSTEM.LDREG(R11, addr);
.  1330  010000FAE      09801  ldr       r0,[sp,#4]
.  1332  010000FB0      04683  mov       r11,r0
    SYSTEM.EMIT(MCU.MSR_MSP_R11) (* move r11 to msp *)
  END ResetMainStack;
.  1334  010000FB2  0F38B8808  .word     0x8808F38B /* EMIT */
.  1338  010000FB6      0B002  add       sp,#8
.  1340  010000FB8      0BD00  pop       { pc }
.  1342  010000FBA      0BF00  nop       
.  1344  010000FBC  02001FFC0  <Global: Config data>

  (* === init and config === *)

  PROCEDURE* SetMainStackSize*(mainStackSize: ARRAY OF INTEGER);
  (* must be used before Kernel.Install *)
    VAR cid: INTEGER;
  BEGIN
.  1348  010000FC0      0B500  push      { lr }
    cid := 0;
.  1350  010000FC2      02300  movs      r3,#0
.  1352  010000FC4      0461A  mov       r2,r3
    WHILE cid < NumCores DO
.  1354  010000FC6      02A01  cmp       r2,#1
.  1356  010000FC8  0F2808016  bge.w     44 -> 1404
      stacks[cid].stacksBottom := Config.StackMem[cid].start - mainStackSize[cid];
.  1360  010000FCC  0F8DF3030  ldr.w     r3,[pc,#48] -> 1412
.  1364  010000FD0      02494  movs      r4,#148
.  1366  010000FD2  0FB043302  mla.w     r3,r4,r2,r3
.  1370  010000FD6  0F8DF4024  ldr.w     r4,[pc,#36] -> 1408
.  1374  010000FDA      00095  lsls      r5,r2,#2
.  1376  010000FDC  0EB050404  add.w     r4,r5,r4
.  1380  010000FE0      00095  lsls      r5,r2,#2
.  1382  010000FE2  0EB050600  add.w     r6,r5,r0
.  1386  010000FE6      06824  ldr       r4,[r4]
.  1388  010000FE8      06836  ldr       r6,[r6]
.  1390  010000FEA  0EBA40406  sub.w     r4,r4,r6
.  1394  010000FEE  0F8C34088  str.w     r4,[r3,#136]
      INC(cid)
    END
.  1398  010000FF2      03201  adds      r2,#1
.  1400  010000FF4  0F7FFBFE7  b.w       -50 -> 1354
  END SetMainStackSize;
.  1404  010000FF8      0BD00  pop       { pc }
.  1406  010000FFA      0BF00  nop       
.  1408  010000FFC  02001FFC0  <Global: Config data>
.  1412  010001000  02001FEF0  <Global: Memory data>


  PROCEDURE Init*;
    VAR cid: INTEGER;
  BEGIN
.  1416  010001004      0B500  push      { lr }
.  1418  010001006      0B081  sub       sp,#4
    MAU.SetNew(Allocate); MAU.SetDispose(Deallocate);
.  1420  010001008  0F2AF5050  adr.w     r0,pc,#-1360 -> 64
.  1424  01000100C  0F7FFFC80  bl.w      Ext Proc #3
.  1428  010001010      0E000  b         0 -> 1432
.  1430  010001012      000E9  <LineNo: 233>
.  1432  010001014  0F2AF4080  adr.w     r0,pc,#-1152 -> 284
.  1436  010001018  0F7FFFC84  bl.w      Ext Proc #4
.  1440  01000101C      0E000  b         0 -> 1444
.  1442  01000101E      000E9  <LineNo: 233>
    cid := 0;
.  1444  010001020      02000  movs      r0,#0
.  1446  010001022      09000  str       r0,[sp]
    WHILE cid < NumCores DO
.  1448  010001024      09800  ldr       r0,[sp]
.  1450  010001026      02801  cmp       r0,#1
.  1452  010001028  0F280807C  bge.w     248 -> 1704
      heaps[cid].heapTop := Config.HeapMem[cid].start;
.  1456  01000102C      09800  ldr       r0,[sp]
.  1458  01000102E      02801  cmp       r0,#1
.  1460  010001030      0D301  bcc.n     2 -> 1466
.  1462  010001032      0DF01  svc       1
.  1464  010001034      000EC  <LineNo: 236>
.  1466  010001036  0F8DF10FC  ldr.w     r1,[pc,#252] -> 1720
.  1470  01000103A      000C2  lsls      r2,r0,#3
.  1472  01000103C  0EB020001  add.w     r0,r2,r1
.  1476  010001040      09900  ldr       r1,[sp]
.  1478  010001042      02901  cmp       r1,#1
.  1480  010001044      0D301  bcc.n     2 -> 1486
.  1482  010001046      0DF01  svc       1
.  1484  010001048      000EC  <LineNo: 236>
.  1486  01000104A  0F8DF20E0  ldr.w     r2,[pc,#224] -> 1712
.  1490  01000104E      000CB  lsls      r3,r1,#3
.  1492  010001050  0EB030102  add.w     r1,r3,r2
.  1496  010001054      06809  ldr       r1,[r1]
.  1498  010001056      06041  str       r1,[r0,#4]
      heaps[cid].heapLimit := Config.HeapMem[cid].limit;
.  1500  010001058      09800  ldr       r0,[sp]
.  1502  01000105A      02801  cmp       r0,#1
.  1504  01000105C      0D301  bcc.n     2 -> 1510
.  1506  01000105E      0DF01  svc       1
.  1508  010001060      000ED  <LineNo: 237>
.  1510  010001062  0F8DF10D0  ldr.w     r1,[pc,#208] -> 1720
.  1514  010001066      000C2  lsls      r2,r0,#3
.  1516  010001068  0EB020001  add.w     r0,r2,r1
.  1520  01000106C      09900  ldr       r1,[sp]
.  1522  01000106E      02901  cmp       r1,#1
.  1524  010001070      0D301  bcc.n     2 -> 1530
.  1526  010001072      0DF01  svc       1
.  1528  010001074      000ED  <LineNo: 237>
.  1530  010001076  0F8DF20B4  ldr.w     r2,[pc,#180] -> 1712
.  1534  01000107A      000CB  lsls      r3,r1,#3
.  1536  01000107C  0EB030102  add.w     r1,r3,r2
.  1540  010001080      06849  ldr       r1,[r1,#4]
.  1542  010001082      06001  str       r1,[r0]
      stacks[cid].stacksBottom := Config.StackMem[cid].start - MainStackSize;
.  1544  010001084      09800  ldr       r0,[sp]
.  1546  010001086      02801  cmp       r0,#1
.  1548  010001088      0D301  bcc.n     2 -> 1554
.  1550  01000108A      0DF01  svc       1
.  1552  01000108C      000EE  <LineNo: 238>
.  1554  01000108E  0F8DF10A8  ldr.w     r1,[pc,#168] -> 1724
.  1558  010001092      02294  movs      r2,#148
.  1560  010001094  0FB021000  mla.w     r0,r2,r0,r1
.  1564  010001098      09900  ldr       r1,[sp]
.  1566  01000109A      02901  cmp       r1,#1
.  1568  01000109C      0D301  bcc.n     2 -> 1574
.  1570  01000109E      0DF01  svc       1
.  1572  0100010A0      000EE  <LineNo: 238>
.  1574  0100010A2  0F8DF208C  ldr.w     r2,[pc,#140] -> 1716
.  1578  0100010A6      0008B  lsls      r3,r1,#2
.  1580  0100010A8  0EB030102  add.w     r1,r3,r2
.  1584  0100010AC      06809  ldr       r1,[r1]
.  1586  0100010AE  0F5A16100  sub.w     r1,r1,#2048
.  1590  0100010B2  0F8C01088  str.w     r1,[r0,#136]
      stacks[cid].stacksTop := Config.StackMem[cid].start;
.  1594  0100010B6      09800  ldr       r0,[sp]
.  1596  0100010B8      02801  cmp       r0,#1
.  1598  0100010BA      0D301  bcc.n     2 -> 1604
.  1600  0100010BC      0DF01  svc       1
.  1602  0100010BE      000EF  <LineNo: 239>
.  1604  0100010C0  0F8DF1074  ldr.w     r1,[pc,#116] -> 1724
.  1608  0100010C4      02294  movs      r2,#148
.  1610  0100010C6  0FB021000  mla.w     r0,r2,r0,r1
.  1614  0100010CA      09900  ldr       r1,[sp]
.  1616  0100010CC      02901  cmp       r1,#1
.  1618  0100010CE      0D301  bcc.n     2 -> 1624
.  1620  0100010D0      0DF01  svc       1
.  1622  0100010D2      000EF  <LineNo: 239>
.  1624  0100010D4  0F8DF2058  ldr.w     r2,[pc,#88] -> 1716
.  1628  0100010D8      0008B  lsls      r3,r1,#2
.  1630  0100010DA  0EB030102  add.w     r1,r3,r2
.  1634  0100010DE      06809  ldr       r1,[r1]
.  1636  0100010E0  0F8C0108C  str.w     r1,[r0,#140]
      stacks[cid].stackCheckEnabled := FALSE;
.  1640  0100010E4      09800  ldr       r0,[sp]
.  1642  0100010E6      02801  cmp       r0,#1
.  1644  0100010E8      0D301  bcc.n     2 -> 1650
.  1646  0100010EA      0DF01  svc       1
.  1648  0100010EC      000F0  <LineNo: 240>
.  1650  0100010EE  0F8DF1048  ldr.w     r1,[pc,#72] -> 1724
.  1654  0100010F2      02294  movs      r2,#148
.  1656  0100010F4  0FB021000  mla.w     r0,r2,r0,r1
.  1660  0100010F8      02100  movs      r1,#0
.  1662  0100010FA  0F8801090  strb.w    r1,[r0,#144]
      SYSTEM.PUT(Config.StackMem[cid].start, StackSeal);
.  1666  0100010FE      09800  ldr       r0,[sp]
.  1668  010001100      02801  cmp       r0,#1
.  1670  010001102      0D301  bcc.n     2 -> 1676
.  1672  010001104      0DF01  svc       1
.  1674  010001106      000F1  <LineNo: 241>
.  1676  010001108  0F8DF1024  ldr.w     r1,[pc,#36] -> 1716
.  1680  01000110C      00082  lsls      r2,r0,#2
.  1682  01000110E  0EB020001  add.w     r0,r2,r1
.  1686  010001112      06800  ldr       r0,[r0]
.  1688  010001114  0F8DF1010  ldr.w     r1,[pc,#16] -> 1708
.  1692  010001118      06001  str       r1,[r0]
      INC(cid)
    END
.  1694  01000111A      09800  ldr       r0,[sp]
.  1696  01000111C      03001  adds      r0,#1
.  1698  01000111E      09000  str       r0,[sp]
.  1700  010001120  0F7FFBF80  b.w       -256 -> 1448
  END Init;
.  1704  010001124      0B001  add       sp,#4
.  1706  010001126      0BD00  pop       { pc }
.  1708  010001128  0FEF5EDA5  <Const:  -17437275>
.  1712  01000112C  02001FFC4  <Global: Config data>
.  1716  010001130  02001FFC0  <Global: Config data>
.  1720  010001134  02001FF84  <Global: Memory data>
.  1724  010001138  02001FEF0  <Global: Memory data>

BEGIN
.  1728  01000113C      0B500  push      { lr }
  Init
END Memory.
.  1730  01000113E  0F7FFFF61  bl.w      -318 -> 1416
.  1734  010001142      0E000  b         0 -> 1738
.  1736  010001144      000F7  <LineNo: 247>
.  1738  010001146      0BD00  pop       { pc }
 