. <tool: Astrobe for RP2350>
. <prog: C:\Users\gray\Projects\oberon\dev\oberon-rtk\examples\v3.0\nxp\any\SignalSync\SignalSync.mod>

.     0  010002D0C              <Pad: 0>
MODULE ProgData;
(**
  Oberon RTK Framework
  Version: v3.0
  --
  Get data about the program from the '.ref' resource data block
  at the end of the program.
  --
  MCU: MCXA346, MCXN947
  --
  Copyright (c) 2024-2025 Gray, gray@grayraven.org
  https://oberon-rtk.org/licences/
  --
  Structure:
  resource header -- at Config.ResMem.start
  entry
  entry
  ...
  resource header
  entry
  ...

  Resource header:
  offset    value         meaning                           CONST
   0        05237424FH    id = "OB7R" as int
   4        000000001H    version                           ResVersionOffset
   8        06665722EH    ".ref" as int, resource name      ResNameOffset
  20                      resource size in bytes            ResSizeOffset
  24                      first entry: module LinkOptions   ResDataOffset

  Resource entry, example LinkOptions:
  offset    value         meaning
   0        000000000H    entry type: module = 0
   4        06B6E694CH    "Link" as int
   8        06974704FH    "Opti" as int
  12        000736E6FH    "ons" + OX as int
  16        000000000H    0X as int
  20        010000340H    code address

  Resource entry, example LinkOptions.CodeStartAddress:
  offset    value         meaning                         CONST
   0        000000000H    entry type: proc = 1, 2, ...
   4        065646F43H    "Code" as int                   EntryStringOffset
   8        072617453H    "Star" as int
  12        064644174H    "tAdd" as int
  16        000736572H    "res" + OX as int
  20        010000344H    code address                    EntryAddrOffset

  Module block:
  module 0 (type = 0)
    procedure 1 (type = 1)
    procedure 2 (type = 2)
    ...
    procedure .init (type = n)
  module 1 (type = 0)
    procedure 1 (type = 1)
    procedure 2 (type = 2)
    ...
    procedure .init (type = n)

  Notes:
  * Entry  type:
    module = 0
    procedure > 0, ie. 1, 2, 3, ... enumerated within module
  * Entry string is terminated by a null char.
  * Hence max string length is (4 x 4) - 1 = 15 chars
  * Entry string memory addresses can contain garbage, but this is always separated
    by a null char from the entry string, for example:
    0696E692EH  ".ini"
    072610074H  "t"     <= null char here: '0074'
    064644174H  "tAdd"  <= garbage
    000736572H  "res"
  * Resource name is not null-terminated.
  * The last entry is always the program's '.init' procedure. Any 'bl.w' address beyond the
    .inits code address cannot be identified, namely in the start-up sequence.
**)

  IMPORT SYSTEM, Config;

  CONST
    ProgResName = ".ref";
.     4  010002D10  06665722E  <String: ".ref">
.     8  010002D14  000000000  <String: "....">
    ResId = 05237424FH; (* "OB7R" little endian *)
    ResVersion = 1;

    ResVersionOffset = 4;
    ResNameOffset = 8;
    ResSizeOffset = 20;
    ResDataOffset = 24;

    EntrySize = 6 * 4;

    EntryStringOffset = 4;
    EntryAddrOffset = 5 * 4;
    NextEntryAddrOffset = EntryAddrOffset + EntrySize;
    EntryStringLen = 16;
    EntryTypeModule = 0;

  TYPE
    ResName = ARRAY 12 OF CHAR;
    EntryString* = ARRAY EntryStringLen OF CHAR;

    ProgDataRes = RECORD
      resAddr: INTEGER;
      dataBeginAddr: INTEGER;
      dataEndAddr: INTEGER;
      size: INTEGER
    END;
.    12  010002D18  010002D18      00010  <Type:   16>
.    16  010002D1C  010002D1C      00000  <Type:   0>
.    20  010002D20  010002D20      00000  <Type:   0>
.    24  010002D24  010002D24      00000  <Type:   0>
.    28  010002D28  010002D28      00000  <Type:   0>

    VAR
      progDataRes: ProgDataRes;


  PROCEDURE* FindEntry*(codeAddr: INTEGER; VAR entryAddr: INTEGER);
    VAR ca: INTEGER; found: BOOLEAN;
  BEGIN
.    32  010002D2C      0B500  push      { lr }
.    34  010002D2E      0B081  sub       sp,#4
    entryAddr := 0;
.    36  010002D30      02300  movs      r3,#0
.    38  010002D32      0600B  str       r3,[r1]
    IF progDataRes.resAddr # 0 THEN
.    40  010002D34  0F8DF3088  ldr.w     r3,[pc,#136] -> 180
.    44  010002D38      0681B  ldr       r3,[r3]
.    46  010002D3A      02B00  cmp       r3,#0
.    48  010002D3C  0F000803D  beq.w     122 -> 174
      found := FALSE;
.    52  010002D40      02300  movs      r3,#0
.    54  010002D42  0F88D3000  strb.w    r3,[sp]
      entryAddr := progDataRes.dataBeginAddr;
.    58  010002D46  0F8DF3078  ldr.w     r3,[pc,#120] -> 180
.    62  010002D4A      0685B  ldr       r3,[r3,#4]
.    64  010002D4C      0600B  str       r3,[r1]
      WHILE (entryAddr < progDataRes.dataEndAddr) & ~found DO
.    66  010002D4E  0F8DF3070  ldr.w     r3,[pc,#112] -> 180
.    70  010002D52      0680C  ldr       r4,[r1]
.    72  010002D54      0689B  ldr       r3,[r3,#8]
.    74  010002D56      0429C  cmp       r4,r3
.    76  010002D58  0F280802F  bge.w     94 -> 174
.    80  010002D5C  0F89D3000  ldrb.w    r3,[sp]
.    84  010002D60  0F0130F01  tst.w     r3,#1
.    88  010002D64  0F0408029  bne.w     82 -> 174
        found := entryAddr + NextEntryAddrOffset > progDataRes.dataEndAddr; (* at last entry *)
.    92  010002D68      0680B  ldr       r3,[r1]
.    94  010002D6A      0332C  adds      r3,#44
.    96  010002D6C  0F8DF4050  ldr.w     r4,[pc,#80] -> 180
.   100  010002D70      068A4  ldr       r4,[r4,#8]
.   102  010002D72      042A3  cmp       r3,r4
.   104  010002D74      0BFCC  ite       gt
.   106  010002D76  0F04F0301  movgt.w   r3,#1
.   110  010002D7A  0F04F0300  movle.w   r3,#0
.   114  010002D7E  0F88D3000  strb.w    r3,[sp]
        IF ~found THEN
.   118  010002D82  0F89D3000  ldrb.w    r3,[sp]
.   122  010002D86  0F0130F01  tst.w     r3,#1
.   126  010002D8A  0F040800B  bne.w     22 -> 152
          SYSTEM.GET(entryAddr + NextEntryAddrOffset, ca);
.   130  010002D8E      0680B  ldr       r3,[r1]
.   132  010002D90      0332C  adds      r3,#44
.   134  010002D92      0681A  ldr       r2,[r3]
          found := codeAddr < ca
        END;
.   136  010002D94      04290  cmp       r0,r2
.   138  010002D96      0BFB4  ite       lt
.   140  010002D98  0F04F0301  movlt.w   r3,#1
.   144  010002D9C  0F04F0300  movge.w   r3,#0
.   148  010002DA0  0F88D3000  strb.w    r3,[sp]
        IF ~found THEN
.   152  010002DA4  0F89D3000  ldrb.w    r3,[sp]
.   156  010002DA8  0F0130F01  tst.w     r3,#1
.   160  010002DAC  0F0408003  bne.w     6 -> 170
          entryAddr := entryAddr + EntrySize
        END
.   164  010002DB0      0680B  ldr       r3,[r1]
.   166  010002DB2      03318  adds      r3,#24
.   168  010002DB4      0600B  str       r3,[r1]
      END
.   170  010002DB6  0F7FFBFCA  b.w       -108 -> 66
    END
  END FindEntry;
.   174  010002DBA      0B001  add       sp,#4
.   176  010002DBC      0BD00  pop       { pc }
.   178  010002DBE      0BF00  nop       
.   180  010002DC0  02001FEC0  <Global: ProgData data>


  PROCEDURE* GetNextEntry*(thisEntryAddr: INTEGER; VAR nextEntryAddr: INTEGER);
  BEGIN
.   184  010002DC4      0B500  push      { lr }
    nextEntryAddr := 0;
.   186  010002DC6      02200  movs      r2,#0
.   188  010002DC8      0600A  str       r2,[r1]
    IF thisEntryAddr + NextEntryAddrOffset < progDataRes.dataEndAddr THEN
.   190  010002DCA  0F100022C  add.w     r2,r0,#44
.   194  010002DCE  0F8DF3014  ldr.w     r3,[pc,#20] -> 216
.   198  010002DD2      0689B  ldr       r3,[r3,#8]
.   200  010002DD4      0429A  cmp       r2,r3
.   202  010002DD6  0F2808003  bge.w     6 -> 212
      nextEntryAddr := thisEntryAddr + EntrySize
    END
.   206  010002DDA  0F1000218  add.w     r2,r0,#24
.   210  010002DDE      0600A  str       r2,[r1]
  END GetNextEntry;
.   212  010002DE0      0BD00  pop       { pc }
.   214  010002DE2      0BF00  nop       
.   216  010002DE4  02001FEC0  <Global: ProgData data>


  PROCEDURE* FindProcEntries*(codeAddr: INTEGER; VAR modEntryAddr, procEntryAddr: INTEGER);
  (* will return '.init' of the program for all 'codeAddr' >= .init's code address *)
  (* this is a limitation of the available program meta data *)
    VAR entryAddr, etype, ca: INTEGER; found: BOOLEAN;
  BEGIN
.   220  010002DE8      0B500  push      { lr }
.   222  010002DEA      0B081  sub       sp,#4
    IF progDataRes.resAddr # 0 THEN
.   224  010002DEC  0F8DF609C  ldr.w     r6,[pc,#156] -> 384
.   228  010002DF0      06836  ldr       r6,[r6]
.   230  010002DF2      02E00  cmp       r6,#0
.   232  010002DF4  0F0008047  beq.w     142 -> 378
      found := FALSE;
.   236  010002DF8      02600  movs      r6,#0
.   238  010002DFA  0F88D6000  strb.w    r6,[sp]
      entryAddr := progDataRes.dataBeginAddr;
.   242  010002DFE  0F8DF608C  ldr.w     r6,[pc,#140] -> 384
.   246  010002E02      06876  ldr       r6,[r6,#4]
.   248  010002E04      04633  mov       r3,r6
      modEntryAddr := 0; procEntryAddr := 0;
.   250  010002E06      02600  movs      r6,#0
.   252  010002E08      0600E  str       r6,[r1]
.   254  010002E0A      02600  movs      r6,#0
.   256  010002E0C      06016  str       r6,[r2]
      WHILE (entryAddr < progDataRes.dataEndAddr) & ~found DO
.   258  010002E0E  0F8DF607C  ldr.w     r6,[pc,#124] -> 384
.   262  010002E12      068B6  ldr       r6,[r6,#8]
.   264  010002E14      042B3  cmp       r3,r6
.   266  010002E16  0F2808036  bge.w     108 -> 378
.   270  010002E1A  0F89D6000  ldrb.w    r6,[sp]
.   274  010002E1E  0F0160F01  tst.w     r6,#1
.   278  010002E22  0F0408030  bne.w     96 -> 378
        found := entryAddr + NextEntryAddrOffset > progDataRes.dataEndAddr; (* at last entry *)
.   282  010002E26  0F103062C  add.w     r6,r3,#44
.   286  010002E2A  0F8DF7060  ldr.w     r7,[pc,#96] -> 384
.   290  010002E2E      068BF  ldr       r7,[r7,#8]
.   292  010002E30      042BE  cmp       r6,r7
.   294  010002E32      0BFCC  ite       gt
.   296  010002E34  0F04F0601  movgt.w   r6,#1
.   300  010002E38  0F04F0600  movle.w   r6,#0
.   304  010002E3C  0F88D6000  strb.w    r6,[sp]
        IF ~found THEN
.   308  010002E40  0F89D6000  ldrb.w    r6,[sp]
.   312  010002E44  0F0160F01  tst.w     r6,#1
.   316  010002E48  0F040800B  bne.w     22 -> 342
          SYSTEM.GET(entryAddr + NextEntryAddrOffset, ca);
.   320  010002E4C  0F103062C  add.w     r6,r3,#44
.   324  010002E50      06835  ldr       r5,[r6]
          found := codeAddr < ca
        END;
.   326  010002E52      042A8  cmp       r0,r5
.   328  010002E54      0BFB4  ite       lt
.   330  010002E56  0F04F0601  movlt.w   r6,#1
.   334  010002E5A  0F04F0600  movge.w   r6,#0
.   338  010002E5E  0F88D6000  strb.w    r6,[sp]
        SYSTEM.GET(entryAddr, etype);
.   342  010002E62      0681C  ldr       r4,[r3]
        IF found THEN
.   344  010002E64  0F89D6000  ldrb.w    r6,[sp]
.   348  010002E68  0F0160F01  tst.w     r6,#1
.   352  010002E6C  0F0008003  beq.w     6 -> 362
          procEntryAddr := entryAddr;
.   356  010002E70      06013  str       r3,[r2]
        ELSIF etype = EntryTypeModule THEN
.   358  010002E72  0F000B804  b.w       8 -> 370
.   362  010002E76      02C00  cmp       r4,#0
.   364  010002E78  0F0408001  bne.w     2 -> 370
          modEntryAddr := entryAddr
        END;
.   368  010002E7C      0600B  str       r3,[r1]
        entryAddr := entryAddr + EntrySize
      END
.   370  010002E7E  0F1030318  add.w     r3,r3,#24
.   374  010002E82  0F7FFBFC4  b.w       -120 -> 258
    END
  END FindProcEntries;
.   378  010002E86      0B001  add       sp,#4
.   380  010002E88      0BD00  pop       { pc }
.   382  010002E8A      0BF00  nop       
.   384  010002E8C  02001FEC0  <Global: ProgData data>


  PROCEDURE* GetCodeAddr*(entryAddr: INTEGER; VAR codeAddr: INTEGER);
  BEGIN
.   388  010002E90      0B500  push      { lr }
    SYSTEM.GET(entryAddr + EntryAddrOffset, codeAddr)
.   390  010002E92  0F1000214  add.w     r2,r0,#20
  END GetCodeAddr;
.   394  010002E96      06813  ldr       r3,[r2]
.   396  010002E98      0600B  str       r3,[r1]
.   398  010002E9A      0BD00  pop       { pc }


  PROCEDURE* GetString*(entryAddr: INTEGER; VAR s: EntryString);
    VAR stringAddr, i: INTEGER; b: BYTE;
  BEGIN
.   400  010002E9C      0B500  push      { lr }
    stringAddr := entryAddr + EntryStringOffset;
.   402  010002E9E      01D05  adds      r5,r0,#4
.   404  010002EA0      0462A  mov       r2,r5
    i := 0;
.   406  010002EA2      02500  movs      r5,#0
.   408  010002EA4      0462B  mov       r3,r5
    WHILE i < EntryStringLen DO
.   410  010002EA6      02B10  cmp       r3,#16
.   412  010002EA8  0F2808009  bge.w     18 -> 434
      SYSTEM.GET(stringAddr + i, b);
.   416  010002EAC  0EB020503  add.w     r5,r2,r3
.   420  010002EB0      0782C  ldrb      r4,[r5]
      s[i] := CHR(b);
.   422  010002EB2  0EB130501  adds.w    r5,r3,r1
.   426  010002EB6      0702C  strb      r4,[r5]
      INC(i)
    END
.   428  010002EB8      03301  adds      r3,#1
.   430  010002EBA  0F7FFBFF4  b.w       -24 -> 410
  END GetString;
.   434  010002EBE      0BD00  pop       { pc }


  PROCEDURE GetNames*(modEntryAddr, procEntryAddr: INTEGER; VAR modName, procName: EntryString);
  BEGIN
.   436  010002EC0      0B50F  push      { r0, r1, r2, r3, lr }
    IF procEntryAddr # 0 THEN
.   438  010002EC2      09801  ldr       r0,[sp,#4]
.   440  010002EC4      02800  cmp       r0,#0
.   442  010002EC6  0F0008008  beq.w     16 -> 462
      GetString(procEntryAddr, procName);
.   446  010002ECA      09801  ldr       r0,[sp,#4]
.   448  010002ECC      09903  ldr       r1,[sp,#12]
.   450  010002ECE  0F7FFFFE5  bl.w      -54 -> 400
.   454  010002ED2      0E000  b         0 -> 458
.   456  010002ED4      000C0  <LineNo: 192>
    ELSE
      procName := "Unknown"
.   458  010002ED6  0F000B80E  b.w       28 -> 490
    END;
.   462  010002EDA      09803  ldr       r0,[sp,#12]
.   464  010002EDC      0A100  adr       r1,pc,#0 -> 468
.   466  010002EDE      0E003  b         6 -> 476
.   468  010002EE0  06E6B6E55  <String: "Unkn">
.   472  010002EE4  0006E776F  <String: "own.">
.   476  010002EE8  0F8512B04  ldr.w     r2,[r1],#4
.   480  010002EEC  0F8402B04  str.w     r2,[r0],#4
.   484  010002EF0  0F012427F  ands.w    r2,r2,#0FF000000H
.   488  010002EF4      0D1F8  bne.n     -16 -> 476
    IF modEntryAddr # 0 THEN
.   490  010002EF6      09800  ldr       r0,[sp]
.   492  010002EF8      02800  cmp       r0,#0
.   494  010002EFA  0F0008008  beq.w     16 -> 514
      GetString(modEntryAddr, modName)
.   498  010002EFE      09800  ldr       r0,[sp]
.   500  010002F00      09902  ldr       r1,[sp,#8]
    ELSE
.   502  010002F02  0F7FFFFCB  bl.w      -106 -> 400
.   506  010002F06      0E000  b         0 -> 510
.   508  010002F08      000C5  <LineNo: 197>
      modName := "Unknown"
.   510  010002F0A  0F000B80E  b.w       28 -> 542
    END
.   514  010002F0E      09802  ldr       r0,[sp,#8]
.   516  010002F10      0A100  adr       r1,pc,#0 -> 520
.   518  010002F12      0E003  b         6 -> 528
.   520  010002F14  06E6B6E55  <String: "Unkn">
.   524  010002F18  0006E776F  <String: "own.">
.   528  010002F1C  0F8512B04  ldr.w     r2,[r1],#4
.   532  010002F20  0F8402B04  str.w     r2,[r0],#4
.   536  010002F24  0F012427F  ands.w    r2,r2,#0FF000000H
.   540  010002F28      0D1F8  bne.n     -16 -> 528
  END GetNames;
.   542  010002F2A      0B004  add       sp,#16
.   544  010002F2C      0BD00  pop       { pc }
.   546  010002F2E      0BF00  nop       

  (* -- init -- *)

  PROCEDURE* getResName(resAddr: INTEGER; VAR name: ResName);
    VAR i, nameAddr: INTEGER; s: ARRAY 4 OF CHAR;
  BEGIN
.   548  010002F30      0B500  push      { lr }
.   550  010002F32      0B081  sub       sp,#4
    nameAddr := resAddr + ResNameOffset;
.   552  010002F34  0F1000308  add.w     r3,r0,#8
    SYSTEM.GET(nameAddr, s);
.   556  010002F38      0681C  ldr       r4,[r3]
.   558  010002F3A      09400  str       r4,[sp]
    FOR i := 0 TO 3 DO name[i] := s[i] END;
.   560  010002F3C      02400  movs      r4,#0
.   562  010002F3E      04622  mov       r2,r4
.   564  010002F40      02A03  cmp       r2,#3
.   566  010002F42  0F3008009  bgt.w     18 -> 588
.   570  010002F46  0EB120401  adds.w    r4,r2,r1
.   574  010002F4A  0EB1D0502  adds.w    r5,sp,r2
.   578  010002F4E      0782D  ldrb      r5,[r5]
.   580  010002F50      07025  strb      r5,[r4]
.   582  010002F52      03201  adds      r2,#1
.   584  010002F54  0F7FFBFF4  b.w       -24 -> 564
    INC(nameAddr, 4);
.   588  010002F58      03304  adds      r3,#4
    SYSTEM.GET(nameAddr, s);
.   590  010002F5A      0681C  ldr       r4,[r3]
.   592  010002F5C      09400  str       r4,[sp]
    FOR i := 0 TO 3 DO name[i + 4] := s[i] END;
.   594  010002F5E      02400  movs      r4,#0
.   596  010002F60      04622  mov       r2,r4
.   598  010002F62      02A03  cmp       r2,#3
.   600  010002F64  0F300800A  bgt.w     20 -> 624
.   604  010002F68      01D14  adds      r4,r2,#4
.   606  010002F6A  0EB140401  adds.w    r4,r4,r1
.   610  010002F6E  0EB1D0502  adds.w    r5,sp,r2
.   614  010002F72      0782D  ldrb      r5,[r5]
.   616  010002F74      07025  strb      r5,[r4]
.   618  010002F76      03201  adds      r2,#1
.   620  010002F78  0F7FFBFF3  b.w       -26 -> 598
    name[8] := 0X
  END getResName;
.   624  010002F7C      02400  movs      r4,#0
.   626  010002F7E      0720C  strb      r4,[r1,#8]
.   628  010002F80      0B001  add       sp,#4
.   630  010002F82      0BD00  pop       { pc }


  PROCEDURE getProgDataRes(VAR res: ProgDataRes);
    VAR resAddr, resSize, resId, resVersion: INTEGER; found: BOOLEAN; resName: ResName;
  BEGIN
.   632  010002F84      0B503  push      { r0, r1, lr }
.   634  010002F86      0B088  sub       sp,#32
    CLEAR(res);
.   636  010002F88      09808  ldr       r0,[sp,#32]
.   638  010002F8A      02100  movs      r1,#0
.   640  010002F8C      02204  movs      r2,#4
.   642  010002F8E      0BF00  nop       
.   644  010002F90  0F8401B04  str.w     r1,[r0],#4
.   648  010002F94      03A01  subs      r2,#1
.   650  010002F96      0DCFB  bgt.n     -10 -> 644
    resAddr := Config.ResMem.start;
.   652  010002F98  0F8DF00D8  ldr.w     r0,[pc,#216] -> 872
.   656  010002F9C      06800  ldr       r0,[r0]
.   658  010002F9E      09000  str       r0,[sp]
    SYSTEM.GET(resAddr, resId);
.   660  010002FA0      09800  ldr       r0,[sp]
.   662  010002FA2      06801  ldr       r1,[r0]
.   664  010002FA4      09102  str       r1,[sp,#8]
    SYSTEM.GET(resAddr + ResVersionOffset, resVersion);
.   666  010002FA6      09800  ldr       r0,[sp]
.   668  010002FA8      03004  adds      r0,#4
.   670  010002FAA      06801  ldr       r1,[r0]
.   672  010002FAC      09103  str       r1,[sp,#12]
    IF (resId = ResId) & (resVersion = ResVersion) THEN
.   674  010002FAE      09802  ldr       r0,[sp,#8]
.   676  010002FB0  0F8DF10BC  ldr.w     r1,[pc,#188] -> 868
.   680  010002FB4      04288  cmp       r0,r1
.   682  010002FB6  0F0408058  bne.w     176 -> 862
.   686  010002FBA      09803  ldr       r0,[sp,#12]
.   688  010002FBC      02801  cmp       r0,#1
.   690  010002FBE  0F0408054  bne.w     168 -> 862
      found := FALSE;
.   694  010002FC2      02000  movs      r0,#0
.   696  010002FC4  0F88D0010  strb.w    r0,[sp,#16]
      WHILE (resId = ResId) & ~found DO
.   700  010002FC8      09802  ldr       r0,[sp,#8]
.   702  010002FCA  0F8DF10A4  ldr.w     r1,[pc,#164] -> 868
.   706  010002FCE      04288  cmp       r0,r1
.   708  010002FD0  0F040804B  bne.w     150 -> 862
.   712  010002FD4  0F89D0010  ldrb.w    r0,[sp,#16]
.   716  010002FD8  0F0100F01  tst.w     r0,#1
.   720  010002FDC  0F0408045  bne.w     138 -> 862
        getResName(resAddr, resName);
.   724  010002FE0      09800  ldr       r0,[sp]
.   726  010002FE2  0F11D0114  adds.w    r1,sp,#20
.   730  010002FE6  0F7FFFFA3  bl.w      -186 -> 548
.   734  010002FEA      0E000  b         0 -> 738
.   736  010002FEC      000E4  <LineNo: 228>
        SYSTEM.GET(resAddr + ResSizeOffset, resSize);
.   738  010002FEE      09800  ldr       r0,[sp]
.   740  010002FF0      03014  adds      r0,#20
.   742  010002FF2      06801  ldr       r1,[r0]
.   744  010002FF4      09101  str       r1,[sp,#4]
        found := resName = ProgResName;
.   746  010002FF6      02000  movs      r0,#0
.   748  010002FF8  0F11D0114  adds.w    r1,sp,#20
.   752  010002FFC      0467B  mov       r3,pc
.   754  010002FFE  0F5B3723C  subs.w    r2,r3,#752
.   758  010003002  0F8113000  ldrb.w    r3,[r1,r0]
.   762  010003006  0F8124000  ldrb.w    r4,[r2,r0]
.   766  01000300A      03001  adds      r0,#1
.   768  01000300C      042A3  cmp       r3,r4
.   770  01000300E  0F0408003  bne.w     6 -> 780
.   774  010003012  0F1B30F00  cmp.w     r3,#0
.   778  010003016      0D1F4  bne.n     -24 -> 758
.   780  010003018      0BF0C  ite       eq
.   782  01000301A  0F04F0001  moveq.w   r0,#1
.   786  01000301E  0F04F0000  movne.w   r0,#0
.   790  010003022  0F88D0010  strb.w    r0,[sp,#16]
        IF found THEN
.   794  010003026  0F89D0010  ldrb.w    r0,[sp,#16]
.   798  01000302A  0F0100F01  tst.w     r0,#1
.   802  01000302E  0F0008012  beq.w     36 -> 842
          res.resAddr := resAddr;
.   806  010003032      09800  ldr       r0,[sp]
.   808  010003034      09908  ldr       r1,[sp,#32]
.   810  010003036      06008  str       r0,[r1]
          res.size := resSize;
.   812  010003038      09801  ldr       r0,[sp,#4]
.   814  01000303A      09908  ldr       r1,[sp,#32]
.   816  01000303C      060C8  str       r0,[r1,#12]
          res.dataBeginAddr := resAddr + ResDataOffset;
.   818  01000303E      09800  ldr       r0,[sp]
.   820  010003040      03018  adds      r0,#24
.   822  010003042      09908  ldr       r1,[sp,#32]
.   824  010003044      06048  str       r0,[r1,#4]
          res.dataEndAddr := res.dataBeginAddr + resSize;
.   826  010003046      09808  ldr       r0,[sp,#32]
.   828  010003048      06840  ldr       r0,[r0,#4]
.   830  01000304A      09901  ldr       r1,[sp,#4]
.   832  01000304C      04408  add       r0,r1
.   834  01000304E      09908  ldr       r1,[sp,#32]
.   836  010003050      06088  str       r0,[r1,#8]
        ELSE
          resAddr := resAddr + ResDataOffset + resSize;
.   838  010003052  0F000B808  b.w       16 -> 858
.   842  010003056      09800  ldr       r0,[sp]
.   844  010003058      03018  adds      r0,#24
.   846  01000305A      09901  ldr       r1,[sp,#4]
.   848  01000305C      04408  add       r0,r1
.   850  01000305E      09000  str       r0,[sp]
          SYSTEM.GET(resAddr, resId)
        END
.   852  010003060      09800  ldr       r0,[sp]
.   854  010003062      06801  ldr       r1,[r0]
.   856  010003064      09102  str       r1,[sp,#8]
      END
.   858  010003066  0F7FFBFAF  b.w       -162 -> 700
    END
  END getProgDataRes;
.   862  01000306A      0B00A  add       sp,#40
.   864  01000306C      0BD00  pop       { pc }
.   866  01000306E      0BF00  nop       
.   868  010003070  05237424F  <Const:  1379353167>
.   872  010003074  02001FF9C  <Global: Config data>

BEGIN
.   876  010003078      0B500  push      { lr }
  getProgDataRes(progDataRes)
.   878  01000307A  0F8DF001C  ldr.w     r0,[pc,#28] -> 908
.   882  01000307E      0467A  mov       r2,pc
.   884  010003080  0F8DF1010  ldr.w     r1,[pc,#16] -> 904
.   888  010003084  0EB110102  adds.w    r1,r1,r2
END ProgData.
.   892  010003088  0F7FFFF7C  bl.w      -264 -> 632
.   896  01000308C      0E000  b         0 -> 900
.   898  01000308E      000F5  <LineNo: 245>
.   900  010003090      0BD00  pop       { pc }
.   902  010003092      0BF00  nop       
.   904  010003094  0FFFFFC96  <Const:  -874>
.   908  010003098  02001FEC0  <Global: ProgData data>
 