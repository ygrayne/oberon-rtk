. <tool: Astrobe for RP2350>
. <prog: C:\Users\gray\Projects\oberon\dev\oberon-rtk\examples\v3.0\nxp\any\SignalSync\SignalSync.mod>

.     0  000000F10              <Pad: 0>
MODULE GPIO;
(**
  Oberon RTK Framework
  Version: v3.0
  --
  General Purpose IO (GPIO)
  --
  MCU: MCXA346
  --
  Copyright (c) 2023-2025 Gray gray@grayraven.org
  https://oberon-rtk.org/licences/
**)

  IMPORT SYSTEM, MCU := MCU2;


  CONST
    Enabled* = 1;
    Disabled* = 0;

    PCR_LK = 15;    (* lock *)
    PCR_INV = 13;   (* input inverter *)
    PCR_IBE = 12;   (* input buffer enable *)
    PCR_MUX_1 = 11; (* function *)
    PCR_MUX_0 = 8;
    PCR_DSE1 = 7;   (* drive strength 1, only port 3, not all pins *)
      PCR_DSE1_val_normal = 0;
      PCR_DSE1_val_double = 1;
    PCR_DSE = 6;    (* drive strength *)
      PCR_DSE_val_low = 0;
      PCR_DSE_val_high = 1;
    PCR_ODE = 5;    (* open drain enable *)
    PCR_PFE = 4;    (* passive filter enable *)
    PCR_SRE = 3;    (* slew rate *)
      PCR_SRE_val_fast = 0;
      PCR_SRE_val_slow = 1;
    PCR_PE = 1;     (* pull enable *)
    PCR_PS = 0;     (* pull select *)
      PCR_PS_val_down = 0;
      PCR_PS_val_up = 1;

    (* value aliases *)
    SlewSlow* = PCR_SRE_val_slow;
    SlewFast* = PCR_SRE_val_fast;
    DriveLow* = PCR_DSE_val_low;
    DriveHigh* = PCR_DSE_val_high;
    DriveNormal* = PCR_DSE1_val_normal;
    DriveDouble* = PCR_DSE1_val_double;
    PullDown* = PCR_PS_val_down;
    PullUp* = PCR_PS_val_up;

    (* functions *)
    (* check port map to select applicable value for a specific pin *)
    Fio0*       = 0;
    Fcan0*      = 11;
    Fclkout0*   = 1;
    Fclkout1*   = 12;
    Fcmp0*      = 8;
    Fct0*       = 4;
    Fct1*       = 5;
    Ffrqme0*    = 1;
    Ffrqme1*    = 12;
    Fi2c0*      = 2;
    Fi2c1*      = 3;
    Fpwm0*      = 5;
    Fpwm1*      = 7;
    Fsmartdma0* = 7;
    Fsmartdma1* = 10;
    Fspi0*      = 2;
    Fspi1*      = 3;
    Ftamper0*   = 13;
    Ftrig0*     = 1;
    Fuart0*     = 2;
    Fuart1*     = 3;
    Fuart2*     = 8;
    Futick0*    = 5;
    Fwuu0*      = 13;


  TYPE
    PadCfg* = RECORD            (* PCR: first value: reset/base state *)
      inputInv*: INTEGER;       (* disabled/enabled *)
      inputBufEn*: INTEGER;     (* disabled/enabled *)
      driveStrength1*: INTEGER; (* normal/double *)
      driveStrength*: INTEGER;  (* low/high *)
      openDrainEn*: INTEGER;    (* disabled/enabled *)
      filterEn*: INTEGER;       (* disabled/enabled *)
      slewRate*: INTEGER;       (* fast/slow *)
      pullEn*: INTEGER;         (* disabled/enabled *)
      pullSel*: INTEGER         (* down/up *)
    END;
.     4  000000F14      00F14      00024  <Type:   36>
.     8  000000F18      00F18      00000  <Type:   0>
.    12  000000F1C      00F1C      00000  <Type:   0>
.    16  000000F20      00F20      00000  <Type:   0>
.    20  000000F24      00F24      00000  <Type:   0>


  PROCEDURE* ConfigurePad*(pin: INTEGER; cfg: PadCfg);
    VAR pcr, val: INTEGER;
  BEGIN
.    24  000000F28      0B500  push      { lr }
    pcr := MCU.PORT0_BASE + ((pin DIV 32) * MCU.PORT_Offset);
.    26  000000F2A      01145  asrs      r5,r0,#5
.    28  000000F2C      0032D  lsls      r5,r5,#12
.    30  000000F2E  0F8DF6064  ldr.w     r6,[pc,#100] -> 132
.    34  000000F32      04435  add       r5,r6
.    36  000000F34      0462B  mov       r3,r5
    pcr := pcr + MCU.PORT_PCR_Offset + ((pin MOD 32) * 4);
.    38  000000F36  0F1030580  add.w     r5,r3,#128
.    42  000000F3A  0F000061F  and.w     r6,r0,#31
.    46  000000F3E      000B6  lsls      r6,r6,#2
.    48  000000F40      04435  add       r5,r6
.    50  000000F42      0462B  mov       r3,r5
    SYSTEM.GET(pcr, val);
.    52  000000F44      0681C  ldr       r4,[r3]
    BFI(val, PCR_INV, cfg.inputInv);
.    54  000000F46      04625  mov       r5,r4
.    56  000000F48      0680E  ldr       r6,[r1]
.    58  000000F4A  0F366344D  bfi       r4,r6,13,1
    BFI(val, PCR_IBE, cfg.inputBufEn);
.    62  000000F4E      04625  mov       r5,r4
.    64  000000F50      0684E  ldr       r6,[r1,#4]
.    66  000000F52  0F366340C  bfi       r4,r6,12,1
    BFI(val, PCR_DSE1, cfg.driveStrength1);
.    70  000000F56      04625  mov       r5,r4
.    72  000000F58      0688E  ldr       r6,[r1,#8]
.    74  000000F5A  0F36614C7  bfi       r4,r6,7,1
    BFI(val, PCR_DSE, cfg.driveStrength);
.    78  000000F5E      04625  mov       r5,r4
.    80  000000F60      068CE  ldr       r6,[r1,#12]
.    82  000000F62  0F3661486  bfi       r4,r6,6,1
    BFI(val, PCR_ODE, cfg.openDrainEn);
.    86  000000F66      04625  mov       r5,r4
.    88  000000F68      0690E  ldr       r6,[r1,#16]
.    90  000000F6A  0F3661445  bfi       r4,r6,5,1
    BFI(val, PCR_PFE, cfg.filterEn);
.    94  000000F6E      04625  mov       r5,r4
.    96  000000F70      0694E  ldr       r6,[r1,#20]
.    98  000000F72  0F3661404  bfi       r4,r6,4,1
    BFI(val, PCR_SRE, cfg.slewRate);
.   102  000000F76      04625  mov       r5,r4
.   104  000000F78      0698E  ldr       r6,[r1,#24]
.   106  000000F7A  0F36604C3  bfi       r4,r6,3,1
    BFI(val, PCR_PE, cfg.pullEn);
.   110  000000F7E      04625  mov       r5,r4
.   112  000000F80      069CE  ldr       r6,[r1,#28]
.   114  000000F82  0F3660441  bfi       r4,r6,1,1
    BFI(val, PCR_PS, cfg.pullSel);
.   118  000000F86      04625  mov       r5,r4
.   120  000000F88      06A0E  ldr       r6,[r1,#32]
.   122  000000F8A  0F3660400  bfi       r4,r6,0,1
    SYSTEM.PUT(pcr, val)
  END ConfigurePad;
.   126  000000F8E      0601C  str       r4,[r3]
.   128  000000F90      0BD00  pop       { pc }
.   130  000000F92      0BF00  nop       
.   132  000000F94  0400BC000  <Const:  1074511872>


  PROCEDURE* GetPadConfig*(pin: INTEGER; VAR pcrVal: INTEGER);
    VAR pcr: INTEGER;
  BEGIN
.   136  000000F98      0B500  push      { lr }
    pcr := MCU.PORT0_BASE + ((pin DIV 32) * MCU.PORT_Offset);
.   138  000000F9A      01143  asrs      r3,r0,#5
.   140  000000F9C      0031B  lsls      r3,r3,#12
.   142  000000F9E  0F8DF401C  ldr.w     r4,[pc,#28] -> 172
.   146  000000FA2      04423  add       r3,r4
.   148  000000FA4      0461A  mov       r2,r3
    pcr := pcr + MCU.PORT_PCR_Offset + ((pin MOD 32) * 4);
.   150  000000FA6  0F1020380  add.w     r3,r2,#128
.   154  000000FAA  0F000041F  and.w     r4,r0,#31
.   158  000000FAE      000A4  lsls      r4,r4,#2
.   160  000000FB0      04423  add       r3,r4
.   162  000000FB2      0461A  mov       r2,r3
    SYSTEM.GET(pcr, pcrVal)
  END GetPadConfig;
.   164  000000FB4      06813  ldr       r3,[r2]
.   166  000000FB6      0600B  str       r3,[r1]
.   168  000000FB8      0BD00  pop       { pc }
.   170  000000FBA      0BF00  nop       
.   172  000000FBC  0400BC000  <Const:  1074511872>


  PROCEDURE* GetPadBaseCfg*(VAR cfg: PadCfg);
  BEGIN
.   176  000000FC0      0B500  push      { lr }
    CLEAR(cfg)
  END GetPadBaseCfg;
.   178  000000FC2      04602  mov       r2,r0
.   180  000000FC4      02300  movs      r3,#0
.   182  000000FC6      02409  movs      r4,#9
.   184  000000FC8  0F8423B04  str.w     r3,[r2],#4
.   188  000000FCC      03C01  subs      r4,#1
.   190  000000FCE      0DCFB  bgt.n     -10 -> 184
.   192  000000FD0      0BD00  pop       { pc }
.   194  000000FD2      0BF00  nop       


  PROCEDURE* LockPad*(pin: INTEGER);
    VAR pcr, val: INTEGER;
  BEGIN
.   196  000000FD4      0B500  push      { lr }
    pcr := MCU.PORT0_BASE + ((pin DIV 32) * MCU.PORT_Offset);
.   198  000000FD6      01143  asrs      r3,r0,#5
.   200  000000FD8      0031B  lsls      r3,r3,#12
.   202  000000FDA  0F8DF4024  ldr.w     r4,[pc,#36] -> 240
.   206  000000FDE      04423  add       r3,r4
.   208  000000FE0      04619  mov       r1,r3
    pcr := pcr + MCU.PORT_PCR_Offset + ((pin MOD 32) * 4);
.   210  000000FE2  0F1010380  add.w     r3,r1,#128
.   214  000000FE6  0F000041F  and.w     r4,r0,#31
.   218  000000FEA      000A4  lsls      r4,r4,#2
.   220  000000FEC      04423  add       r3,r4
.   222  000000FEE      04619  mov       r1,r3
    SYSTEM.GET(pcr, val);
.   224  000000FF0      0680A  ldr       r2,[r1]
    BFI(val, PCR_LK, Enabled);
.   226  000000FF2      04613  mov       r3,r2
.   228  000000FF4      02401  movs      r4,#1
.   230  000000FF6  0F36432CF  bfi       r2,r4,15,1
    SYSTEM.PUT(pcr, val)
  END LockPad;
.   234  000000FFA      0600A  str       r2,[r1]
.   236  000000FFC      0BD00  pop       { pc }
.   238  000000FFE      0BF00  nop       
.   240  000001000  0400BC000  <Const:  1074511872>


  PROCEDURE* SetFunction*(pin, function: INTEGER);
    VAR pcr, val: INTEGER;
  BEGIN
.   244  000001004      0B500  push      { lr }
    pcr := MCU.PORT0_BASE + ((pin DIV 32) * MCU.PORT_Offset);
.   246  000001006      01144  asrs      r4,r0,#5
.   248  000001008      00324  lsls      r4,r4,#12
.   250  00000100A  0F8DF5020  ldr.w     r5,[pc,#32] -> 284
.   254  00000100E      0442C  add       r4,r5
.   256  000001010      04622  mov       r2,r4
    pcr := pcr + MCU.PORT_PCR_Offset + ((pin MOD 32) * 4);
.   258  000001012  0F1020480  add.w     r4,r2,#128
.   262  000001016  0F000051F  and.w     r5,r0,#31
.   266  00000101A      000AD  lsls      r5,r5,#2
.   268  00000101C      0442C  add       r4,r5
.   270  00000101E      04622  mov       r2,r4
    SYSTEM.GET(pcr, val);
.   272  000001020      06813  ldr       r3,[r2]
    BFI(val, PCR_MUX_1, PCR_MUX_0, function);
.   274  000001022      0461C  mov       r4,r3
.   276  000001024  0F361230B  bfi       r3,r1,8,4
    SYSTEM.PUT(pcr, val)
  END SetFunction;
.   280  000001028      06013  str       r3,[r2]
.   282  00000102A      0BD00  pop       { pc }
.   284  00000102C  0400BC000  <Const:  1074511872>


  PROCEDURE* ConnectInput*(pin: INTEGER);
  END ConnectInput;
.   288  000001030      0B500  push      { lr }
.   290  000001032      0BD00  pop       { pc }


  (* GPIO control *)
  (* function 'Fio' *)
  (* parameter 'gpio': MCU.GPIOx *)

  PROCEDURE* Set*(gpio: INTEGER; mask: SET);
  BEGIN
.   292  000001034      0B500  push      { lr }
    SYSTEM.PUT(gpio + MCU.GPIO_PSOR_Offset, mask)
.   294  000001036  0F1000244  add.w     r2,r0,#68
  END Set;
.   298  00000103A      06011  str       r1,[r2]
.   300  00000103C      0BD00  pop       { pc }
.   302  00000103E      0BF00  nop       


  PROCEDURE* Clear*(gpio: INTEGER; mask: SET);
  BEGIN
.   304  000001040      0B500  push      { lr }
    SYSTEM.PUT(gpio + MCU.GPIO_PCOR_Offset, mask)
.   306  000001042  0F1000248  add.w     r2,r0,#72
  END Clear;
.   310  000001046      06011  str       r1,[r2]
.   312  000001048      0BD00  pop       { pc }
.   314  00000104A      0BF00  nop       


  PROCEDURE* Toggle*(gpio: INTEGER; mask: SET);
  BEGIN
.   316  00000104C      0B500  push      { lr }
    SYSTEM.PUT(gpio + MCU.GPIO_PTOR_Offset, mask)
.   318  00000104E  0F100024C  add.w     r2,r0,#76
  END Toggle;
.   322  000001052      06011  str       r1,[r2]
.   324  000001054      0BD00  pop       { pc }
.   326  000001056      0BF00  nop       


  PROCEDURE* EnableOutput*(gpio: INTEGER; mask: SET);
    VAR addr: INTEGER; val: SET;
  BEGIN
.   328  000001058      0B500  push      { lr }
    addr := gpio + MCU.GPIO_PDDR_Offset;
.   330  00000105A  0F1000254  add.w     r2,r0,#84
    SYSTEM.GET(addr, val);
.   334  00000105E      06813  ldr       r3,[r2]
    val := val + mask;
.   336  000001060  0EA530401  orrs.w    r4,r3,r1
.   340  000001064      04623  mov       r3,r4
    SYSTEM.PUT(addr, val)
  END EnableOutput;
.   342  000001066      06013  str       r3,[r2]
.   344  000001068      0BD00  pop       { pc }
.   346  00000106A      0BF00  nop       

END GPIO.
.   348  00000106C      0B500  push      { lr }
.   350  00000106E      0BD00  pop       { pc }
 