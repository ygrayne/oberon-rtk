. <tool: Astrobe for RP2350>
. <prog: C:\Users\gray\Projects\oberon\dev\oberon-rtk\examples\v3.0\nxp\any\SignalSync\SignalSync.mod>

.     0  0100005F0              <Pad: 0>
MODULE Config;
(**
  Oberon RTK Framework
  Version: v3.0
  --
  * Memory configuration data
  * Set VTOR, install initial simple error/fault handlers
  * Set core ID register via VTOR/vector table
  * Other basic low level set-up
  --
  One core only (all SRAM allocated to core 0)
  --
  MCU: MCXN947
  Board: FRDM-MCXN947
  --
  Copyright (c) 2023-2025 Gray, gray@grayraven.org
  https://oberon-rtk.org/licences/
**)

  IMPORT SYSTEM, LinkOptions, MCU := MCU2, CLK; (* LinkOptions must be first in list *)

  CONST
    NumCoresUsed* = 1;

    ErrorLEDpinNo = 10;   (* red, port 0 *)
    LXOR = MCU.GPIO0_BASE + MCU.GPIO_PTOR_Offset;

  TYPE
    DataDesc* = RECORD
      start*, end*: INTEGER
    END;
.     4  0100005F4  0100005F4      00008  <Type:   8>
.     8  0100005F8  0100005F8      00000  <Type:   0>
.    12  0100005FC  0100005FC      00000  <Type:   0>
.    16  010000600  010000600      00000  <Type:   0>
.    20  010000604  010000604      00000  <Type:   0>

    HeapDesc* = RECORD
      start*: INTEGER;
      limit*: INTEGER
    END;
.    24  010000608  010000608      00008  <Type:   8>
.    28  01000060C  01000060C      00000  <Type:   0>
.    32  010000610  010000610      00000  <Type:   0>
.    36  010000614  010000614      00000  <Type:   0>
.    40  010000618  010000618      00000  <Type:   0>

    StackDesc* = RECORD
      start*: INTEGER
    END;
.    44  01000061C  01000061C      00004  <Type:   4>
.    48  010000620  010000620      00000  <Type:   0>
.    52  010000624  010000624      00000  <Type:   0>
.    56  010000628  010000628      00000  <Type:   0>
.    60  01000062C  01000062C      00000  <Type:   0>

    CodeDesc* = RECORD
      start*, end*: INTEGER
    END;
.    64  010000630  010000630      00008  <Type:   8>
.    68  010000634  010000634      00000  <Type:   0>
.    72  010000638  010000638      00000  <Type:   0>
.    76  01000063C  01000063C      00000  <Type:   0>
.    80  010000640  010000640      00000  <Type:   0>

    ModDesc* = RECORD (* module data space *)
      start*, end*: INTEGER
    END;
.    84  010000644  010000644      00008  <Type:   8>
.    88  010000648  010000648      00000  <Type:   0>
.    92  01000064C  01000064C      00000  <Type:   0>
.    96  010000650  010000650      00000  <Type:   0>
.   100  010000654  010000654      00000  <Type:   0>

    ResDesc* = RECORD (* resources block at the end of the binary *)
      start*: INTEGER
    END;
.   104  010000658  010000658      00004  <Type:   4>
.   108  01000065C  01000065C      00000  <Type:   0>
.   112  010000660  010000660      00000  <Type:   0>
.   116  010000664  010000664      00000  <Type:   0>
.   120  010000668  010000668      00000  <Type:   0>

    ExtDesc* = RECORD (* extended memory *)
      start*, end*: INTEGER
    END;
.   124  01000066C  01000066C      00008  <Type:   8>
.   128  010000670  010000670      00000  <Type:   0>
.   132  010000674  010000674      00000  <Type:   0>
.   136  010000678  010000678      00000  <Type:   0>
.   140  01000067C  01000067C      00000  <Type:   0>

    VectDesc* = RECORD (* vector table *)
      start*, end*: INTEGER
    END;
.   144  010000680  010000680      00008  <Type:   8>
.   148  010000684  010000684      00000  <Type:   0>
.   152  010000688  010000688      00000  <Type:   0>
.   156  01000068C  01000068C      00000  <Type:   0>
.   160  010000690  010000690      00000  <Type:   0>

  VAR
    DataMem*: ARRAY NumCoresUsed OF DataDesc;
    HeapMem*: ARRAY NumCoresUsed OF HeapDesc;
    StackMem*: ARRAY NumCoresUsed OF StackDesc;
    ExtMem*: ARRAY NumCoresUsed OF ExtDesc;
    VectMem*: ARRAY NumCoresUsed OF VectDesc;
    ModMem*: ModDesc;
    CodeMem*: CodeDesc;
    ResMem*: ResDesc;


  (* simple error/fault handlers for the startup sequence *)

  PROCEDURE initLED;
    VAR addr: INTEGER; val: SET;
  BEGIN
.   164  010000694      0B500  push      { lr }
.   166  010000696      0B082  sub       sp,#8
    CLK.EnableBusClock(MCU.DEV_PORT0);
.   168  010000698      0200D  movs      r0,#13
.   170  01000069A  0F7FFFF63  bl.w      Ext Proc #11
.   174  01000069E      0E000  b         0 -> 178
.   176  0100006A0      0004E  <LineNo: 78>
    CLK.EnableBusClock(MCU.DEV_GPIO0);
.   178  0100006A2      02013  movs      r0,#19
.   180  0100006A4  0F7FFFF5E  bl.w      Ext Proc #11
.   184  0100006A8      0E000  b         0 -> 188
.   186  0100006AA      0004F  <LineNo: 79>
    addr := MCU.GPIO0 + MCU.GPIO_PDDR_Offset;
.   188  0100006AC  0F8DF001C  ldr.w     r0,[pc,#28] -> 220
.   192  0100006B0      09000  str       r0,[sp]
    SYSTEM.GET(addr, val);
.   194  0100006B2      09800  ldr       r0,[sp]
.   196  0100006B4      06801  ldr       r1,[r0]
.   198  0100006B6      09101  str       r1,[sp,#4]
    INCL(val, ErrorLEDpinNo);
.   200  0100006B8      09801  ldr       r0,[sp,#4]
.   202  0100006BA  0F4506080  orrs.w    r0,r0,#1024
.   206  0100006BE      09001  str       r0,[sp,#4]
    SYSTEM.PUT(addr, val)
  END initLED;
.   208  0100006C0      09800  ldr       r0,[sp]
.   210  0100006C2      09901  ldr       r1,[sp,#4]
.   212  0100006C4      06001  str       r1,[r0]
.   214  0100006C6      0B002  add       sp,#8
.   216  0100006C8      0BD00  pop       { pc }
.   218  0100006CA      0BF00  nop       
.   220  0100006CC  040096054  <Const:  1074356308>


  PROCEDURE* errorHandler*[0];
    VAR i: INTEGER;
  BEGIN
.   224  0100006D0  0F84DED04  push.w    { lr }
    REPEAT
      SYSTEM.PUT(LXOR, {ErrorLEDpinNo});
.   228  0100006D4  0F8DF1024  ldr.w     r1,[pc,#36] -> 268
.   232  0100006D8  0F2404200  movw      r2,#1024
.   236  0100006DC      0600A  str       r2,[r1]
      i := 0;
.   238  0100006DE      02100  movs      r1,#0
.   240  0100006E0      04608  mov       r0,r1
      WHILE i < 1000000 DO INC(i) END
.   242  0100006E2  0F8DF201C  ldr.w     r2,[pc,#28] -> 272
.   246  0100006E6      04290  cmp       r0,r2
.   248  0100006E8  0F2808003  bge.w     6 -> 258
.   252  0100006EC      03001  adds      r0,#1
.   254  0100006EE  0F7FFBFF8  b.w       -16 -> 242
    UNTIL FALSE
  END errorHandler;
.   258  0100006F2      04280  cmp       r0,r0
.   260  0100006F4  0F43FAFEE  beq.w     -36 -> 228
.   264  0100006F8  0F85DFB04  pop.w     { pc }
.   268  0100006FC  04009604C  <Const:  1074356300>
.   272  010000700  0000F4240  <Const:  1000000>


  PROCEDURE* faultHandler*[0];
    VAR i: INTEGER;
  BEGIN
.   276  010000704  0F84DED04  push.w    { lr }
    REPEAT
      SYSTEM.PUT(LXOR, {ErrorLEDpinNo});
.   280  010000708  0F8DF1024  ldr.w     r1,[pc,#36] -> 320
.   284  01000070C  0F2404200  movw      r2,#1024
.   288  010000710      0600A  str       r2,[r1]
      i := 0;
.   290  010000712      02100  movs      r1,#0
.   292  010000714      04608  mov       r0,r1
      WHILE i < 5000000 DO INC(i) END
.   294  010000716  0F8DF201C  ldr.w     r2,[pc,#28] -> 324
.   298  01000071A      04290  cmp       r0,r2
.   300  01000071C  0F2808003  bge.w     6 -> 310
.   304  010000720      03001  adds      r0,#1
.   306  010000722  0F7FFBFF8  b.w       -16 -> 294
    UNTIL FALSE
  END faultHandler;
.   310  010000726      04280  cmp       r0,r0
.   312  010000728  0F43FAFEE  beq.w     -36 -> 280
.   316  01000072C  0F85DFB04  pop.w     { pc }
.   320  010000730  04009604C  <Const:  1074356300>
.   324  010000734  0004C4B40  <Const:  5000000>


  PROCEDURE* install(vectAddr: INTEGER; p: PROCEDURE);
  BEGIN
.   328  010000738      0B500  push      { lr }
    INCL(SYSTEM.VAL(SET, p), 0); (* thumb code *)
.   330  01000073A  0F0510101  orrs.w    r1,r1,#1
    SYSTEM.PUT(vectAddr, p)
  END install;
.   334  01000073E      06001  str       r1,[r0]
.   336  010000740      0BD00  pop       { pc }
.   338  010000742      0BF00  nop       


  PROCEDURE init;
    CONST Core0 = 0;
    VAR vtor: INTEGER;
  BEGIN
.   340  010000744      0B500  push      { lr }
.   342  010000746      0B081  sub       sp,#4
    (* core 0 *)
    DataMem[Core0].start := LinkOptions.DataStart;
.   344  010000748  0F8DF0144  ldr.w     r0,[pc,#324] -> 672
.   348  01000074C  0F8DF1120  ldr.w     r1,[pc,#288] -> 640
.   352  010000750      06809  ldr       r1,[r1]
.   354  010000752      06001  str       r1,[r0]
    DataMem[Core0].end := LinkOptions.DataEnd;
.   356  010000754  0F8DF0138  ldr.w     r0,[pc,#312] -> 672
.   360  010000758  0F8DF1118  ldr.w     r1,[pc,#280] -> 644
.   364  01000075C      06809  ldr       r1,[r1]
.   366  01000075E      06041  str       r1,[r0,#4]
    HeapMem[Core0].start := LinkOptions.HeapStart;
.   368  010000760  0F8DF0130  ldr.w     r0,[pc,#304] -> 676
.   372  010000764  0F8DF1110  ldr.w     r1,[pc,#272] -> 648
.   376  010000768      06809  ldr       r1,[r1]
.   378  01000076A      06001  str       r1,[r0]
    HeapMem[Core0].limit := LinkOptions.HeapLimit;
.   380  01000076C  0F8DF0124  ldr.w     r0,[pc,#292] -> 676
.   384  010000770  0F8DF1108  ldr.w     r1,[pc,#264] -> 652
.   388  010000774      06809  ldr       r1,[r1]
.   390  010000776      06041  str       r1,[r0,#4]
    StackMem[Core0].start := LinkOptions.StackStart;
.   392  010000778  0F8DF011C  ldr.w     r0,[pc,#284] -> 680
.   396  01000077C  0F8DF1100  ldr.w     r1,[pc,#256] -> 656
.   400  010000780      06809  ldr       r1,[r1]
.   402  010000782      06001  str       r1,[r0]
    ExtMem[Core0].start := MCU.SRAM_X_S_BASE;
.   404  010000784  0F8DF0114  ldr.w     r0,[pc,#276] -> 684
.   408  010000788  0F04F51A0  mov.w     r1,#014000000H
.   412  01000078C      06001  str       r1,[r0]
    ExtMem[Core0].end := MCU.SRAM_X_S_BASE + MCU.SRAM_X_Size;
.   414  01000078E  0F8DF010C  ldr.w     r0,[pc,#268] -> 684
.   418  010000792  0F8DF10CC  ldr.w     r1,[pc,#204] -> 624
.   422  010000796      06041  str       r1,[r0,#4]
    VectMem[Core0].start := DataMem[Core0].start;
.   424  010000798  0F8DF0104  ldr.w     r0,[pc,#260] -> 688
.   428  01000079C  0F8DF10F0  ldr.w     r1,[pc,#240] -> 672
.   432  0100007A0      06809  ldr       r1,[r1]
.   434  0100007A2      06001  str       r1,[r0]
    VectMem[Core0].end := VectMem[Core0].start + MCU.VectorTableSize;
.   436  0100007A4  0F8DF00F8  ldr.w     r0,[pc,#248] -> 688
.   440  0100007A8  0F8DF10F4  ldr.w     r1,[pc,#244] -> 688
.   444  0100007AC      06809  ldr       r1,[r1]
.   446  0100007AE  0F501712C  add.w     r1,r1,#688
.   450  0100007B2      06041  str       r1,[r0,#4]

    (* common *)
    CodeMem.start := LinkOptions.CodeStart;
.   452  0100007B4  0F8DF00EC  ldr.w     r0,[pc,#236] -> 692
.   456  0100007B8  0F8DF10C8  ldr.w     r1,[pc,#200] -> 660
.   460  0100007BC      06809  ldr       r1,[r1]
.   462  0100007BE      06001  str       r1,[r0]
    CodeMem.end := LinkOptions.CodeEnd;
.   464  0100007C0  0F8DF00E0  ldr.w     r0,[pc,#224] -> 692
.   468  0100007C4  0F8DF10C0  ldr.w     r1,[pc,#192] -> 664
.   472  0100007C8      06809  ldr       r1,[r1]
.   474  0100007CA      06041  str       r1,[r0,#4]
    ResMem.start := LinkOptions.ResourceStart;
.   476  0100007CC  0F8DF00D8  ldr.w     r0,[pc,#216] -> 696
.   480  0100007D0  0F8DF10B8  ldr.w     r1,[pc,#184] -> 668
.   484  0100007D4      06809  ldr       r1,[r1]
.   486  0100007D6      06001  str       r1,[r0]
    ModMem.start := StackMem[Core0].start + 04H;
.   488  0100007D8  0F8DF00D0  ldr.w     r0,[pc,#208] -> 700
.   492  0100007DC  0F8DF10B8  ldr.w     r1,[pc,#184] -> 680
.   496  0100007E0      06809  ldr       r1,[r1]
.   498  0100007E2      03104  adds      r1,#4
.   500  0100007E4      06001  str       r1,[r0]
    ModMem.end := DataMem[Core0].end;
.   502  0100007E6  0F8DF00C4  ldr.w     r0,[pc,#196] -> 700
.   506  0100007EA  0F8DF10A4  ldr.w     r1,[pc,#164] -> 672
.   510  0100007EE      06849  ldr       r1,[r1,#4]
.   512  0100007F0      06041  str       r1,[r0,#4]


    (* VTOR and initial simple error/fault handlers *)
    (* UsageFault and friends are not enabled yet and escalate to HardFault *)
    vtor := VectMem[Core0].start;
.   514  0100007F2  0F8DF00AC  ldr.w     r0,[pc,#172] -> 688
.   518  0100007F6      06800  ldr       r0,[r0]
.   520  0100007F8      09000  str       r0,[sp]
    SYSTEM.PUT(MCU.PPB_VTOR, vtor);
.   522  0100007FA  0F8DF0068  ldr.w     r0,[pc,#104] -> 628
.   526  0100007FE      09900  ldr       r1,[sp]
.   528  010000800      06001  str       r1,[r0]
    SYSTEM.EMIT(MCU.DSB); SYSTEM.EMIT(MCU.ISB);
.   530  010000802  0F3BF8F4F  dsb       
.   534  010000806  0F3BF8F6F  isb       
    install(vtor + MCU.EXC_NMI_Offset, faultHandler);
.   538  01000080A      09800  ldr       r0,[sp]
.   540  01000080C      03008  adds      r0,#8
.   542  01000080E      0BF00  nop       
.   544  010000810  0F2AF1110  adr.w     r1,pc,#-272 -> 276
.   548  010000814  0F7FFFF90  bl.w      -224 -> 328
.   552  010000818      0E000  b         0 -> 556
.   554  01000081A      00090  <LineNo: 144>
    install(vtor + MCU.EXC_HardFault_Offset, faultHandler);
.   556  01000081C      09800  ldr       r0,[sp]
.   558  01000081E      0300C  adds      r0,#12
.   560  010000820  0F2AF1120  adr.w     r1,pc,#-288 -> 276
.   564  010000824  0F7FFFF88  bl.w      -240 -> 328
.   568  010000828      0E000  b         0 -> 572
.   570  01000082A      00091  <LineNo: 145>
    install(vtor + MCU.EXC_SVC_Offset, errorHandler);
.   572  01000082C      09800  ldr       r0,[sp]
.   574  01000082E      0302C  adds      r0,#44
.   576  010000830  0F2AF1164  adr.w     r1,pc,#-356 -> 224
.   580  010000834  0F7FFFF80  bl.w      -256 -> 328
.   584  010000838      0E000  b         0 -> 588
.   586  01000083A      00092  <LineNo: 146>
    initLED;
.   588  01000083C  0F7FFFF2A  bl.w      -428 -> 164
.   592  010000840      0E000  b         0 -> 596
.   594  010000842      00093  <LineNo: 147>

    (* the MCXN947 does not provide a register to get the core ID *)
    (* use value at address 0H of vector table as core ID *)
    (* see Cores.GetCoreId *)
    SYSTEM.PUT(vtor, Core0);
.   596  010000844      09800  ldr       r0,[sp]
.   598  010000846      02100  movs      r1,#0
.   600  010000848      06001  str       r1,[r0]

    (* disble glitch detectors *)
    SYSTEM.PUT(MCU.GDET0_BASE + MCU.GDET_ENABLE1_Offset, 0);
.   602  01000084A  0F8DF001C  ldr.w     r0,[pc,#28] -> 632
.   606  01000084E      02100  movs      r1,#0
.   608  010000850      06001  str       r1,[r0]
    SYSTEM.PUT(MCU.GDET1_BASE + MCU.GDET_ENABLE1_Offset, 0)
  END init;
.   610  010000852  0F8DF0018  ldr.w     r0,[pc,#24] -> 636
.   614  010000856      02100  movs      r1,#0
.   616  010000858      06001  str       r1,[r0]
.   618  01000085A      0B001  add       sp,#4
.   620  01000085C      0BD00  pop       { pc }
.   622  01000085E      0BF00  nop       
.   624  010000860  014018000  <Const:  335642624>
.   628  010000864  0E000ED08  <Const:  -536810232>
.   632  010000868  040024008  <Const:  1073889288>
.   636  01000086C  040025008  <Const:  1073893384>
.   640  010000870  02001FFE4  <Global: LinkOptions data>
.   644  010000874  02001FFE0  <Global: LinkOptions data>
.   648  010000878  02001FFF4  <Global: LinkOptions data>
.   652  01000087C  02001FFF0  <Global: LinkOptions data>
.   656  010000880  02001FFEC  <Global: LinkOptions data>
.   660  010000884  02001FFD8  <Global: LinkOptions data>
.   664  010000888  02001FFD4  <Global: LinkOptions data>
.   668  01000088C  02001FFE8  <Global: LinkOptions data>
.   672  010000890  02001FFCC  <Global: Config data>
.   676  010000894  02001FFC4  <Global: Config data>
.   680  010000898  02001FFC0  <Global: Config data>
.   684  01000089C  02001FFB8  <Global: Config data>
.   688  0100008A0  02001FFB0  <Global: Config data>
.   692  0100008A4  02001FFA0  <Global: Config data>
.   696  0100008A8  02001FF9C  <Global: Config data>
.   700  0100008AC  02001FFA8  <Global: Config data>

BEGIN
.   704  0100008B0      0B500  push      { lr }
  init
END Config.
.   706  0100008B2  0F7FFFF47  bl.w      -370 -> 340
.   710  0100008B6      0E000  b         0 -> 714
.   712  0100008B8      000A0  <LineNo: 160>
.   714  0100008BA      0BD00  pop       { pc }
 