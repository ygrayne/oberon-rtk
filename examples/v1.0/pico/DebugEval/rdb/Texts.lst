.     0  <Pad: 0>
MODULE Texts;
(**
  Oberon RTK Framework
  --
  Formatted output to a "channel", using a 'TextIO.Writer'
  Formatted input from a "channel", using a 'TextIO.Reader'
  --
  The behaviour of the procedures depends on the write string and read
  procedures allocated to 'W' and 'R' parameters:
  * blocking
  * non-blocking (using the kernel)
  --
  Copyright (c) 2020 - 2024 Gray gray@grayraven.org
  https://oberon-rtk.org/licences/
**)

  IMPORT TextIO, Errors;

  CONST
    CR = 0DX;
    LF = 0AX;
    Blanks = "                                "; (* 32 blanks *)
.     4  <String: "    ">
.     8  <String: "    ">
.    12  <String: "    ">
.    16  <String: "    ">
.    20  <String: "    ">
.    24  <String: "    ">
.    28  <String: "    ">
.    32  <String: "    ">
.    36  <String: "....">
    MaxBlanks = 32;

    (* conversion constants *)
    MaxInt* = 07FFFFFFFH; (*  2,147,483,647 *)
    MinInt* = 080000000H; (* -2,147,483,648 *)
    MaxIntDigits* = 10;   (* sans sign, sans leading zeros *)

    (* read results *)
    NoError* = TextIO.NoError;
    BufferOverflow* = TextIO.BufferOverflow; (* a tool small buffer was provided or used *)
    SyntaxError* = TextIO.SyntaxError;      (* zero length or non-numerical chars *)
    OutOfLimits* = TextIO.OutOfLimits;    (* bigger than MaxInt, smaller than MinInt *)
    NoInput* = TextIO.NoInput;
    FifoOverrun* = TextIO.FifoOverrun;

  VAR eol: ARRAY 2 OF CHAR;

  (* write conversions *)

  PROCEDURE IntToString*(int: INTEGER; VAR str: ARRAY OF CHAR; VAR slen: INTEGER);
    VAR spos, dpos: INTEGER; digits: ARRAY 10 OF CHAR;
  BEGIN
.    40    028H  0B50FH          push     { r0, r1, r2, r3, lr }
.    42    02AH  0B085H          sub      sp,#20
    ASSERT(LEN(str) >= 12, Errors.PreCond); (* 10 digits, minus sign, 0X *)
.    44    02CH  09807H          ldr      r0,[sp,#28]
.    46    02EH  0280CH          cmp      r0,#12
.    48    030H  0DA01H          bge.n    2 -> 54
.    50    032H  0DF65H          svc      101
.    52  <LineNo: 45>
    IF int = 080000000H THEN
.    54    036H  09805H          ldr      r0,[sp,#20]
.    56    038H  0494FH          ldr      r1,[pc,#316] -> 376
.    58    03AH  042C8H          cmn      r0,r1
.    60    03CH  0D001H          beq.n    2 -> 66
.    62    03EH  0E025H          b        74 -> 140
.    64    040H  046C0H          nop
      str := "-2147483648";
.    66    042H  0200CH          movs     r0,#12
.    68    044H  09907H          ldr      r1,[sp,#28]
.    70    046H  04281H          cmp      r1,r0
.    72    048H  0DA01H          bge.n    2 -> 78
.    74    04AH  0DF06H          svc      6
.    76  <LineNo: 47>
.    78    04EH  09806H          ldr      r0,[sp,#24]
.    80    050H  0A100H          adr      r1,pc,#0 -> 84
.    82    052H  0E005H          b        10 -> 96
.    84  <String: "-214">
.    88  <String: "7483">
.    92  <String: "648.">
.    96    060H  04B46H          ldr      r3,[pc,#280] -> 380
.    98    062H  0680AH          ldr      r2,[r1]
.   100    064H  03104H          adds     r1,#4
.   102    066H  06002H          str      r2,[r0]
.   104    068H  03004H          adds     r0,#4
.   106    06AH  0401AH          ands     r2,r3
.   108    06CH  0D1F9H          bne.n    -14 -> 98
      str[11] := 0X;
.   110    06EH  0200BH          movs     r0,#11
.   112    070H  09907H          ldr      r1,[sp,#28]
.   114    072H  04288H          cmp      r0,r1
.   116    074H  0D301H          bcc.n    2 -> 122
.   118    076H  0DF01H          svc      1
.   120  <LineNo: 48>
.   122    07AH  09906H          ldr      r1,[sp,#24]
.   124    07CH  01808H          adds     r0,r1,r0
.   126    07EH  02100H          movs     r1,#0
.   128    080H  07001H          strb     r1,[r0]
      slen := 11
    ELSE
.   130    082H  0200BH          movs     r0,#11
.   132    084H  09908H          ldr      r1,[sp,#32]
.   134    086H  06008H          str      r0,[r1]
      spos := 0;
.   136    088H  0E074H          b        232 -> 372
.   138    08AH  046C0H          nop
.   140    08CH  02000H          movs     r0,#0
.   142    08EH  09000H          str      r0,[sp]
      IF int < 0 THEN
.   144    090H  09805H          ldr      r0,[sp,#20]
.   146    092H  02800H          cmp      r0,#0
.   148    094H  0DB01H          blt.n    2 -> 154
.   150    096H  0E010H          b        32 -> 186
.   152    098H  046C0H          nop
        int := -int;
.   154    09AH  09805H          ldr      r0,[sp,#20]
.   156    09CH  04240H          rsbs     r0,r0,#0
.   158    09EH  09005H          str      r0,[sp,#20]
        str[spos] := "-";
.   160    0A0H  09800H          ldr      r0,[sp]
.   162    0A2H  09907H          ldr      r1,[sp,#28]
.   164    0A4H  04288H          cmp      r0,r1
.   166    0A6H  0D301H          bcc.n    2 -> 172
.   168    0A8H  0DF01H          svc      1
.   170  <LineNo: 54>
.   172    0ACH  09906H          ldr      r1,[sp,#24]
.   174    0AEH  01808H          adds     r0,r1,r0
.   176    0B0H  0212DH          movs     r1,#45
.   178    0B2H  07001H          strb     r1,[r0]
        INC(spos)
      END;
.   180    0B4H  09800H          ldr      r0,[sp]
.   182    0B6H  03001H          adds     r0,#1
.   184    0B8H  09000H          str      r0,[sp]
      dpos := 0;
.   186    0BAH  02000H          movs     r0,#0
.   188    0BCH  09001H          str      r0,[sp,#4]
      REPEAT
        digits[dpos] := CHR(int MOD 10 + ORD("0"));
.   190    0BEH  09801H          ldr      r0,[sp,#4]
.   192    0C0H  0280AH          cmp      r0,#10
.   194    0C2H  0D301H          bcc.n    2 -> 200
.   196    0C4H  0DF01H          svc      1
.   198  <LineNo: 59>
.   200    0C8H  04669H          mov      r1,sp
.   202    0CAH  01808H          adds     r0,r1,r0
.   204    0CCH  09905H          ldr      r1,[sp,#20]
.   206    0CEH  0220AH          movs     r2,#10
.   208    0D0H  02501H          movs     r5,#1
.   210    0D2H  007EDH          lsls     r5,r5,#31
.   212    0D4H  02300H          movs     r3,#0
.   214    0D6H  02400H          movs     r4,#0
.   216    0D8H  00049H          lsls     r1,r1,#1
.   218    0DAH  04164H          adcs     r4,r4
.   220    0DCH  04294H          cmp      r4,r2
.   222    0DEH  0D301H          bcc.n    2 -> 228
.   224    0E0H  0195BH          adds     r3,r3,r5
.   226    0E2H  01AA4H          subs     r4,r4,r2
.   228    0E4H  0086DH          lsrs     r5,r5,#1
.   230    0E6H  0D1F7H          bne.n    -18 -> 216
.   232    0E8H  04621H          mov      r1,r4
.   234    0EAH  03130H          adds     r1,#48
.   236    0ECH  07201H          strb     r1,[r0,#8]
        int := int DIV 10;
.   238    0EEH  09805H          ldr      r0,[sp,#20]
.   240    0F0H  0210AH          movs     r1,#10
.   242    0F2H  02401H          movs     r4,#1
.   244    0F4H  007E4H          lsls     r4,r4,#31
.   246    0F6H  02200H          movs     r2,#0
.   248    0F8H  02300H          movs     r3,#0
.   250    0FAH  00040H          lsls     r0,r0,#1
.   252    0FCH  0415BH          adcs     r3,r3
.   254    0FEH  0428BH          cmp      r3,r1
.   256   0100H  0D301H          bcc.n    2 -> 262
.   258   0102H  01912H          adds     r2,r2,r4
.   260   0104H  01A5BH          subs     r3,r3,r1
.   262   0106H  00864H          lsrs     r4,r4,#1
.   264   0108H  0D1F7H          bne.n    -18 -> 250
.   266   010AH  04610H          mov      r0,r2
.   268   010CH  09005H          str      r0,[sp,#20]
        INC(dpos)
      UNTIL int = 0;
.   270   010EH  09801H          ldr      r0,[sp,#4]
.   272   0110H  03001H          adds     r0,#1
.   274   0112H  09001H          str      r0,[sp,#4]
.   276   0114H  09805H          ldr      r0,[sp,#20]
.   278   0116H  02800H          cmp      r0,#0
.   280   0118H  0D1D1H          bne.n    -94 -> 190
      DEC(dpos);
.   282   011AH  09801H          ldr      r0,[sp,#4]
.   284   011CH  03801H          subs     r0,#1
.   286   011EH  09001H          str      r0,[sp,#4]
      WHILE dpos >= 0 DO
.   288   0120H  09801H          ldr      r0,[sp,#4]
.   290   0122H  02800H          cmp      r0,#0
.   292   0124H  0DA01H          bge.n    2 -> 298
.   294   0126H  0E018H          b        48 -> 346
.   296   0128H  046C0H          nop
        str[spos] := digits[dpos];
.   298   012AH  09800H          ldr      r0,[sp]
.   300   012CH  09907H          ldr      r1,[sp,#28]
.   302   012EH  04288H          cmp      r0,r1
.   304   0130H  0D301H          bcc.n    2 -> 310
.   306   0132H  0DF01H          svc      1
.   308  <LineNo: 65>
.   310   0136H  09906H          ldr      r1,[sp,#24]
.   312   0138H  01808H          adds     r0,r1,r0
.   314   013AH  09901H          ldr      r1,[sp,#4]
.   316   013CH  0290AH          cmp      r1,#10
.   318   013EH  0D301H          bcc.n    2 -> 324
.   320   0140H  0DF01H          svc      1
.   322  <LineNo: 65>
.   324   0144H  0466AH          mov      r2,sp
.   326   0146H  01851H          adds     r1,r2,r1
.   328   0148H  07A09H          ldrb     r1,[r1,#8]
.   330   014AH  07001H          strb     r1,[r0]
        DEC(dpos); INC(spos)
.   332   014CH  09801H          ldr      r0,[sp,#4]
.   334   014EH  03801H          subs     r0,#1
.   336   0150H  09001H          str      r0,[sp,#4]
      END;
.   338   0152H  09800H          ldr      r0,[sp]
.   340   0154H  03001H          adds     r0,#1
.   342   0156H  09000H          str      r0,[sp]
.   344   0158H  0E7E2H          b        -60 -> 288
      str[spos] := 0X;
.   346   015AH  09800H          ldr      r0,[sp]
.   348   015CH  09907H          ldr      r1,[sp,#28]
.   350   015EH  04288H          cmp      r0,r1
.   352   0160H  0D301H          bcc.n    2 -> 358
.   354   0162H  0DF01H          svc      1
.   356  <LineNo: 68>
.   358   0166H  09906H          ldr      r1,[sp,#24]
.   360   0168H  01808H          adds     r0,r1,r0
.   362   016AH  02100H          movs     r1,#0
.   364   016CH  07001H          strb     r1,[r0]
      slen := spos
    END
.   366   016EH  09800H          ldr      r0,[sp]
.   368   0170H  09908H          ldr      r1,[sp,#32]
.   370   0172H  06008H          str      r0,[r1]
  END IntToString;
.   372   0174H  0B009H          add      sp,#36
.   374   0176H  0BD00H          pop      { pc }
.   376  <Const: 080000000H  -2147483648>
.   380  <Const: 0FF000000H  -16777216>


  PROCEDURE IntToHexString*(int: INTEGER; VAR str: ARRAY OF CHAR; VAR slen: INTEGER);
    VAR dpos, spos, d: INTEGER; digits: ARRAY 10 OF CHAR;
  BEGIN
.   384   0180H  0B50FH          push     { r0, r1, r2, r3, lr }
.   386   0182H  0B086H          sub      sp,#24
    ASSERT(LEN(str) >= 10, Errors.PreCond);
.   388   0184H  09808H          ldr      r0,[sp,#32]
.   390   0186H  0280AH          cmp      r0,#10
.   392   0188H  0DA01H          bge.n    2 -> 398
.   394   018AH  0DF65H          svc      101
.   396  <LineNo: 77>
    dpos := 0;
.   398   018EH  02000H          movs     r0,#0
.   400   0190H  09000H          str      r0,[sp]
    REPEAT
      d := int MOD 010H;
.   402   0192H  09806H          ldr      r0,[sp,#24]
.   404   0194H  00700H          lsls     r0,r0,#28
.   406   0196H  00F00H          lsrs     r0,r0,#28
.   408   0198H  09002H          str      r0,[sp,#8]
      IF d < 10 THEN
.   410   019AH  09802H          ldr      r0,[sp,#8]
.   412   019CH  0280AH          cmp      r0,#10
.   414   019EH  0DB01H          blt.n    2 -> 420
.   416   01A0H  0E00CH          b        24 -> 444
.   418   01A2H  046C0H          nop
        digits[dpos] := CHR(d + ORD("0"))
.   420   01A4H  09800H          ldr      r0,[sp]
.   422   01A6H  0280AH          cmp      r0,#10
.   424   01A8H  0D301H          bcc.n    2 -> 430
.   426   01AAH  0DF01H          svc      1
.   428  <LineNo: 82>
.   430   01AEH  04669H          mov      r1,sp
.   432   01B0H  01808H          adds     r0,r1,r0
.   434   01B2H  09902H          ldr      r1,[sp,#8]
.   436   01B4H  03130H          adds     r1,#48
      ELSE
.   438   01B6H  07301H          strb     r1,[r0,#12]
        digits[dpos] := CHR(d - 10 + ORD("A"))
.   440   01B8H  0E00BH          b        22 -> 466
.   442   01BAH  046C0H          nop
.   444   01BCH  09800H          ldr      r0,[sp]
.   446   01BEH  0280AH          cmp      r0,#10
.   448   01C0H  0D301H          bcc.n    2 -> 454
.   450   01C2H  0DF01H          svc      1
.   452  <LineNo: 84>
.   454   01C6H  04669H          mov      r1,sp
.   456   01C8H  01808H          adds     r0,r1,r0
.   458   01CAH  09902H          ldr      r1,[sp,#8]
.   460   01CCH  0390AH          subs     r1,#10
.   462   01CEH  03141H          adds     r1,#65
      END;
.   464   01D0H  07301H          strb     r1,[r0,#12]
      int := int DIV 010H;
.   466   01D2H  09806H          ldr      r0,[sp,#24]
.   468   01D4H  01100H          asrs     r0,r0,#4
.   470   01D6H  09006H          str      r0,[sp,#24]
      INC(dpos)
    UNTIL dpos = 8;
.   472   01D8H  09800H          ldr      r0,[sp]
.   474   01DAH  03001H          adds     r0,#1
.   476   01DCH  09000H          str      r0,[sp]
.   478   01DEH  09800H          ldr      r0,[sp]
.   480   01E0H  02808H          cmp      r0,#8
.   482   01E2H  0D1D6H          bne.n    -84 -> 402
    DEC(dpos); spos := 0;
.   484   01E4H  09800H          ldr      r0,[sp]
.   486   01E6H  03801H          subs     r0,#1
.   488   01E8H  09000H          str      r0,[sp]
.   490   01EAH  02000H          movs     r0,#0
.   492   01ECH  09001H          str      r0,[sp,#4]
    WHILE dpos >= 0 DO
.   494   01EEH  09800H          ldr      r0,[sp]
.   496   01F0H  02800H          cmp      r0,#0
.   498   01F2H  0DA01H          bge.n    2 -> 504
.   500   01F4H  0E018H          b        48 -> 552
.   502   01F6H  046C0H          nop
      str[spos] := digits[dpos];
.   504   01F8H  09801H          ldr      r0,[sp,#4]
.   506   01FAH  09908H          ldr      r1,[sp,#32]
.   508   01FCH  04288H          cmp      r0,r1
.   510   01FEH  0D301H          bcc.n    2 -> 516
.   512   0200H  0DF01H          svc      1
.   514  <LineNo: 91>
.   516   0204H  09907H          ldr      r1,[sp,#28]
.   518   0206H  01808H          adds     r0,r1,r0
.   520   0208H  09900H          ldr      r1,[sp]
.   522   020AH  0290AH          cmp      r1,#10
.   524   020CH  0D301H          bcc.n    2 -> 530
.   526   020EH  0DF01H          svc      1
.   528  <LineNo: 91>
.   530   0212H  0466AH          mov      r2,sp
.   532   0214H  01851H          adds     r1,r2,r1
.   534   0216H  07B09H          ldrb     r1,[r1,#12]
.   536   0218H  07001H          strb     r1,[r0]
      DEC(dpos); INC(spos)
.   538   021AH  09800H          ldr      r0,[sp]
.   540   021CH  03801H          subs     r0,#1
.   542   021EH  09000H          str      r0,[sp]
    END;
.   544   0220H  09801H          ldr      r0,[sp,#4]
.   546   0222H  03001H          adds     r0,#1
.   548   0224H  09001H          str      r0,[sp,#4]
.   550   0226H  0E7E2H          b        -60 -> 494
    str[8] := "H";
.   552   0228H  02008H          movs     r0,#8
.   554   022AH  09908H          ldr      r1,[sp,#32]
.   556   022CH  04288H          cmp      r0,r1
.   558   022EH  0D301H          bcc.n    2 -> 564
.   560   0230H  0DF01H          svc      1
.   562  <LineNo: 94>
.   564   0234H  09907H          ldr      r1,[sp,#28]
.   566   0236H  01808H          adds     r0,r1,r0
.   568   0238H  02148H          movs     r1,#72
.   570   023AH  07001H          strb     r1,[r0]
    str[9] := 0X;
.   572   023CH  02009H          movs     r0,#9
.   574   023EH  09908H          ldr      r1,[sp,#32]
.   576   0240H  04288H          cmp      r0,r1
.   578   0242H  0D301H          bcc.n    2 -> 584
.   580   0244H  0DF01H          svc      1
.   582  <LineNo: 95>
.   584   0248H  09907H          ldr      r1,[sp,#28]
.   586   024AH  01808H          adds     r0,r1,r0
.   588   024CH  02100H          movs     r1,#0
.   590   024EH  07001H          strb     r1,[r0]
    slen := 9
  END IntToHexString;
.   592   0250H  02009H          movs     r0,#9
.   594   0252H  09909H          ldr      r1,[sp,#36]
.   596   0254H  06008H          str      r0,[r1]
.   598   0256H  0B00AH          add      sp,#40
.   600   0258H  0BD00H          pop      { pc }
.   602   025AH  046C0H          nop


  PROCEDURE IntToBinString*(int: INTEGER; VAR str: ARRAY OF CHAR; VAR slen: INTEGER);
    VAR
      i, j, k: INTEGER;
      bits: SET;
  BEGIN
.   604   025CH  0B50FH          push     { r0, r1, r2, r3, lr }
.   606   025EH  0B084H          sub      sp,#16
    ASSERT(LEN(str) >= 36, Errors.PreCond);
.   608   0260H  09806H          ldr      r0,[sp,#24]
.   610   0262H  02824H          cmp      r0,#36
.   612   0264H  0DA01H          bge.n    2 -> 618
.   614   0266H  0DF65H          svc      101
.   616  <LineNo: 105>
    k := 0;
.   618   026AH  02000H          movs     r0,#0
.   620   026CH  09002H          str      r0,[sp,#8]
    FOR i := 0 TO 3 DO
.   622   026EH  02000H          movs     r0,#0
.   624   0270H  09000H          str      r0,[sp]
      bits := BITS(BFX(int, 31, 24));
.   626   0272H  09800H          ldr      r0,[sp]
.   628   0274H  02803H          cmp      r0,#3
.   630   0276H  0DD01H          ble.n    2 -> 636
.   632   0278H  0E043H          b        134 -> 770
.   634   027AH  046C0H          nop
.   636   027CH  09804H          ldr      r0,[sp,#16]
.   638   027EH  00E00H          lsrs     r0,r0,#24
.   640   0280H  09003H          str      r0,[sp,#12]
      int := LSL(int, 8);
.   642   0282H  09804H          ldr      r0,[sp,#16]
.   644   0284H  00200H          lsls     r0,r0,#8
.   646   0286H  09004H          str      r0,[sp,#16]
      FOR j := 7 TO 0 BY -1 DO
.   648   0288H  02007H          movs     r0,#7
.   650   028AH  09001H          str      r0,[sp,#4]
        IF j IN bits THEN str[k] := "1" ELSE str[k] := "0" END;
.   652   028CH  09801H          ldr      r0,[sp,#4]
.   654   028EH  02800H          cmp      r0,#0
.   656   0290H  0DA01H          bge.n    2 -> 662
.   658   0292H  0E025H          b        74 -> 736
.   660   0294H  046C0H          nop
.   662   0296H  09803H          ldr      r0,[sp,#12]
.   664   0298H  09901H          ldr      r1,[sp,#4]
.   666   029AH  02201H          movs     r2,#1
.   668   029CH  0408AH          lsls     r2,r1
.   670   029EH  04210H          tst      r0,r2
.   672   02A0H  0D101H          bne.n    2 -> 678
.   674   02A2H  0E00CH          b        24 -> 702
.   676   02A4H  046C0H          nop
.   678   02A6H  09802H          ldr      r0,[sp,#8]
.   680   02A8H  09906H          ldr      r1,[sp,#24]
.   682   02AAH  04288H          cmp      r0,r1
.   684   02ACH  0D301H          bcc.n    2 -> 690
.   686   02AEH  0DF01H          svc      1
.   688  <LineNo: 111>
.   690   02B2H  09905H          ldr      r1,[sp,#20]
.   692   02B4H  01808H          adds     r0,r1,r0
.   694   02B6H  02131H          movs     r1,#49
.   696   02B8H  07001H          strb     r1,[r0]
.   698   02BAH  0E00AH          b        20 -> 722
.   700   02BCH  046C0H          nop
.   702   02BEH  09802H          ldr      r0,[sp,#8]
.   704   02C0H  09906H          ldr      r1,[sp,#24]
.   706   02C2H  04288H          cmp      r0,r1
.   708   02C4H  0D301H          bcc.n    2 -> 714
.   710   02C6H  0DF01H          svc      1
.   712  <LineNo: 111>
.   714   02CAH  09905H          ldr      r1,[sp,#20]
.   716   02CCH  01808H          adds     r0,r1,r0
.   718   02CEH  02130H          movs     r1,#48
.   720   02D0H  07001H          strb     r1,[r0]
        INC(k)
      END;
.   722   02D2H  09802H          ldr      r0,[sp,#8]
.   724   02D4H  03001H          adds     r0,#1
.   726   02D6H  09002H          str      r0,[sp,#8]
.   728   02D8H  09801H          ldr      r0,[sp,#4]
.   730   02DAH  03801H          subs     r0,#1
.   732   02DCH  09001H          str      r0,[sp,#4]
.   734   02DEH  0E7D5H          b        -86 -> 652
      str[k] := " ";
.   736   02E0H  09802H          ldr      r0,[sp,#8]
.   738   02E2H  09906H          ldr      r1,[sp,#24]
.   740   02E4H  04288H          cmp      r0,r1
.   742   02E6H  0D301H          bcc.n    2 -> 748
.   744   02E8H  0DF01H          svc      1
.   746  <LineNo: 114>
.   748   02ECH  09905H          ldr      r1,[sp,#20]
.   750   02EEH  01808H          adds     r0,r1,r0
.   752   02F0H  02120H          movs     r1,#32
.   754   02F2H  07001H          strb     r1,[r0]
      INC(k)
    END;
.   756   02F4H  09802H          ldr      r0,[sp,#8]
.   758   02F6H  03001H          adds     r0,#1
.   760   02F8H  09002H          str      r0,[sp,#8]
.   762   02FAH  09800H          ldr      r0,[sp]
.   764   02FCH  03001H          adds     r0,#1
.   766   02FEH  09000H          str      r0,[sp]
.   768   0300H  0E7B7H          b        -146 -> 626
    str[35] := 0X;
.   770   0302H  02023H          movs     r0,#35
.   772   0304H  09906H          ldr      r1,[sp,#24]
.   774   0306H  04288H          cmp      r0,r1
.   776   0308H  0D301H          bcc.n    2 -> 782
.   778   030AH  0DF01H          svc      1
.   780  <LineNo: 117>
.   782   030EH  09905H          ldr      r1,[sp,#20]
.   784   0310H  01808H          adds     r0,r1,r0
.   786   0312H  02100H          movs     r1,#0
.   788   0314H  07001H          strb     r1,[r0]
    slen := 35
  END IntToBinString;
.   790   0316H  02023H          movs     r0,#35
.   792   0318H  09907H          ldr      r1,[sp,#28]
.   794   031AH  06008H          str      r0,[r1]
.   796   031CH  0B008H          add      sp,#32
.   798   031EH  0BD00H          pop      { pc }

  (* write *)

  PROCEDURE Write*(W: TextIO.Writer; ch: CHAR);
    VAR s: ARRAY 1 OF CHAR;
  BEGIN
.   800   0320H  0B503H          push     { r0, r1, lr }
.   802   0322H  0B081H          sub      sp,#4
    s[0] := ch;
.   804   0324H  0A802H          add      r0,sp,#8
.   806   0326H  07800H          ldrb     r0,[r0]
.   808   0328H  0A900H          add      r1,sp,#0
.   810   032AH  07008H          strb     r0,[r1]
    W.putString(W.dev, s, 1)
.   812   032CH  09801H          ldr      r0,[sp,#4]
.   814   032EH  06800H          ldr      r0,[r0]
.   816   0330H  04669H          mov      r1,sp
.   818   0332H  02201H          movs     r2,#1
.   820   0334H  02301H          movs     r3,#1
  END Write;
.   822   0336H  09C01H          ldr      r4,[sp,#4]
.   824   0338H  06864H          ldr      r4,[r4,#4]
.   826   033AH  02C00H          cmp      r4,#0
.   828   033CH  0D101H          bne.n    2 -> 834
.   830   033EH  0DF05H          svc      5
.   832  <LineNo: 127>
.   834   0342H  03401H          adds     r4,#1
.   836   0344H  047A0H          blx      r4
.   838   0346H  0E000H          b        0 -> 842
.   840  <LineNo: 127>
.   842   034AH  0B003H          add      sp,#12
.   844   034CH  0BD00H          pop      { pc }
.   846   034EH  046C0H          nop


  PROCEDURE WriteString*(W: TextIO.Writer; str: ARRAY OF CHAR);
    VAR i: INTEGER;
  BEGIN
.   848   0350H  0B507H          push     { r0, r1, r2, lr }
.   850   0352H  0B081H          sub      sp,#4
    i := 0;
.   852   0354H  02000H          movs     r0,#0
.   854   0356H  09000H          str      r0,[sp]
    WHILE (i < LEN(str)) & (str[i] # 0X) DO INC(i) END;
.   856   0358H  09800H          ldr      r0,[sp]
.   858   035AH  09903H          ldr      r1,[sp,#12]
.   860   035CH  04288H          cmp      r0,r1
.   862   035EH  0DB01H          blt.n    2 -> 868
.   864   0360H  0E011H          b        34 -> 902
.   866   0362H  046C0H          nop
.   868   0364H  09800H          ldr      r0,[sp]
.   870   0366H  09903H          ldr      r1,[sp,#12]
.   872   0368H  04288H          cmp      r0,r1
.   874   036AH  0D301H          bcc.n    2 -> 880
.   876   036CH  0DF01H          svc      1
.   878  <LineNo: 135>
.   880   0370H  09902H          ldr      r1,[sp,#8]
.   882   0372H  01808H          adds     r0,r1,r0
.   884   0374H  07800H          ldrb     r0,[r0]
.   886   0376H  02800H          cmp      r0,#0
.   888   0378H  0D101H          bne.n    2 -> 894
.   890   037AH  0E004H          b        8 -> 902
.   892   037CH  046C0H          nop
.   894   037EH  09800H          ldr      r0,[sp]
.   896   0380H  03001H          adds     r0,#1
.   898   0382H  09000H          str      r0,[sp]
.   900   0384H  0E7E8H          b        -48 -> 856
    W.putString(W.dev, str, i)
.   902   0386H  09801H          ldr      r0,[sp,#4]
.   904   0388H  06800H          ldr      r0,[r0]
.   906   038AH  09902H          ldr      r1,[sp,#8]
.   908   038CH  09A03H          ldr      r2,[sp,#12]
.   910   038EH  09B00H          ldr      r3,[sp]
  END WriteString;
.   912   0390H  09C01H          ldr      r4,[sp,#4]
.   914   0392H  06864H          ldr      r4,[r4,#4]
.   916   0394H  02C00H          cmp      r4,#0
.   918   0396H  0D101H          bne.n    2 -> 924
.   920   0398H  0DF05H          svc      5
.   922  <LineNo: 136>
.   924   039CH  03401H          adds     r4,#1
.   926   039EH  047A0H          blx      r4
.   928   03A0H  0E000H          b        0 -> 932
.   930  <LineNo: 136>
.   932   03A4H  0B004H          add      sp,#16
.   934   03A6H  0BD00H          pop      { pc }


  PROCEDURE WriteLn*(W: TextIO.Writer);
  BEGIN
.   936   03A8H  0B501H          push     { r0, lr }
    W.putString(W.dev, eol, 2)
.   938   03AAH  09800H          ldr      r0,[sp]
.   940   03ACH  06800H          ldr      r0,[r0]
.   942   03AEH  04907H          ldr      r1,[pc,#28] -> 972
.   944   03B0H  02202H          movs     r2,#2
.   946   03B2H  02302H          movs     r3,#2
  END WriteLn;
.   948   03B4H  09C00H          ldr      r4,[sp]
.   950   03B6H  06864H          ldr      r4,[r4,#4]
.   952   03B8H  02C00H          cmp      r4,#0
.   954   03BAH  0D101H          bne.n    2 -> 960
.   956   03BCH  0DF05H          svc      5
.   958  <LineNo: 142>
.   960   03C0H  03401H          adds     r4,#1
.   962   03C2H  047A0H          blx      r4
.   964   03C4H  0E000H          b        0 -> 968
.   966  <LineNo: 142>
.   968   03C8H  0B001H          add      sp,#4
.   970   03CAH  0BD00H          pop      { pc }
.   972  <Global: 000040000H  040000H>


  PROCEDURE writeNumString(W: TextIO.Writer; str: ARRAY OF CHAR; numChars, leftPadding: INTEGER);
  BEGIN
.   976   03D0H  0B51FH          push     { r0, r1, r2, r3, r4, lr }
    IF leftPadding > MaxBlanks THEN leftPadding := MaxBlanks END;
.   978   03D2H  09804H          ldr      r0,[sp,#16]
.   980   03D4H  02820H          cmp      r0,#32
.   982   03D6H  0DC01H          bgt.n    2 -> 988
.   984   03D8H  0E002H          b        4 -> 992
.   986   03DAH  046C0H          nop
.   988   03DCH  02020H          movs     r0,#32
.   990   03DEH  09004H          str      r0,[sp,#16]
    IF leftPadding > 0 THEN
.   992   03E0H  09804H          ldr      r0,[sp,#16]
.   994   03E2H  02800H          cmp      r0,#0
.   996   03E4H  0DC01H          bgt.n    2 -> 1002
.   998   03E6H  0E012H          b        36 -> 1038
.  1000   03E8H  046C0H          nop
      W.putString(W.dev, Blanks, leftPadding)
.  1002   03EAH  09800H          ldr      r0,[sp]
.  1004   03ECH  06800H          ldr      r0,[r0]
.  1006   03EEH  046C0H          nop
.  1008   03F0H  0490FH          ldr      r1,[pc,#60] -> 1072
.  1010   03F2H  0467AH          mov      r2,pc
.  1012   03F4H  01889H          adds     r1,r1,r2
.  1014   03F6H  02221H          movs     r2,#33
.  1016   03F8H  09B04H          ldr      r3,[sp,#16]
    END;
.  1018   03FAH  09C00H          ldr      r4,[sp]
.  1020   03FCH  06864H          ldr      r4,[r4,#4]
.  1022   03FEH  02C00H          cmp      r4,#0
.  1024   0400H  0D101H          bne.n    2 -> 1030
.  1026   0402H  0DF05H          svc      5
.  1028  <LineNo: 150>
.  1030   0406H  03401H          adds     r4,#1
.  1032   0408H  047A0H          blx      r4
.  1034   040AH  0E000H          b        0 -> 1038
.  1036  <LineNo: 150>
    W.putString(W.dev, str, numChars)
.  1038   040EH  09800H          ldr      r0,[sp]
.  1040   0410H  06800H          ldr      r0,[r0]
.  1042   0412H  09901H          ldr      r1,[sp,#4]
.  1044   0414H  09A02H          ldr      r2,[sp,#8]
.  1046   0416H  09B03H          ldr      r3,[sp,#12]
  END writeNumString;
.  1048   0418H  09C00H          ldr      r4,[sp]
.  1050   041AH  06864H          ldr      r4,[r4,#4]
.  1052   041CH  02C00H          cmp      r4,#0
.  1054   041EH  0D101H          bne.n    2 -> 1060
.  1056   0420H  0DF05H          svc      5
.  1058  <LineNo: 152>
.  1060   0424H  03401H          adds     r4,#1
.  1062   0426H  047A0H          blx      r4
.  1064   0428H  0E000H          b        0 -> 1068
.  1066  <LineNo: 152>
.  1068   042CH  0B005H          add      sp,#20
.  1070   042EH  0BD00H          pop      { pc }
.  1072  <Const: 0FFFFFC0EH  -1010>


  PROCEDURE WriteInt*(W: TextIO.Writer; int, width: INTEGER);
  (**
    Write an integer value in decimal form via 'W'.
  **)
    VAR buffer: ARRAY 12 OF CHAR; strLen: INTEGER;
  BEGIN
.  1076   0434H  0B507H          push     { r0, r1, r2, lr }
.  1078   0436H  0B084H          sub      sp,#16
    IntToString(int, buffer, strLen);
.  1080   0438H  09805H          ldr      r0,[sp,#20]
.  1082   043AH  04669H          mov      r1,sp
.  1084   043CH  0220CH          movs     r2,#12
.  1086   043EH  0AB03H          add      r3,sp,#12
.  1088   0440H  0F7FFFDF2H      bl.w     -1052 -> 40
.  1092   0444H  0E000H          b        0 -> 1096
.  1094  <LineNo: 162>
    writeNumString(W, buffer, strLen, width - strLen)
.  1096   0448H  09804H          ldr      r0,[sp,#16]
.  1098   044AH  04669H          mov      r1,sp
.  1100   044CH  0220CH          movs     r2,#12
.  1102   044EH  09B03H          ldr      r3,[sp,#12]
.  1104   0450H  09C06H          ldr      r4,[sp,#24]
.  1106   0452H  09D03H          ldr      r5,[sp,#12]
.  1108   0454H  01B64H          subs     r4,r4,r5
  END WriteInt;
.  1110   0456H  0F7FFFFBBH      bl.w     -138 -> 976
.  1114   045AH  0E000H          b        0 -> 1118
.  1116  <LineNo: 163>
.  1118   045EH  0B007H          add      sp,#28
.  1120   0460H  0BD00H          pop      { pc }
.  1122   0462H  046C0H          nop


  PROCEDURE WriteHex*(W: TextIO.Writer; int, width: INTEGER);
    VAR buffer: ARRAY 12 OF CHAR; strLen: INTEGER;
  BEGIN
.  1124   0464H  0B507H          push     { r0, r1, r2, lr }
.  1126   0466H  0B084H          sub      sp,#16
    IntToHexString(int, buffer, strLen);
.  1128   0468H  09805H          ldr      r0,[sp,#20]
.  1130   046AH  04669H          mov      r1,sp
.  1132   046CH  0220CH          movs     r2,#12
.  1134   046EH  0AB03H          add      r3,sp,#12
.  1136   0470H  0F7FFFE86H      bl.w     -756 -> 384
.  1140   0474H  0E000H          b        0 -> 1144
.  1142  <LineNo: 170>
    writeNumString(W, buffer, strLen, width - strLen)
.  1144   0478H  09804H          ldr      r0,[sp,#16]
.  1146   047AH  04669H          mov      r1,sp
.  1148   047CH  0220CH          movs     r2,#12
.  1150   047EH  09B03H          ldr      r3,[sp,#12]
.  1152   0480H  09C06H          ldr      r4,[sp,#24]
.  1154   0482H  09D03H          ldr      r5,[sp,#12]
.  1156   0484H  01B64H          subs     r4,r4,r5
  END WriteHex;
.  1158   0486H  0F7FFFFA3H      bl.w     -186 -> 976
.  1162   048AH  0E000H          b        0 -> 1166
.  1164  <LineNo: 171>
.  1166   048EH  0B007H          add      sp,#28
.  1168   0490H  0BD00H          pop      { pc }
.  1170   0492H  046C0H          nop


  PROCEDURE WriteBin*(W: TextIO.Writer; int, width: INTEGER);
    VAR buffer: ARRAY 36 OF CHAR; strLen: INTEGER;
  BEGIN
.  1172   0494H  0B507H          push     { r0, r1, r2, lr }
.  1174   0496H  0B08AH          sub      sp,#40
    IntToBinString(int, buffer, strLen);
.  1176   0498H  0980BH          ldr      r0,[sp,#44]
.  1178   049AH  04669H          mov      r1,sp
.  1180   049CH  02224H          movs     r2,#36
.  1182   049EH  0AB09H          add      r3,sp,#36
.  1184   04A0H  0F7FFFEDCH      bl.w     -584 -> 604
.  1188   04A4H  0E000H          b        0 -> 1192
.  1190  <LineNo: 178>
    writeNumString(W, buffer, strLen, width - strLen)
.  1192   04A8H  0980AH          ldr      r0,[sp,#40]
.  1194   04AAH  04669H          mov      r1,sp
.  1196   04ACH  02224H          movs     r2,#36
.  1198   04AEH  09B09H          ldr      r3,[sp,#36]
.  1200   04B0H  09C0CH          ldr      r4,[sp,#48]
.  1202   04B2H  09D09H          ldr      r5,[sp,#36]
.  1204   04B4H  01B64H          subs     r4,r4,r5
  END WriteBin;
.  1206   04B6H  0F7FFFF8BH      bl.w     -234 -> 976
.  1210   04BAH  0E000H          b        0 -> 1214
.  1212  <LineNo: 179>
.  1214   04BEH  0B00DH          add      sp,#52
.  1216   04C0H  0BD00H          pop      { pc }
.  1218   04C2H  046C0H          nop

  (* read conversions *)

  PROCEDURE cleanLeft(str: ARRAY OF CHAR; VAR first: INTEGER; VAR neg: BOOLEAN);
    VAR ch: CHAR;
  BEGIN
.  1220   04C4H  0B50FH          push     { r0, r1, r2, r3, lr }
.  1222   04C6H  0B081H          sub      sp,#4
    first := 0;
.  1224   04C8H  02000H          movs     r0,#0
.  1226   04CAH  09903H          ldr      r1,[sp,#12]
.  1228   04CCH  06008H          str      r0,[r1]
    WHILE str[first] = " " DO INC(first) END;
.  1230   04CEH  09803H          ldr      r0,[sp,#12]
.  1232   04D0H  06800H          ldr      r0,[r0]
.  1234   04D2H  09902H          ldr      r1,[sp,#8]
.  1236   04D4H  04288H          cmp      r0,r1
.  1238   04D6H  0D301H          bcc.n    2 -> 1244
.  1240   04D8H  0DF01H          svc      1
.  1242  <LineNo: 188>
.  1244   04DCH  09901H          ldr      r1,[sp,#4]
.  1246   04DEH  01808H          adds     r0,r1,r0
.  1248   04E0H  07800H          ldrb     r0,[r0]
.  1250   04E2H  02820H          cmp      r0,#32
.  1252   04E4H  0D001H          beq.n    2 -> 1258
.  1254   04E6H  0E005H          b        10 -> 1268
.  1256   04E8H  046C0H          nop
.  1258   04EAH  09803H          ldr      r0,[sp,#12]
.  1260   04ECH  06801H          ldr      r1,[r0]
.  1262   04EEH  03101H          adds     r1,#1
.  1264   04F0H  06001H          str      r1,[r0]
.  1266   04F2H  0E7ECH          b        -40 -> 1230
    ch := str[first];
.  1268   04F4H  09803H          ldr      r0,[sp,#12]
.  1270   04F6H  06800H          ldr      r0,[r0]
.  1272   04F8H  09902H          ldr      r1,[sp,#8]
.  1274   04FAH  04288H          cmp      r0,r1
.  1276   04FCH  0D301H          bcc.n    2 -> 1282
.  1278   04FEH  0DF01H          svc      1
.  1280  <LineNo: 189>
.  1282   0502H  09901H          ldr      r1,[sp,#4]
.  1284   0504H  01808H          adds     r0,r1,r0
.  1286   0506H  07800H          ldrb     r0,[r0]
.  1288   0508H  0A900H          add      r1,sp,#0
.  1290   050AH  07008H          strb     r0,[r1]
    neg := ch = "-";
.  1292   050CH  0A800H          add      r0,sp,#0
.  1294   050EH  07800H          ldrb     r0,[r0]
.  1296   0510H  0282DH          cmp      r0,#45
.  1298   0512H  0D001H          beq.n    2 -> 1304
.  1300   0514H  02000H          movs     r0,#0
.  1302   0516H  0E000H          b        0 -> 1306
.  1304   0518H  02001H          movs     r0,#1
.  1306   051AH  09904H          ldr      r1,[sp,#16]
.  1308   051CH  07008H          strb     r0,[r1]
    IF (ch = "-") OR (ch = "+") THEN INC(first) END;
.  1310   051EH  0A800H          add      r0,sp,#0
.  1312   0520H  07800H          ldrb     r0,[r0]
.  1314   0522H  0282DH          cmp      r0,#45
.  1316   0524H  0D101H          bne.n    2 -> 1322
.  1318   0526H  0E006H          b        12 -> 1334
.  1320   0528H  046C0H          nop
.  1322   052AH  0A800H          add      r0,sp,#0
.  1324   052CH  07800H          ldrb     r0,[r0]
.  1326   052EH  0282BH          cmp      r0,#43
.  1328   0530H  0D001H          beq.n    2 -> 1334
.  1330   0532H  0E004H          b        8 -> 1342
.  1332   0534H  046C0H          nop
.  1334   0536H  09803H          ldr      r0,[sp,#12]
.  1336   0538H  06801H          ldr      r1,[r0]
.  1338   053AH  03101H          adds     r1,#1
.  1340   053CH  06001H          str      r1,[r0]
    WHILE str[first] = " " DO INC(first) END;
.  1342   053EH  09803H          ldr      r0,[sp,#12]
.  1344   0540H  06800H          ldr      r0,[r0]
.  1346   0542H  09902H          ldr      r1,[sp,#8]
.  1348   0544H  04288H          cmp      r0,r1
.  1350   0546H  0D301H          bcc.n    2 -> 1356
.  1352   0548H  0DF01H          svc      1
.  1354  <LineNo: 192>
.  1356   054CH  09901H          ldr      r1,[sp,#4]
.  1358   054EH  01808H          adds     r0,r1,r0
.  1360   0550H  07800H          ldrb     r0,[r0]
.  1362   0552H  02820H          cmp      r0,#32
.  1364   0554H  0D001H          beq.n    2 -> 1370
.  1366   0556H  0E005H          b        10 -> 1380
.  1368   0558H  046C0H          nop
.  1370   055AH  09803H          ldr      r0,[sp,#12]
.  1372   055CH  06801H          ldr      r1,[r0]
.  1374   055EH  03101H          adds     r1,#1
.  1376   0560H  06001H          str      r1,[r0]
.  1378   0562H  0E7ECH          b        -40 -> 1342
    WHILE str[first] = "0" DO INC(first) END;
.  1380   0564H  09803H          ldr      r0,[sp,#12]
.  1382   0566H  06800H          ldr      r0,[r0]
.  1384   0568H  09902H          ldr      r1,[sp,#8]
.  1386   056AH  04288H          cmp      r0,r1
.  1388   056CH  0D301H          bcc.n    2 -> 1394
.  1390   056EH  0DF01H          svc      1
.  1392  <LineNo: 193>
.  1394   0572H  09901H          ldr      r1,[sp,#4]
.  1396   0574H  01808H          adds     r0,r1,r0
.  1398   0576H  07800H          ldrb     r0,[r0]
.  1400   0578H  02830H          cmp      r0,#48
.  1402   057AH  0D001H          beq.n    2 -> 1408
.  1404   057CH  0E005H          b        10 -> 1418
.  1406   057EH  046C0H          nop
.  1408   0580H  09803H          ldr      r0,[sp,#12]
.  1410   0582H  06801H          ldr      r1,[r0]
.  1412   0584H  03101H          adds     r1,#1
.  1414   0586H  06001H          str      r1,[r0]
.  1416   0588H  0E7ECH          b        -40 -> 1380
  END cleanLeft;
.  1418   058AH  0B005H          add      sp,#20
.  1420   058CH  0BD00H          pop      { pc }
.  1422   058EH  046C0H          nop

  PROCEDURE cleanRight(str: ARRAY OF CHAR; numCh: INTEGER; VAR last: INTEGER);
  BEGIN
.  1424   0590H  0B50FH          push     { r0, r1, r2, r3, lr }
    last := numCh - 1;
.  1426   0592H  09802H          ldr      r0,[sp,#8]
.  1428   0594H  03801H          subs     r0,#1
.  1430   0596H  09903H          ldr      r1,[sp,#12]
.  1432   0598H  06008H          str      r0,[r1]
    WHILE str[last] = " " DO
.  1434   059AH  09803H          ldr      r0,[sp,#12]
.  1436   059CH  06800H          ldr      r0,[r0]
.  1438   059EH  09901H          ldr      r1,[sp,#4]
.  1440   05A0H  04288H          cmp      r0,r1
.  1442   05A2H  0D301H          bcc.n    2 -> 1448
.  1444   05A4H  0DF01H          svc      1
.  1446  <LineNo: 199>
.  1448   05A8H  09900H          ldr      r1,[sp]
.  1450   05AAH  01808H          adds     r0,r1,r0
.  1452   05ACH  07800H          ldrb     r0,[r0]
.  1454   05AEH  02820H          cmp      r0,#32
.  1456   05B0H  0D001H          beq.n    2 -> 1462
.  1458   05B2H  0E005H          b        10 -> 1472
.  1460   05B4H  046C0H          nop
      DEC(last)
    END
.  1462   05B6H  09803H          ldr      r0,[sp,#12]
.  1464   05B8H  06801H          ldr      r1,[r0]
.  1466   05BAH  03901H          subs     r1,#1
.  1468   05BCH  06001H          str      r1,[r0]
.  1470   05BEH  0E7ECH          b        -40 -> 1434
  END cleanRight;
.  1472   05C0H  0B004H          add      sp,#16
.  1474   05C2H  0BD00H          pop      { pc }


  PROCEDURE StrToInt*(str: ARRAY OF CHAR; numCh: INTEGER; VAR int: INTEGER; VAR res: INTEGER);
  (* rolls over at 0100000000H = 2^32 *)
    VAR first, last, digit: INTEGER; neg: BOOLEAN; ch: CHAR;
  BEGIN
.  1476   05C4H  0B51FH          push     { r0, r1, r2, r3, r4, lr }
.  1478   05C6H  0B084H          sub      sp,#16
    res := NoError;
.  1480   05C8H  02000H          movs     r0,#0
.  1482   05CAH  09908H          ldr      r1,[sp,#32]
.  1484   05CCH  06008H          str      r0,[r1]
    cleanLeft(str, first, neg);
.  1486   05CEH  09804H          ldr      r0,[sp,#16]
.  1488   05D0H  09905H          ldr      r1,[sp,#20]
.  1490   05D2H  0466AH          mov      r2,sp
.  1492   05D4H  0AB03H          add      r3,sp,#12
.  1494   05D6H  0F7FFFF75H      bl.w     -278 -> 1220
.  1498   05DAH  0E000H          b        0 -> 1502
.  1500  <LineNo: 210>
    IF numCh - first > MaxIntDigits THEN
.  1502   05DEH  09806H          ldr      r0,[sp,#24]
.  1504   05E0H  09900H          ldr      r1,[sp]
.  1506   05E2H  01A40H          subs     r0,r0,r1
.  1508   05E4H  0280AH          cmp      r0,#10
.  1510   05E6H  0DC01H          bgt.n    2 -> 1516
.  1512   05E8H  0E003H          b        6 -> 1522
.  1514   05EAH  046C0H          nop
      res := OutOfLimits;
.  1516   05ECH  02003H          movs     r0,#3
.  1518   05EEH  09908H          ldr      r1,[sp,#32]
.  1520   05F0H  06008H          str      r0,[r1]
    END;
    IF res = NoError THEN
.  1522   05F2H  09808H          ldr      r0,[sp,#32]
.  1524   05F4H  06800H          ldr      r0,[r0]
.  1526   05F6H  02800H          cmp      r0,#0
.  1528   05F8H  0D001H          beq.n    2 -> 1534
.  1530   05FAH  0E061H          b        194 -> 1728
.  1532   05FCH  046C0H          nop
      cleanRight(str, numCh, last);
.  1534   05FEH  09804H          ldr      r0,[sp,#16]
.  1536   0600H  09905H          ldr      r1,[sp,#20]
.  1538   0602H  09A06H          ldr      r2,[sp,#24]
.  1540   0604H  0AB01H          add      r3,sp,#4
.  1542   0606H  0F7FFFFC3H      bl.w     -122 -> 1424
.  1546   060AH  0E000H          b        0 -> 1550
.  1548  <LineNo: 215>
      int := 0;
.  1550   060EH  02000H          movs     r0,#0
.  1552   0610H  09907H          ldr      r1,[sp,#28]
.  1554   0612H  06008H          str      r0,[r1]
      WHILE (first <= last) & (res = NoError) DO
.  1556   0614H  09800H          ldr      r0,[sp]
.  1558   0616H  09901H          ldr      r1,[sp,#4]
.  1560   0618H  04288H          cmp      r0,r1
.  1562   061AH  0DD01H          ble.n    2 -> 1568
.  1564   061CH  0E050H          b        160 -> 1728
.  1566   061EH  046C0H          nop
.  1568   0620H  09808H          ldr      r0,[sp,#32]
.  1570   0622H  06800H          ldr      r0,[r0]
.  1572   0624H  02800H          cmp      r0,#0
.  1574   0626H  0D001H          beq.n    2 -> 1580
.  1576   0628H  0E04AH          b        148 -> 1728
.  1578   062AH  046C0H          nop
        ch := str[first];
.  1580   062CH  09800H          ldr      r0,[sp]
.  1582   062EH  09905H          ldr      r1,[sp,#20]
.  1584   0630H  04288H          cmp      r0,r1
.  1586   0632H  0D301H          bcc.n    2 -> 1592
.  1588   0634H  0DF01H          svc      1
.  1590  <LineNo: 218>
.  1592   0638H  09904H          ldr      r1,[sp,#16]
.  1594   063AH  01808H          adds     r0,r1,r0
.  1596   063CH  07800H          ldrb     r0,[r0]
.  1598   063EH  0A903H          add      r1,sp,#12
.  1600   0640H  07048H          strb     r0,[r1,#1]
        IF (ch < "0") OR (ch > "9") THEN
.  1602   0642H  0A803H          add      r0,sp,#12
.  1604   0644H  07840H          ldrb     r0,[r0,#1]
.  1606   0646H  02830H          cmp      r0,#48
.  1608   0648H  0DA01H          bge.n    2 -> 1614
.  1610   064AH  0E006H          b        12 -> 1626
.  1612   064CH  046C0H          nop
.  1614   064EH  0A803H          add      r0,sp,#12
.  1616   0650H  07840H          ldrb     r0,[r0,#1]
.  1618   0652H  02839H          cmp      r0,#57
.  1620   0654H  0DC01H          bgt.n    2 -> 1626
.  1622   0656H  0E005H          b        10 -> 1636
.  1624   0658H  046C0H          nop
          res := SyntaxError;
.  1626   065AH  02002H          movs     r0,#2
.  1628   065CH  09908H          ldr      r1,[sp,#32]
.  1630   065EH  06008H          str      r0,[r1]
        ELSE
          digit := ORD(ch) - ORD("0");
.  1632   0660H  0E02DH          b        90 -> 1726
.  1634   0662H  046C0H          nop
.  1636   0664H  0A803H          add      r0,sp,#12
.  1638   0666H  07840H          ldrb     r0,[r0,#1]
.  1640   0668H  03830H          subs     r0,#48
.  1642   066AH  09002H          str      r0,[sp,#8]
          int := (int * 10) + digit;
.  1644   066CH  09807H          ldr      r0,[sp,#28]
.  1646   066EH  06800H          ldr      r0,[r0]
.  1648   0670H  0210AH          movs     r1,#10
.  1650   0672H  04348H          muls     r0,r1
.  1652   0674H  09902H          ldr      r1,[sp,#8]
.  1654   0676H  01840H          adds     r0,r0,r1
.  1656   0678H  09907H          ldr      r1,[sp,#28]
.  1658   067AH  06008H          str      r0,[r1]
          IF MaxInt - int < 0 THEN  (* works across overflow *)
.  1660   067CH  09807H          ldr      r0,[sp,#28]
.  1662   067EH  06800H          ldr      r0,[r0]
.  1664   0680H  04919H          ldr      r1,[pc,#100] -> 1768
.  1666   0682H  01A08H          subs     r0,r1,r0
.  1668   0684H  02800H          cmp      r0,#0
.  1670   0686H  0DB01H          blt.n    2 -> 1676
.  1672   0688H  0E016H          b        44 -> 1720
.  1674   068AH  046C0H          nop
            IF neg & (int = MinInt) THEN
.  1676   068CH  0A803H          add      r0,sp,#12
.  1678   068EH  07800H          ldrb     r0,[r0]
.  1680   0690H  02101H          movs     r1,#1
.  1682   0692H  04208H          tst      r0,r1
.  1684   0694H  0D101H          bne.n    2 -> 1690
.  1686   0696H  0E00CH          b        24 -> 1714
.  1688   0698H  046C0H          nop
.  1690   069AH  09807H          ldr      r0,[sp,#28]
.  1692   069CH  06800H          ldr      r0,[r0]
.  1694   069EH  04913H          ldr      r1,[pc,#76] -> 1772
.  1696   06A0H  042C8H          cmn      r0,r1
.  1698   06A2H  0D001H          beq.n    2 -> 1704
.  1700   06A4H  0E005H          b        10 -> 1714
.  1702   06A6H  046C0H          nop
              neg := FALSE
            ELSE
.  1704   06A8H  02000H          movs     r0,#0
.  1706   06AAH  0A903H          add      r1,sp,#12
.  1708   06ACH  07008H          strb     r0,[r1]
              res := OutOfLimits
.  1710   06AEH  0E003H          b        6 -> 1720
.  1712   06B0H  046C0H          nop
            END
.  1714   06B2H  02003H          movs     r0,#3
.  1716   06B4H  09908H          ldr      r1,[sp,#32]
.  1718   06B6H  06008H          str      r0,[r1]
          END;
          INC(first)
        END
.  1720   06B8H  09800H          ldr      r0,[sp]
.  1722   06BAH  03001H          adds     r0,#1
.  1724   06BCH  09000H          str      r0,[sp]
      END
.  1726   06BEH  0E7A9H          b        -174 -> 1556
    END;
    IF res = NoError THEN
.  1728   06C0H  09808H          ldr      r0,[sp,#32]
.  1730   06C2H  06800H          ldr      r0,[r0]
.  1732   06C4H  02800H          cmp      r0,#0
.  1734   06C6H  0D001H          beq.n    2 -> 1740
.  1736   06C8H  0E00CH          b        24 -> 1764
.  1738   06CAH  046C0H          nop
      IF neg THEN int := -int END
.  1740   06CCH  0A803H          add      r0,sp,#12
.  1742   06CEH  07800H          ldrb     r0,[r0]
.  1744   06D0H  02101H          movs     r1,#1
.  1746   06D2H  04208H          tst      r0,r1
.  1748   06D4H  0D101H          bne.n    2 -> 1754
.  1750   06D6H  0E005H          b        10 -> 1764
.  1752   06D8H  046C0H          nop
.  1754   06DAH  09807H          ldr      r0,[sp,#28]
.  1756   06DCH  06800H          ldr      r0,[r0]
.  1758   06DEH  04240H          rsbs     r0,r0,#0
.  1760   06E0H  09907H          ldr      r1,[sp,#28]
.  1762   06E2H  06008H          str      r0,[r1]
    END
  END StrToInt;
.  1764   06E4H  0B009H          add      sp,#36
.  1766   06E6H  0BD00H          pop      { pc }
.  1768  <Const: 07FFFFFFFH  07FFFFFFFH>
.  1772  <Const: 080000000H  -2147483648>

  (* read *)

  PROCEDURE ReadString*(R: TextIO.Reader; VAR s: ARRAY OF CHAR; VAR res: INTEGER);
  (**
    Read a string via 'R', terminated by any char < " ", usually a CR.
    Flush the rest of the input in case of buffer overflow.
    The string is truncated to the buffer length, terminated by 0X.
  **)
    VAR numCh: INTEGER;
  BEGIN
.  1776   06F0H  0B50FH          push     { r0, r1, r2, r3, lr }
.  1778   06F2H  0B081H          sub      sp,#4
    R.getString(R.dev, s, numCh, res);
.  1780   06F4H  09801H          ldr      r0,[sp,#4]
.  1782   06F6H  06800H          ldr      r0,[r0]
.  1784   06F8H  09902H          ldr      r1,[sp,#8]
.  1786   06FAH  09A03H          ldr      r2,[sp,#12]
.  1788   06FCH  0466BH          mov      r3,sp
.  1790   06FEH  09C04H          ldr      r4,[sp,#16]
.  1792   0700H  09D01H          ldr      r5,[sp,#4]
.  1794   0702H  0686DH          ldr      r5,[r5,#4]
.  1796   0704H  02D00H          cmp      r5,#0
.  1798   0706H  0D101H          bne.n    2 -> 1804
.  1800   0708H  0DF05H          svc      5
.  1802  <LineNo: 250>
.  1804   070CH  03501H          adds     r5,#1
.  1806   070EH  047A8H          blx      r5
.  1808   0710H  0E000H          b        0 -> 1812
.  1810  <LineNo: 249>
    IF res = NoError THEN
.  1812   0714H  09804H          ldr      r0,[sp,#16]
.  1814   0716H  06800H          ldr      r0,[r0]
.  1816   0718H  02800H          cmp      r0,#0
.  1818   071AH  0D001H          beq.n    2 -> 1824
.  1820   071CH  0E008H          b        16 -> 1840
.  1822   071EH  046C0H          nop
      IF numCh = 0 THEN
.  1824   0720H  09800H          ldr      r0,[sp]
.  1826   0722H  02800H          cmp      r0,#0
.  1828   0724H  0D001H          beq.n    2 -> 1834
.  1830   0726H  0E003H          b        6 -> 1840
.  1832   0728H  046C0H          nop
        res := NoInput
      END
.  1834   072AH  02004H          movs     r0,#4
.  1836   072CH  09904H          ldr      r1,[sp,#16]
.  1838   072EH  06008H          str      r0,[r1]
    END
  END ReadString;
.  1840   0730H  0B005H          add      sp,#20
.  1842   0732H  0BD00H          pop      { pc }


  PROCEDURE ReadInt*(R: TextIO.Reader; VAR int, res: INTEGER);
  (**
    Read an integer in decimal form via 'R', terminated by any char < " ", usually a CR.
    Flush the rest of the input in case of buffer overflow or fifo overrun.
    The number is not valid in case of any error.
    As long as there's no buffer overflow or fifo overrrun, any number of leading
    blanks, blanks after the sign, leading zeros, and trailing blanks are permitted.
  **)
    VAR numCh: INTEGER; buf: ARRAY 32 OF CHAR;
  BEGIN
.  1844   0734H  0B507H          push     { r0, r1, r2, lr }
.  1846   0736H  0B089H          sub      sp,#36
    R.getString(R.dev, buf, numCh, res);
.  1848   0738H  09809H          ldr      r0,[sp,#36]
.  1850   073AH  06800H          ldr      r0,[r0]
.  1852   073CH  0A901H          add      r1,sp,#4
.  1854   073EH  02220H          movs     r2,#32
.  1856   0740H  0466BH          mov      r3,sp
.  1858   0742H  09C0BH          ldr      r4,[sp,#44]
.  1860   0744H  09D09H          ldr      r5,[sp,#36]
.  1862   0746H  0686DH          ldr      r5,[r5,#4]
.  1864   0748H  02D00H          cmp      r5,#0
.  1866   074AH  0D101H          bne.n    2 -> 1872
.  1868   074CH  0DF05H          svc      5
.  1870  <LineNo: 269>
.  1872   0750H  03501H          adds     r5,#1
.  1874   0752H  047A8H          blx      r5
.  1876   0754H  0E000H          b        0 -> 1880
.  1878  <LineNo: 268>
    IF res = NoError THEN
.  1880   0758H  0980BH          ldr      r0,[sp,#44]
.  1882   075AH  06800H          ldr      r0,[r0]
.  1884   075CH  02800H          cmp      r0,#0
.  1886   075EH  0D001H          beq.n    2 -> 1892
.  1888   0760H  0E013H          b        38 -> 1930
.  1890   0762H  046C0H          nop
      IF numCh > 0 THEN
.  1892   0764H  09800H          ldr      r0,[sp]
.  1894   0766H  02800H          cmp      r0,#0
.  1896   0768H  0DC01H          bgt.n    2 -> 1902
.  1898   076AH  0E00BH          b        22 -> 1924
.  1900   076CH  046C0H          nop
        StrToInt(buf, numCh, int, res)
.  1902   076EH  0A801H          add      r0,sp,#4
.  1904   0770H  02120H          movs     r1,#32
.  1906   0772H  09A00H          ldr      r2,[sp]
.  1908   0774H  09B0AH          ldr      r3,[sp,#40]
.  1910   0776H  09C0BH          ldr      r4,[sp,#44]
      ELSE
.  1912   0778H  0F7FFFF24H      bl.w     -440 -> 1476
.  1916   077CH  0E000H          b        0 -> 1920
.  1918  <LineNo: 272>
        res := NoInput
.  1920   0780H  0E003H          b        6 -> 1930
.  1922   0782H  046C0H          nop
      END
.  1924   0784H  02004H          movs     r0,#4
.  1926   0786H  0990BH          ldr      r1,[sp,#44]
.  1928   0788H  06008H          str      r0,[r1]
    END
  END ReadInt;
.  1930   078AH  0B00CH          add      sp,#48
.  1932   078CH  0BD00H          pop      { pc }
.  1934   078EH  046C0H          nop


  PROCEDURE FlushOut*(W: TextIO.Writer);
  (**
    Allow flushing on writers that don't need it to keep
    program code independent of output channel if needed.
  **)
  BEGIN
.  1936   0790H  0B501H          push     { r0, lr }
    IF W.flush # NIL THEN
.  1938   0792H  09800H          ldr      r0,[sp]
.  1940   0794H  06880H          ldr      r0,[r0,#8]
.  1942   0796H  02800H          cmp      r0,#0
.  1944   0798H  0D101H          bne.n    2 -> 1950
.  1946   079AH  0E00CH          b        24 -> 1974
.  1948   079CH  046C0H          nop
      W.flush(W.dev)
.  1950   079EH  09800H          ldr      r0,[sp]
.  1952   07A0H  06800H          ldr      r0,[r0]
    END
.  1954   07A2H  09900H          ldr      r1,[sp]
.  1956   07A4H  06889H          ldr      r1,[r1,#8]
.  1958   07A6H  02900H          cmp      r1,#0
.  1960   07A8H  0D101H          bne.n    2 -> 1966
.  1962   07AAH  0DF05H          svc      5
.  1964  <LineNo: 287>
.  1966   07AEH  03101H          adds     r1,#1
.  1968   07B0H  04788H          blx      r1
.  1970   07B2H  0E000H          b        0 -> 1974
.  1972  <LineNo: 287>
  END FlushOut;
.  1974   07B6H  0B001H          add      sp,#4
.  1976   07B8H  0BD00H          pop      { pc }
.  1978   07BAH  046C0H          nop

BEGIN
.  1980   07BCH  0B500H          push     { lr }
  eol[0] := CR; eol[1] := LF
.  1982   07BEH  04803H          ldr      r0,[pc,#12] -> 1996
.  1984   07C0H  0210DH          movs     r1,#13
.  1986   07C2H  07001H          strb     r1,[r0]
.  1988   07C4H  04801H          ldr      r0,[pc,#4] -> 1996
END Texts.
.  1990   07C6H  0210AH          movs     r1,#10
.  1992   07C8H  07041H          strb     r1,[r0,#1]
.  1994   07CAH  0BD00H          pop      { pc }
.  1996  <Global: 0000401E6H  0401E6H>
