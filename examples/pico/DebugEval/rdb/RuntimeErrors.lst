.     0  <Pad: 0>
MODULE RuntimeErrors;
(**
  Oberon RTK Framework
  Exception handling: run-time errors and faults
  Multi-core
  --
  Error: run-time errors, including ASSERT, triggered by SVC calls
  Fault: hardware faults, triggered by MCU
  --
  MCU: Cortex-M0+ RP2040, tested on Pico
  --
  Note, no printing is done here, since we don't know if there's
  even a terminal connected out in the wild, and if there's an
  operator seeing the messages. All error and fault data is collected,
  and passed to an installable handler, which then can print, or just log
  (or both), or take autonomous corrective actions, such as a restart.

  See module RuntimeErrorsOut for a corresponding handler and print
  functions.
  --
  Copyright (c) 2020-2024 Gray, gray@grayraven.org
  Portions copyright (c) 2008-2023 CFB Software, https://www.astrobe.com
  Used with permission.
  Please refer to the licensing conditions as defined at the end of this file.
**)

  IMPORT
    SYSTEM, LED, MCU := MCU2, Config, Memory;

  CONST
    NumCores* = Config.NumCores;
    NumStackedRegs* = 4;
    TraceDepth* = 7;
    MoreTracePoints* = -1;
    StackTraceNotLR = 0;
    StackTraceLineNo = 1;
    StackTraceNoLineNo = 2;
    ErrorLed = LED.Green;

    (* stacked registers offsets from r0 *)
    StartStacktraceOffset = 32;
    PSRoffset = 28;
    PCoffset = 24;

    (* register numbers *)
    SP = 13;
    LR = 14;
    PC = 15;

  (*
    offsets if handler is compiled as normal procedure:
    +36 +48   lower end of stack frame of interrupted proc with stack alignment
    +32 +44   lower end of stack frame of interrupted proc without stack alignment
        from here down, stacked by hardware
    +28 +40   xPSR
    +24 +36   PC  = handler return address
    +20 +32   LR  = interrupted procs's LR
    +16 +28   R12
    +12 +24   R3
    +8  +20   R2
    +4  +16   R1
     0  +12   R0
        from here down, pushed by handler prologue
        +8    LR  = EXC_RETURN
        +4    local var of handler
        SP => local var of handler
  *)


  TYPE
    TracePoint* = RECORD
      address*: INTEGER;
      lineNo*: INTEGER
    END;
.     4  <Type: 8>
.     8  <Type: 0>
.    12  <Type: 0>
.    16  <Type: 0>
.    20  <Type: 0>

    Trace* = RECORD
      tp*: ARRAY TraceDepth + 1 OF TracePoint;
      count*: INTEGER
    END;
.    24  <Type: 68>
.    28  <Type: 0>
.    32  <Type: 0>
.    36  <Type: 0>
.    40  <Type: 0>

    StackedRegisters* = RECORD
      r0*, r1*, r2*, r3*, r12*: INTEGER;
      lr*, pc*, xpsr*, sp*: INTEGER
    END;
.    44  <Type: 36>
.    48  <Type: 0>
.    52  <Type: 0>
.    56  <Type: 0>
.    60  <Type: 0>

    CurrentRegisters* = RECORD
      sp*, lr*, pc*, xpsr*: INTEGER
    END;
.    64  <Type: 16>
.    68  <Type: 0>
.    72  <Type: 0>
.    76  <Type: 0>
.    80  <Type: 0>

    (* note/todo: depending on the final design decision, 'StackedRegisters'
    and 'CurrentRegisters' can be put into 'ExceptionRec' *)

    ExceptionRec* = RECORD
      code*: INTEGER;
      core*: INTEGER;
    END;
.    84  <Type: 8>
.    88  <Type: 0>
.    92  <Type: 0>
.    96  <Type: 0>
.   100  <Type: 0>

    FaultRec* = RECORD(ExceptionRec)
      address*: INTEGER;
      stackedRegs*: StackedRegisters;
      currentRegs*: CurrentRegisters
    END;
.   104  <Type: 64>
.   108  <Type: 0680000H>
.   112  <Type: 0>
.   116  <Type: 0>
.   120  <Type: 0>

    ErrorRec* = RECORD(ExceptionRec)
      trace*: Trace;
      stackedRegs*: StackedRegisters;
      currentRegs*: CurrentRegisters
    END;
.   124  <Type: 128>
.   128  <Type: 07C0036H>
.   132  <Type: 0>
.   136  <Type: 0>
.   140  <Type: 0>

    Exception = RECORD
      faultRec: FaultRec;
      errorRec: ErrorRec;
      handleException: PROCEDURE(cpuId: INTEGER; er: ExceptionRec);
      haltOn, stackTraceOn, stackedRegsOn, currentRegsOn: BOOLEAN
    END;
.   144  <Type: 200>
.   148  <Type: 0>
.   152  <Type: 0>
.   156  <Type: 0>
.   160  <Type: 0>


  VAR
    exc: ARRAY NumCores OF Exception;

  (* IMPORTANT: if the error/fault handler does not HALT, 'handleException' has to set an
  appropriate exception return address on the stack to continue in a reasonable way. *)

  PROCEDURE* HALT(cid: INTEGER);
  BEGIN
.   164    0A4H  0B501H          push     { r0, lr }
    IF exc[cid].haltOn THEN
.   166    0A6H  09800H          ldr      r0,[sp]
.   168    0A8H  04907H          ldr      r1,[pc,#28] -> 200
.   170    0AAH  022C8H          movs     r2,#200
.   172    0ACH  04350H          muls     r0,r2
.   174    0AEH  01808H          adds     r0,r1,r0
.   176    0B0H  021C4H          movs     r1,#196
.   178    0B2H  05C40H          ldrb     r0,[r0,r1]
.   180    0B4H  02101H          movs     r1,#1
.   182    0B6H  04208H          tst      r0,r1
.   184    0B8H  0D101H          bne.n    2 -> 190
.   186    0BAH  0E002H          b        4 -> 194
.   188    0BCH  046C0H          nop
      REPEAT UNTIL FALSE
    END
.   190    0BEH  04280H          cmp      r0,r0
.   192    0C0H  0D0FDH          beq.n    -6 -> 190
  END HALT;
.   194    0C2H  0B001H          add      sp,#4
.   196    0C4H  0BD00H          pop      { pc }
.   198    0C6H  046C0H          nop
.   200  <Global: 001900000H  01900000H>

  (* --- Astrobe code begin --- *)

  PROCEDURE getHalfWord(addr: INTEGER; VAR value: INTEGER);
  (* from Astrobe library, modified *)
  (* get 16-bit data from an address that is possibly not word-aligned *)
    VAR b1, b2: BYTE;
  BEGIN
.   204    0CCH  0B503H          push     { r0, r1, lr }
.   206    0CEH  0B081H          sub      sp,#4
    SYSTEM.GET(addr + 1, b1);
.   208    0D0H  09801H          ldr      r0,[sp,#4]
.   210    0D2H  03001H          adds     r0,#1
.   212    0D4H  07801H          ldrb     r1,[r0]
.   214    0D6H  0AA00H          add      r2,sp,#0
.   216    0D8H  07011H          strb     r1,[r2]
    SYSTEM.GET(addr, b2);
.   218    0DAH  09801H          ldr      r0,[sp,#4]
.   220    0DCH  07801H          ldrb     r1,[r0]
.   222    0DEH  0AA00H          add      r2,sp,#0
.   224    0E0H  07051H          strb     r1,[r2,#1]
    value := LSL(b1, 8) + b2
.   226    0E2H  0A800H          add      r0,sp,#0
.   228    0E4H  07800H          ldrb     r0,[r0]
.   230    0E6H  00200H          lsls     r0,r0,#8
  END getHalfWord;
.   232    0E8H  0A900H          add      r1,sp,#0
.   234    0EAH  07849H          ldrb     r1,[r1,#1]
.   236    0ECH  01840H          adds     r0,r0,r1
.   238    0EEH  09902H          ldr      r1,[sp,#8]
.   240    0F0H  06008H          str      r0,[r1]
.   242    0F2H  0B003H          add      sp,#12
.   244    0F4H  0BD00H          pop      { pc }
.   246    0F6H  046C0H          nop

  PROCEDURE isBL(codeAddr: INTEGER): BOOLEAN;
  (* from Astrobe library *)
  (* check if the instruction at 'codeAddr' is a BL instruction *)
    VAR instr: INTEGER;
  BEGIN
.   248    0F8H  0B501H          push     { r0, lr }
.   250    0FAH  0B081H          sub      sp,#4
    getHalfWord(codeAddr, instr);
.   252    0FCH  09801H          ldr      r0,[sp,#4]
.   254    0FEH  04669H          mov      r1,sp
.   256   0100H  0F7FFFFE4H      bl.w     -56 -> 204
.   260   0104H  0E000H          b        0 -> 264
.   262  <LineNo: 148>
    RETURN BFX(instr, 15, 11) = 01EH
.   264   0108H  09800H          ldr      r0,[sp]
.   266   010AH  00400H          lsls     r0,r0,#16
.   268   010CH  00EC0H          lsrs     r0,r0,#27
  END isBL;
.   270   010EH  0281EH          cmp      r0,#30
.   272   0110H  0D001H          beq.n    2 -> 278
.   274   0112H  02000H          movs     r0,#0
.   276   0114H  0E000H          b        0 -> 280
.   278   0116H  02001H          movs     r0,#1
.   280   0118H  0B002H          add      sp,#8
.   282   011AH  0BD00H          pop      { pc }

  PROCEDURE isBLX(codeAddr: INTEGER): BOOLEAN;
  (* from Astrobe library *)
  (* check if the instruction at 'codeAddr' is a BLX instruction *)
    VAR instr: INTEGER;
  BEGIN
.   284   011CH  0B501H          push     { r0, lr }
.   286   011EH  0B081H          sub      sp,#4
    getHalfWord(codeAddr, instr);
.   288   0120H  09801H          ldr      r0,[sp,#4]
.   290   0122H  04669H          mov      r1,sp
.   292   0124H  0F7FFFFD2H      bl.w     -92 -> 204
.   296   0128H  0E000H          b        0 -> 300
.   298  <LineNo: 157>
    RETURN (BFX(instr, 15, 7) = 08FH) & (BFX(instr, 2, 0) = 0)
.   300   012CH  09800H          ldr      r0,[sp]
.   302   012EH  00400H          lsls     r0,r0,#16
.   304   0130H  00DC0H          lsrs     r0,r0,#23
.   306   0132H  0288FH          cmp      r0,#143
.   308   0134H  0D001H          beq.n    2 -> 314
.   310   0136H  0E005H          b        10 -> 324
.   312   0138H  046C0H          nop
.   314   013AH  09800H          ldr      r0,[sp]
.   316   013CH  00740H          lsls     r0,r0,#29
.   318   013EH  00F40H          lsrs     r0,r0,#29
.   320   0140H  02800H          cmp      r0,#0
  END isBLX;
.   322   0142H  0D001H          beq.n    2 -> 328
.   324   0144H  02000H          movs     r0,#0
.   326   0146H  0E000H          b        0 -> 330
.   328   0148H  02001H          movs     r0,#1
.   330   014AH  0B002H          add      sp,#8
.   332   014CH  0BD00H          pop      { pc }
.   334   014EH  046C0H          nop

  PROCEDURE getNextLR(stackAddr: INTEGER; VAR lr, res: INTEGER);
  (* from Astrobe library. modified *)
  (* Check if the value at 'stackAddr' on the stack is a link register address.
  If yes, it will point to a code address (+1 for thumb mode) which
  is preceded by a BL or BLX instruction. *)
    VAR nextInstr: INTEGER;
  BEGIN
.   336   0150H  0B507H          push     { r0, r1, r2, lr }
.   338   0152H  0B081H          sub      sp,#4
    res := StackTraceNotLR;
.   340   0154H  02000H          movs     r0,#0
.   342   0156H  09903H          ldr      r1,[sp,#12]
.   344   0158H  06008H          str      r0,[r1]
    SYSTEM.GET(stackAddr, lr);
.   346   015AH  09801H          ldr      r0,[sp,#4]
.   348   015CH  06801H          ldr      r1,[r0]
.   350   015EH  09A02H          ldr      r2,[sp,#8]
.   352   0160H  06011H          str      r1,[r2]
    (* must be Thumb mode *)
    IF ODD(lr) THEN
.   354   0162H  09802H          ldr      r0,[sp,#8]
.   356   0164H  06800H          ldr      r0,[r0]
.   358   0166H  02101H          movs     r1,#1
.   360   0168H  04208H          tst      r0,r1
.   362   016AH  0D101H          bne.n    2 -> 368
.   364   016CH  0E042H          b        132 -> 500
.   366   016EH  046C0H          nop
      DEC(lr);
.   368   0170H  09802H          ldr      r0,[sp,#8]
.   370   0172H  06801H          ldr      r1,[r0]
.   372   0174H  03901H          subs     r1,#1
.   374   0176H  06001H          str      r1,[r0]
      IF (lr >= Config.CodeStart) & (lr < Config.CodeEnd) THEN
.   376   0178H  09802H          ldr      r0,[sp,#8]
.   378   017AH  06800H          ldr      r0,[r0]
.   380   017CH  0491EH          ldr      r1,[pc,#120] -> 504
.   382   017EH  06809H          ldr      r1,[r1]
.   384   0180H  04288H          cmp      r0,r1
.   386   0182H  0DA01H          bge.n    2 -> 392
.   388   0184H  0E036H          b        108 -> 500
.   390   0186H  046C0H          nop
.   392   0188H  09802H          ldr      r0,[sp,#8]
.   394   018AH  06800H          ldr      r0,[r0]
.   396   018CH  0491BH          ldr      r1,[pc,#108] -> 508
.   398   018EH  06809H          ldr      r1,[r1]
.   400   0190H  04288H          cmp      r0,r1
.   402   0192H  0DB01H          blt.n    2 -> 408
.   404   0194H  0E02EH          b        92 -> 500
.   406   0196H  046C0H          nop
        IF isBL(lr - 4) OR isBLX(lr - 2) THEN
.   408   0198H  09802H          ldr      r0,[sp,#8]
.   410   019AH  06800H          ldr      r0,[r0]
.   412   019CH  03804H          subs     r0,#4
.   414   019EH  0F7FFFFABH      bl.w     -170 -> 248
.   418   01A2H  0E000H          b        0 -> 422
.   420  <LineNo: 174>
.   422   01A6H  02101H          movs     r1,#1
.   424   01A8H  04208H          tst      r0,r1
.   426   01AAH  0D001H          beq.n    2 -> 432
.   428   01ACH  0E00CH          b        24 -> 456
.   430   01AEH  046C0H          nop
.   432   01B0H  09802H          ldr      r0,[sp,#8]
.   434   01B2H  06800H          ldr      r0,[r0]
.   436   01B4H  03802H          subs     r0,#2
.   438   01B6H  0F7FFFFB1H      bl.w     -158 -> 284
.   442   01BAH  0E000H          b        0 -> 446
.   444  <LineNo: 174>
.   446   01BEH  02101H          movs     r1,#1
.   448   01C0H  04208H          tst      r0,r1
.   450   01C2H  0D101H          bne.n    2 -> 456
.   452   01C4H  0E016H          b        44 -> 500
.   454   01C6H  046C0H          nop
          getHalfWord(lr, nextInstr);
.   456   01C8H  09802H          ldr      r0,[sp,#8]
.   458   01CAH  06800H          ldr      r0,[r0]
.   460   01CCH  04669H          mov      r1,sp
.   462   01CEH  0F7FFFF7DH      bl.w     -262 -> 204
.   466   01D2H  0E000H          b        0 -> 470
.   468  <LineNo: 175>
          (* if stack trace is enabled there should be a B,0 instruction (0E0000H)
          that skips the line number after the BL instruction *)
          IF nextInstr = 0E000H THEN
.   470   01D6H  09800H          ldr      r0,[sp]
.   472   01D8H  02107H          movs     r1,#7
.   474   01DAH  00349H          lsls     r1,r1,#13
.   476   01DCH  04288H          cmp      r0,r1
.   478   01DEH  0D001H          beq.n    2 -> 484
.   480   01E0H  0E005H          b        10 -> 494
.   482   01E2H  046C0H          nop
            res := StackTraceLineNo
          ELSE
.   484   01E4H  02001H          movs     r0,#1
.   486   01E6H  09903H          ldr      r1,[sp,#12]
.   488   01E8H  06008H          str      r0,[r1]
            res := StackTraceNoLineNo
.   490   01EAH  0E003H          b        6 -> 500
.   492   01ECH  046C0H          nop
          END
.   494   01EEH  02002H          movs     r0,#2
.   496   01F0H  09903H          ldr      r1,[sp,#12]
.   498   01F2H  06008H          str      r0,[r1]
        END
      END
    END
  END getNextLR;
.   500   01F4H  0B004H          add      sp,#16
.   502   01F6H  0BD00H          pop      { pc }
.   504  <Global: 000050000H  050000H>
.   508  <Global: 0000600FCH  0600FCH>

  (* --- Astrobe code end --- *)


  PROCEDURE Stacktrace*(stackAddr: INTEGER; VAR trace: Trace);
    VAR
      lr, x, res: INTEGER;
      tp: TracePoint;
  BEGIN
.   512   0200H  0B507H          push     { r0, r1, r2, lr }
.   514   0202H  0B085H          sub      sp,#20
    SYSTEM.GET(stackAddr, x);
.   516   0204H  09805H          ldr      r0,[sp,#20]
.   518   0206H  06801H          ldr      r1,[r0]
.   520   0208H  09101H          str      r1,[sp,#4]
    WHILE (stackAddr # x) & (trace.count < TraceDepth) DO
.   522   020AH  09805H          ldr      r0,[sp,#20]
.   524   020CH  09901H          ldr      r1,[sp,#4]
.   526   020EH  04288H          cmp      r0,r1
.   528   0210H  0D101H          bne.n    2 -> 534
.   530   0212H  0E041H          b        130 -> 664
.   532   0214H  046C0H          nop
.   534   0216H  09806H          ldr      r0,[sp,#24]
.   536   0218H  06C00H          ldr      r0,[r0,#64]
.   538   021AH  02807H          cmp      r0,#7
.   540   021CH  0DB01H          blt.n    2 -> 546
.   542   021EH  0E03BH          b        118 -> 664
.   544   0220H  046C0H          nop
      getNextLR(stackAddr, lr, res);
.   546   0222H  09805H          ldr      r0,[sp,#20]
.   548   0224H  04669H          mov      r1,sp
.   550   0226H  0AA02H          add      r2,sp,#8
.   552   0228H  0F7FFFF92H      bl.w     -220 -> 336
.   556   022CH  0E000H          b        0 -> 560
.   558  <LineNo: 198>
      IF res > StackTraceNotLR THEN
.   560   0230H  09802H          ldr      r0,[sp,#8]
.   562   0232H  02800H          cmp      r0,#0
.   564   0234H  0DC01H          bgt.n    2 -> 570
.   566   0236H  0E028H          b        80 -> 650
.   568   0238H  046C0H          nop
        tp.address := lr - 4;
.   570   023AH  09800H          ldr      r0,[sp]
.   572   023CH  03804H          subs     r0,#4
.   574   023EH  09003H          str      r0,[sp,#12]
        IF res = StackTraceLineNo THEN
.   576   0240H  09802H          ldr      r0,[sp,#8]
.   578   0242H  02801H          cmp      r0,#1
.   580   0244H  0D001H          beq.n    2 -> 586
.   582   0246H  0E009H          b        18 -> 604
.   584   0248H  046C0H          nop
          getHalfWord(lr + 2, tp.lineNo)
.   586   024AH  09800H          ldr      r0,[sp]
.   588   024CH  03002H          adds     r0,#2
.   590   024EH  0A904H          add      r1,sp,#16
        ELSE
.   592   0250H  0F7FFFF3CH      bl.w     -392 -> 204
.   596   0254H  0E000H          b        0 -> 600
.   598  <LineNo: 202>
          tp.lineNo := 0
.   600   0258H  0E002H          b        4 -> 608
.   602   025AH  046C0H          nop
        END;
.   604   025CH  02000H          movs     r0,#0
.   606   025EH  09004H          str      r0,[sp,#16]
        trace.tp[trace.count] := tp;
.   608   0260H  09806H          ldr      r0,[sp,#24]
.   610   0262H  06C00H          ldr      r0,[r0,#64]
.   612   0264H  02808H          cmp      r0,#8
.   614   0266H  0D301H          bcc.n    2 -> 620
.   616   0268H  0DF01H          svc      1
.   618  <LineNo: 206>
.   620   026CH  09906H          ldr      r1,[sp,#24]
.   622   026EH  000C0H          lsls     r0,r0,#3
.   624   0270H  01808H          adds     r0,r1,r0
.   626   0272H  02102H          movs     r1,#2
.   628   0274H  0AA03H          add      r2,sp,#12
.   630   0276H  06813H          ldr      r3,[r2]
.   632   0278H  03204H          adds     r2,#4
.   634   027AH  06003H          str      r3,[r0]
.   636   027CH  03004H          adds     r0,#4
.   638   027EH  03901H          subs     r1,#1
.   640   0280H  0D1F9H          bne.n    -14 -> 630
        INC(trace.count)
      END;
.   642   0282H  09806H          ldr      r0,[sp,#24]
.   644   0284H  06C01H          ldr      r1,[r0,#64]
.   646   0286H  03101H          adds     r1,#1
.   648   0288H  06401H          str      r1,[r0,#64]
      INC(stackAddr, 4);
.   650   028AH  09805H          ldr      r0,[sp,#20]
.   652   028CH  03004H          adds     r0,#4
.   654   028EH  09005H          str      r0,[sp,#20]
      SYSTEM.GET(stackAddr, x)
    END;
.   656   0290H  09805H          ldr      r0,[sp,#20]
.   658   0292H  06801H          ldr      r1,[r0]
.   660   0294H  09101H          str      r1,[sp,#4]
.   662   0296H  0E7B8H          b        -144 -> 522
    IF trace.count = TraceDepth THEN
.   664   0298H  09806H          ldr      r0,[sp,#24]
.   666   029AH  06C00H          ldr      r0,[r0,#64]
.   668   029CH  02807H          cmp      r0,#7
.   670   029EH  0D001H          beq.n    2 -> 676
.   672   02A0H  0E003H          b        6 -> 682
.   674   02A2H  046C0H          nop
      trace.tp[TraceDepth].address := MoreTracePoints
    END
.   676   02A4H  04802H          ldr      r0,[pc,#8] -> 688
.   678   02A6H  09906H          ldr      r1,[sp,#24]
.   680   02A8H  06388H          str      r0,[r1,#56]
  END Stacktrace;
.   682   02AAH  0B008H          add      sp,#32
.   684   02ACH  0BD00H          pop      { pc }
.   686   02AEH  046C0H          nop
.   688  <Const: 0FFFFFFFFH  -1>


  PROCEDURE extractError(stackFrameBase: INTEGER; VAR errorRec: ErrorRec);
  (* collect error data, fill in top trace point *)
    VAR tp: TracePoint; addr: INTEGER;
  BEGIN
.   692   02B4H  0B507H          push     { r0, r1, r2, lr }
.   694   02B6H  0B083H          sub      sp,#12
    SYSTEM.GET(stackFrameBase + PCoffset, addr); (* return address for exc handler (PC on stack) *)
.   696   02B8H  09803H          ldr      r0,[sp,#12]
.   698   02BAH  03018H          adds     r0,#24
.   700   02BCH  06801H          ldr      r1,[r0]
.   702   02BEH  09102H          str      r1,[sp,#8]
    getHalfWord(addr, tp.lineNo); (* source code line number *)
.   704   02C0H  09802H          ldr      r0,[sp,#8]
.   706   02C2H  0A901H          add      r1,sp,#4
.   708   02C4H  0F7FFFF02H      bl.w     -508 -> 204
.   712   02C8H  0E000H          b        0 -> 716
.   714  <LineNo: 223>
    DEC(addr, 2); (* address of SVC instruction *)
.   716   02CCH  09802H          ldr      r0,[sp,#8]
.   718   02CEH  03802H          subs     r0,#2
.   720   02D0H  09002H          str      r0,[sp,#8]
    tp.address := addr; (* SCV instruction address = error address *)
.   722   02D2H  09802H          ldr      r0,[sp,#8]
.   724   02D4H  09000H          str      r0,[sp]
    getHalfWord(addr, errorRec.code); (* SCV instruction *)
.   726   02D6H  09802H          ldr      r0,[sp,#8]
.   728   02D8H  09904H          ldr      r1,[sp,#16]
.   730   02DAH  0F7FFFEF7H      bl.w     -530 -> 204
.   734   02DEH  0E000H          b        0 -> 738
.   736  <LineNo: 226>
    errorRec.code := BFX(errorRec.code, 7, 0); (* error code *)
.   738   02E2H  09804H          ldr      r0,[sp,#16]
.   740   02E4H  06800H          ldr      r0,[r0]
.   742   02E6H  0B2C0H          uxtb     r0,r0
.   744   02E8H  09904H          ldr      r1,[sp,#16]
.   746   02EAH  06008H          str      r0,[r1]
    errorRec.trace.tp[0] := tp;
.   748   02ECH  02002H          movs     r0,#2
.   750   02EEH  09904H          ldr      r1,[sp,#16]
.   752   02F0H  03108H          adds     r1,#8
.   754   02F2H  0466AH          mov      r2,sp
.   756   02F4H  06813H          ldr      r3,[r2]
.   758   02F6H  03204H          adds     r2,#4
.   760   02F8H  0600BH          str      r3,[r1]
.   762   02FAH  03104H          adds     r1,#4
.   764   02FCH  03801H          subs     r0,#1
.   766   02FEH  0D1F9H          bne.n    -14 -> 756
    errorRec.trace.count := 1
  END extractError;
.   768   0300H  02001H          movs     r0,#1
.   770   0302H  09904H          ldr      r1,[sp,#16]
.   772   0304H  06488H          str      r0,[r1,#72]
.   774   0306H  0B006H          add      sp,#24
.   776   0308H  0BD00H          pop      { pc }
.   778   030AH  046C0H          nop


  PROCEDURE extractFault(stackFrameBase: INTEGER; VAR faultRec: FaultRec);
  BEGIN
.   780   030CH  0B507H          push     { r0, r1, r2, lr }
    SYSTEM.GET(stackFrameBase + PCoffset, faultRec.address);
.   782   030EH  09800H          ldr      r0,[sp]
.   784   0310H  03018H          adds     r0,#24
.   786   0312H  06801H          ldr      r1,[r0]
.   788   0314H  09A01H          ldr      r2,[sp,#4]
.   790   0316H  06091H          str      r1,[r2,#8]
    SYSTEM.EMIT(MCU.MRS_R11_IPSR);
.   792   0318H  0F3EF8B05H      .word 0x8B05F3EF /* EMIT */
    faultRec.code := SYSTEM.REG(11);
.   796   031CH  04658H          mov      r0,r11
.   798   031EH  09901H          ldr      r1,[sp,#4]
.   800   0320H  06008H          str      r0,[r1]
  END extractFault;
.   802   0322H  0B003H          add      sp,#12
.   804   0324H  0BD00H          pop      { pc }
.   806   0326H  046C0H          nop


  PROCEDURE readRegs(stackFrameBase: INTEGER; VAR stackedRegs: StackedRegisters);
  BEGIN
.   808   0328H  0B507H          push     { r0, r1, r2, lr }
    SYSTEM.GET(stackFrameBase, stackedRegs.r0);
.   810   032AH  09800H          ldr      r0,[sp]
.   812   032CH  06801H          ldr      r1,[r0]
.   814   032EH  09A01H          ldr      r2,[sp,#4]
.   816   0330H  06011H          str      r1,[r2]
    SYSTEM.GET(stackFrameBase + 4, stackedRegs.r1);
.   818   0332H  09800H          ldr      r0,[sp]
.   820   0334H  03004H          adds     r0,#4
.   822   0336H  06801H          ldr      r1,[r0]
.   824   0338H  09A01H          ldr      r2,[sp,#4]
.   826   033AH  06051H          str      r1,[r2,#4]
    SYSTEM.GET(stackFrameBase + 8, stackedRegs.r2);
.   828   033CH  09800H          ldr      r0,[sp]
.   830   033EH  03008H          adds     r0,#8
.   832   0340H  06801H          ldr      r1,[r0]
.   834   0342H  09A01H          ldr      r2,[sp,#4]
.   836   0344H  06091H          str      r1,[r2,#8]
    SYSTEM.GET(stackFrameBase + 12, stackedRegs.r3);
.   838   0346H  09800H          ldr      r0,[sp]
.   840   0348H  0300CH          adds     r0,#12
.   842   034AH  06801H          ldr      r1,[r0]
.   844   034CH  09A01H          ldr      r2,[sp,#4]
.   846   034EH  060D1H          str      r1,[r2,#12]
    SYSTEM.GET(stackFrameBase + 16, stackedRegs.r12);
.   848   0350H  09800H          ldr      r0,[sp]
.   850   0352H  03010H          adds     r0,#16
.   852   0354H  06801H          ldr      r1,[r0]
.   854   0356H  09A01H          ldr      r2,[sp,#4]
.   856   0358H  06111H          str      r1,[r2,#16]
    SYSTEM.GET(stackFrameBase + 20, stackedRegs.lr);
.   858   035AH  09800H          ldr      r0,[sp]
.   860   035CH  03014H          adds     r0,#20
.   862   035EH  06801H          ldr      r1,[r0]
.   864   0360H  09A01H          ldr      r2,[sp,#4]
.   866   0362H  06151H          str      r1,[r2,#20]
    SYSTEM.GET(stackFrameBase + 24, stackedRegs.pc);
.   868   0364H  09800H          ldr      r0,[sp]
.   870   0366H  03018H          adds     r0,#24
.   872   0368H  06801H          ldr      r1,[r0]
.   874   036AH  09A01H          ldr      r2,[sp,#4]
.   876   036CH  06191H          str      r1,[r2,#24]
    SYSTEM.GET(stackFrameBase + 28, stackedRegs.xpsr);
.   878   036EH  09800H          ldr      r0,[sp]
.   880   0370H  0301CH          adds     r0,#28
.   882   0372H  06801H          ldr      r1,[r0]
.   884   0374H  09A01H          ldr      r2,[sp,#4]
.   886   0376H  061D1H          str      r1,[r2,#28]
    stackedRegs.sp := stackFrameBase
  END readRegs;
.   888   0378H  09800H          ldr      r0,[sp]
.   890   037AH  09901H          ldr      r1,[sp,#4]
.   892   037CH  06208H          str      r0,[r1,#32]
.   894   037EH  0B003H          add      sp,#12
.   896   0380H  0BD00H          pop      { pc }
.   898   0382H  046C0H          nop


  PROCEDURE traceStart(stackFrameBase: INTEGER): INTEGER;
    CONST StackAlignBit = 9; (* in stacked PSR *)
    VAR addr: INTEGER;
  BEGIN
.   900   0384H  0B501H          push     { r0, lr }
.   902   0386H  0B081H          sub      sp,#4
    addr := stackFrameBase + StartStacktraceOffset;
.   904   0388H  09801H          ldr      r0,[sp,#4]
.   906   038AH  03020H          adds     r0,#32
.   908   038CH  09000H          str      r0,[sp]
    IF SYSTEM.BIT(stackFrameBase + PSRoffset, StackAlignBit) THEN
.   910   038EH  09801H          ldr      r0,[sp,#4]
.   912   0390H  0301CH          adds     r0,#28
.   914   0392H  06801H          ldr      r1,[r0]
.   916   0394H  00589H          lsls     r1,r1,#22
.   918   0396H  0D401H          bmi.n    2 -> 924
.   920   0398H  0E003H          b        6 -> 930
.   922   039AH  046C0H          nop
      INC(addr, 4)
    END
.   924   039CH  09800H          ldr      r0,[sp]
.   926   039EH  03004H          adds     r0,#4
.   928   03A0H  09000H          str      r0,[sp]
    RETURN addr
  END traceStart;
.   930   03A2H  09800H          ldr      r0,[sp]
.   932   03A4H  0B002H          add      sp,#8
.   934   03A6H  0BD00H          pop      { pc }


  PROCEDURE stackFrameBase(stackAddr, EXC_RETURN: INTEGER): INTEGER;
    VAR addr: INTEGER;
  BEGIN
.   936   03A8H  0B503H          push     { r0, r1, lr }
.   938   03AAH  0B081H          sub      sp,#4
    IF 2 IN BITS(EXC_RETURN) THEN (* PSP and MSP used *)
.   940   03ACH  09802H          ldr      r0,[sp,#8]
.   942   03AEH  02104H          movs     r1,#4
.   944   03B0H  04208H          tst      r0,r1
.   946   03B2H  0D101H          bne.n    2 -> 952
.   948   03B4H  0E006H          b        12 -> 964
.   950   03B6H  046C0H          nop
      SYSTEM.EMIT(MCU.MRS_R11_PSP);
.   952   03B8H  0F3EF8B09H      .word 0x8B09F3EF /* EMIT */
      addr := SYSTEM.REG(11)
    ELSE (* only MSP used *)
.   956   03BCH  04658H          mov      r0,r11
.   958   03BEH  09000H          str      r0,[sp]
      addr := stackAddr
.   960   03C0H  0E002H          b        4 -> 968
.   962   03C2H  046C0H          nop
    END
.   964   03C4H  09801H          ldr      r0,[sp,#4]
.   966   03C6H  09000H          str      r0,[sp]
    RETURN addr
  END stackFrameBase;
.   968   03C8H  09800H          ldr      r0,[sp]
.   970   03CAH  0B003H          add      sp,#12
.   972   03CCH  0BD00H          pop      { pc }
.   974   03CEH  046C0H          nop


  PROCEDURE errorHandler;
  (* via compiler-inserted SVC instruction *)
  (* in main stack *)
    VAR stackFrameAddr, cid: INTEGER;
  BEGIN
.   976   03D0H  0B500H          push     { lr }
.   978   03D2H  0B082H          sub      sp,#8
    SYSTEM.GET(MCU.SIO_CPUID, cid);
.   980   03D4H  0486DH          ldr      r0,[pc,#436] -> 1420
.   982   03D6H  06801H          ldr      r1,[r0]
.   984   03D8H  09101H          str      r1,[sp,#4]
    IF exc[cid].currentRegsOn THEN
.   986   03DAH  09801H          ldr      r0,[sp,#4]
.   988   03DCH  02802H          cmp      r0,#2
.   990   03DEH  0D301H          bcc.n    2 -> 996
.   992   03E0H  0DF01H          svc      1
.   994  <LineNo: 286>
.   996   03E4H  0496EH          ldr      r1,[pc,#440] -> 1440
.   998   03E6H  022C8H          movs     r2,#200
.  1000   03E8H  04350H          muls     r0,r2
.  1002   03EAH  01808H          adds     r0,r1,r0
.  1004   03ECH  021C7H          movs     r1,#199
.  1006   03EEH  05C40H          ldrb     r0,[r0,r1]
.  1008   03F0H  02101H          movs     r1,#1
.  1010   03F2H  04208H          tst      r0,r1
.  1012   03F4H  0D101H          bne.n    2 -> 1018
.  1014   03F6H  0E032H          b        100 -> 1118
.  1016   03F8H  046C0H          nop
      exc[cid].errorRec.currentRegs.pc := SYSTEM.REG(PC); (* pretty useless *)
.  1018   03FAH  09801H          ldr      r0,[sp,#4]
.  1020   03FCH  02802H          cmp      r0,#2
.  1022   03FEH  0D301H          bcc.n    2 -> 1028
.  1024   0400H  0DF01H          svc      1
.  1026  <LineNo: 287>
.  1028   0404H  04966H          ldr      r1,[pc,#408] -> 1440
.  1030   0406H  022C8H          movs     r2,#200
.  1032   0408H  04350H          muls     r0,r2
.  1034   040AH  01808H          adds     r0,r1,r0
.  1036   040CH  04679H          mov      r1,pc
.  1038   040EH  022B8H          movs     r2,#184
.  1040   0410H  05081H          str      r1,[r0,r2]
      exc[cid].errorRec.currentRegs.sp := SYSTEM.REG(SP);
.  1042   0412H  09801H          ldr      r0,[sp,#4]
.  1044   0414H  02802H          cmp      r0,#2
.  1046   0416H  0D301H          bcc.n    2 -> 1052
.  1048   0418H  0DF01H          svc      1
.  1050  <LineNo: 288>
.  1052   041CH  04960H          ldr      r1,[pc,#384] -> 1440
.  1054   041EH  022C8H          movs     r2,#200
.  1056   0420H  04350H          muls     r0,r2
.  1058   0422H  01808H          adds     r0,r1,r0
.  1060   0424H  04669H          mov      r1,sp
.  1062   0426H  022B0H          movs     r2,#176
.  1064   0428H  05081H          str      r1,[r0,r2]
      exc[cid].errorRec.currentRegs.lr := SYSTEM.REG(LR);
.  1066   042AH  09801H          ldr      r0,[sp,#4]
.  1068   042CH  02802H          cmp      r0,#2
.  1070   042EH  0D301H          bcc.n    2 -> 1076
.  1072   0430H  0DF01H          svc      1
.  1074  <LineNo: 289>
.  1076   0434H  0495AH          ldr      r1,[pc,#360] -> 1440
.  1078   0436H  022C8H          movs     r2,#200
.  1080   0438H  04350H          muls     r0,r2
.  1082   043AH  01808H          adds     r0,r1,r0
.  1084   043CH  04671H          mov      r1,lr
.  1086   043EH  022B4H          movs     r2,#180
.  1088   0440H  05081H          str      r1,[r0,r2]
      SYSTEM.EMIT(MCU.MRS_R11_XPSR);
.  1090   0442H  0F3EF8B03H      .word 0x8B03F3EF /* EMIT */
      exc[cid].errorRec.currentRegs.xpsr := SYSTEM.REG(11);
.  1094   0446H  09801H          ldr      r0,[sp,#4]
.  1096   0448H  02802H          cmp      r0,#2
.  1098   044AH  0D301H          bcc.n    2 -> 1104
.  1100   044CH  0DF01H          svc      1
.  1102  <LineNo: 291>
.  1104   0450H  04953H          ldr      r1,[pc,#332] -> 1440
.  1106   0452H  022C8H          movs     r2,#200
.  1108   0454H  04350H          muls     r0,r2
.  1110   0456H  01808H          adds     r0,r1,r0
.  1112   0458H  04659H          mov      r1,r11
.  1114   045AH  022BCH          movs     r2,#188
.  1116   045CH  05081H          str      r1,[r0,r2]
    END;
    exc[cid].errorRec.core := cid;
.  1118   045EH  09801H          ldr      r0,[sp,#4]
.  1120   0460H  02802H          cmp      r0,#2
.  1122   0462H  0D301H          bcc.n    2 -> 1128
.  1124   0464H  0DF01H          svc      1
.  1126  <LineNo: 293>
.  1128   0468H  0494DH          ldr      r1,[pc,#308] -> 1440
.  1130   046AH  022C8H          movs     r2,#200
.  1132   046CH  04350H          muls     r0,r2
.  1134   046EH  01808H          adds     r0,r1,r0
.  1136   0470H  09901H          ldr      r1,[sp,#4]
.  1138   0472H  06441H          str      r1,[r0,#68]
    stackFrameAddr := stackFrameBase(SYSTEM.REG(SP) + 12, SYSTEM.REG(LR)); (* SP: + 12 for lr, stackFrameAddr, cid *)
.  1140   0474H  04668H          mov      r0,sp
.  1142   0476H  0300CH          adds     r0,#12
.  1144   0478H  04671H          mov      r1,lr
.  1146   047AH  0F7FFFF95H      bl.w     -214 -> 936
.  1150   047EH  0E000H          b        0 -> 1154
.  1152  <LineNo: 294>
.  1154   0482H  09000H          str      r0,[sp]
    IF exc[cid].stackedRegsOn THEN
.  1156   0484H  09801H          ldr      r0,[sp,#4]
.  1158   0486H  02802H          cmp      r0,#2
.  1160   0488H  0D301H          bcc.n    2 -> 1166
.  1162   048AH  0DF01H          svc      1
.  1164  <LineNo: 295>
.  1166   048EH  04944H          ldr      r1,[pc,#272] -> 1440
.  1168   0490H  022C8H          movs     r2,#200
.  1170   0492H  04350H          muls     r0,r2
.  1172   0494H  01808H          adds     r0,r1,r0
.  1174   0496H  021C6H          movs     r1,#198
.  1176   0498H  05C40H          ldrb     r0,[r0,r1]
.  1178   049AH  02101H          movs     r1,#1
.  1180   049CH  04208H          tst      r0,r1
.  1182   049EH  0D101H          bne.n    2 -> 1188
.  1184   04A0H  0E012H          b        36 -> 1224
.  1186   04A2H  046C0H          nop
      readRegs(stackFrameAddr, exc[cid].errorRec.stackedRegs)
.  1188   04A4H  09800H          ldr      r0,[sp]
.  1190   04A6H  09901H          ldr      r1,[sp,#4]
.  1192   04A8H  02902H          cmp      r1,#2
.  1194   04AAH  0D301H          bcc.n    2 -> 1200
.  1196   04ACH  0DF01H          svc      1
.  1198  <LineNo: 296>
.  1200   04B0H  04A3BH          ldr      r2,[pc,#236] -> 1440
.  1202   04B2H  023C8H          movs     r3,#200
.  1204   04B4H  04359H          muls     r1,r3
.  1206   04B6H  01851H          adds     r1,r2,r1
.  1208   04B8H  0318CH          adds     r1,#140
.  1210   04BAH  04A35H          ldr      r2,[pc,#212] -> 1424
.  1212   04BCH  0467BH          mov      r3,pc
.  1214   04BEH  018D2H          adds     r2,r2,r3
    END;
.  1216   04C0H  0F7FFFF32H      bl.w     -412 -> 808
.  1220   04C4H  0E000H          b        0 -> 1224
.  1222  <LineNo: 296>
    extractError(stackFrameAddr, exc[cid].errorRec);
.  1224   04C8H  09800H          ldr      r0,[sp]
.  1226   04CAH  09901H          ldr      r1,[sp,#4]
.  1228   04CCH  02902H          cmp      r1,#2
.  1230   04CEH  0D301H          bcc.n    2 -> 1236
.  1232   04D0H  0DF01H          svc      1
.  1234  <LineNo: 298>
.  1236   04D4H  04A32H          ldr      r2,[pc,#200] -> 1440
.  1238   04D6H  023C8H          movs     r3,#200
.  1240   04D8H  04359H          muls     r1,r3
.  1242   04DAH  01851H          adds     r1,r2,r1
.  1244   04DCH  03140H          adds     r1,#64
.  1246   04DEH  04A2DH          ldr      r2,[pc,#180] -> 1428
.  1248   04E0H  0467BH          mov      r3,pc
.  1250   04E2H  018D2H          adds     r2,r2,r3
.  1252   04E4H  0F7FFFEE6H      bl.w     -564 -> 692
.  1256   04E8H  0E000H          b        0 -> 1260
.  1258  <LineNo: 298>
    IF exc[cid].stackTraceOn THEN
.  1260   04ECH  09801H          ldr      r0,[sp,#4]
.  1262   04EEH  02802H          cmp      r0,#2
.  1264   04F0H  0D301H          bcc.n    2 -> 1270
.  1266   04F2H  0DF01H          svc      1
.  1268  <LineNo: 299>
.  1270   04F6H  0492AH          ldr      r1,[pc,#168] -> 1440
.  1272   04F8H  022C8H          movs     r2,#200
.  1274   04FAH  04350H          muls     r0,r2
.  1276   04FCH  01808H          adds     r0,r1,r0
.  1278   04FEH  021C5H          movs     r1,#197
.  1280   0500H  05C40H          ldrb     r0,[r0,r1]
.  1282   0502H  02101H          movs     r1,#1
.  1284   0504H  04208H          tst      r0,r1
.  1286   0506H  0D101H          bne.n    2 -> 1292
.  1288   0508H  0E016H          b        44 -> 1336
.  1290   050AH  046C0H          nop
      Stacktrace(traceStart(stackFrameAddr), exc[cid].errorRec.trace)
.  1292   050CH  09800H          ldr      r0,[sp]
.  1294   050EH  0F7FFFF39H      bl.w     -398 -> 900
.  1298   0512H  0E000H          b        0 -> 1302
.  1300  <LineNo: 300>
.  1302   0516H  09901H          ldr      r1,[sp,#4]
.  1304   0518H  02902H          cmp      r1,#2
.  1306   051AH  0D301H          bcc.n    2 -> 1312
.  1308   051CH  0DF01H          svc      1
.  1310  <LineNo: 300>
.  1312   0520H  04A1FH          ldr      r2,[pc,#124] -> 1440
.  1314   0522H  023C8H          movs     r3,#200
.  1316   0524H  04359H          muls     r1,r3
.  1318   0526H  01851H          adds     r1,r2,r1
.  1320   0528H  03148H          adds     r1,#72
.  1322   052AH  04A1BH          ldr      r2,[pc,#108] -> 1432
.  1324   052CH  0467BH          mov      r3,pc
.  1326   052EH  018D2H          adds     r2,r2,r3
    END;
.  1328   0530H  0F7FFFE66H      bl.w     -820 -> 512
.  1332   0534H  0E000H          b        0 -> 1336
.  1334  <LineNo: 300>
    exc[cid].handleException(cid, exc[cid].errorRec);
.  1336   0538H  09801H          ldr      r0,[sp,#4]
.  1338   053AH  02802H          cmp      r0,#2
.  1340   053CH  0D301H          bcc.n    2 -> 1346
.  1342   053EH  0DF01H          svc      1
.  1344  <LineNo: 302>
.  1346   0542H  04917H          ldr      r1,[pc,#92] -> 1440
.  1348   0544H  022C8H          movs     r2,#200
.  1350   0546H  04350H          muls     r0,r2
.  1352   0548H  01808H          adds     r0,r1,r0
.  1354   054AH  021C0H          movs     r1,#192
.  1356   054CH  05840H          ldr      r0,[r0,r1]
.  1358   054EH  0B401H          push     { r0 }
.  1360   0550H  09802H          ldr      r0,[sp,#8]
.  1362   0552H  09902H          ldr      r1,[sp,#8]
.  1364   0554H  02902H          cmp      r1,#2
.  1366   0556H  0D301H          bcc.n    2 -> 1372
.  1368   0558H  0DF01H          svc      1
.  1370  <LineNo: 302>
.  1372   055CH  04A10H          ldr      r2,[pc,#64] -> 1440
.  1374   055EH  023C8H          movs     r3,#200
.  1376   0560H  04359H          muls     r1,r3
.  1378   0562H  01851H          adds     r1,r2,r1
.  1380   0564H  03140H          adds     r1,#64
.  1382   0566H  04A0DH          ldr      r2,[pc,#52] -> 1436
.  1384   0568H  0467BH          mov      r3,pc
.  1386   056AH  018D2H          adds     r2,r2,r3
.  1388   056CH  0BC08H          pop      { r3 }
.  1390   056EH  02B00H          cmp      r3,#0
.  1392   0570H  0D101H          bne.n    2 -> 1398
.  1394   0572H  0DF05H          svc      5
.  1396  <LineNo: 302>
.  1398   0576H  03301H          adds     r3,#1
.  1400   0578H  04798H          blx      r3
.  1402   057AH  0E000H          b        0 -> 1406
.  1404  <LineNo: 301>
    (*ASSERT(FALSE);*)  (* trigger hard fault for testing *)
    HALT(cid)
.  1406   057EH  09801H          ldr      r0,[sp,#4]
  END errorHandler;
.  1408   0580H  0F7FFFD90H      bl.w     -1248 -> 164
.  1412   0584H  0E000H          b        0 -> 1416
.  1414  <LineNo: 304>
.  1416   0588H  0B002H          add      sp,#8
.  1418   058AH  0BD00H          pop      { pc }
.  1420  <Const: 0D0000000H  -805306368>
.  1424  <Const: 0FFFFFB6CH  -1172>
.  1428  <Const: 0FFFFFB98H  -1128>
.  1432  <Const: 0FFFFFAE8H  -1304>
.  1436  <Const: 0FFFFFB10H  -1264>
.  1440  <Global: 001900064H  01900064H>


  PROCEDURE faultHandler;
  (* via MCU hardware-generated exception *)
  (* in main stack *)
    VAR stackFrameAddr, cid: INTEGER;
  BEGIN
.  1444   05A4H  0B500H          push     { lr }
.  1446   05A6H  0B082H          sub      sp,#8
    SYSTEM.GET(MCU.SIO_CPUID, cid);
.  1448   05A8H  04857H          ldr      r0,[pc,#348] -> 1800
.  1450   05AAH  06801H          ldr      r1,[r0]
.  1452   05ACH  09101H          str      r1,[sp,#4]
    IF exc[cid].currentRegsOn THEN
.  1454   05AEH  09801H          ldr      r0,[sp,#4]
.  1456   05B0H  02802H          cmp      r0,#2
.  1458   05B2H  0D301H          bcc.n    2 -> 1464
.  1460   05B4H  0DF01H          svc      1
.  1462  <LineNo: 314>
.  1464   05B8H  04957H          ldr      r1,[pc,#348] -> 1816
.  1466   05BAH  022C8H          movs     r2,#200
.  1468   05BCH  04350H          muls     r0,r2
.  1470   05BEH  01808H          adds     r0,r1,r0
.  1472   05C0H  021C7H          movs     r1,#199
.  1474   05C2H  05C40H          ldrb     r0,[r0,r1]
.  1476   05C4H  02101H          movs     r1,#1
.  1478   05C6H  04208H          tst      r0,r1
.  1480   05C8H  0D101H          bne.n    2 -> 1486
.  1482   05CAH  0E02EH          b        92 -> 1578
.  1484   05CCH  046C0H          nop
      exc[cid].faultRec.currentRegs.pc := SYSTEM.REG(PC);
.  1486   05CEH  09801H          ldr      r0,[sp,#4]
.  1488   05D0H  02802H          cmp      r0,#2
.  1490   05D2H  0D301H          bcc.n    2 -> 1496
.  1492   05D4H  0DF01H          svc      1
.  1494  <LineNo: 315>
.  1496   05D8H  0494FH          ldr      r1,[pc,#316] -> 1816
.  1498   05DAH  022C8H          movs     r2,#200
.  1500   05DCH  04350H          muls     r0,r2
.  1502   05DEH  01808H          adds     r0,r1,r0
.  1504   05E0H  04679H          mov      r1,pc
.  1506   05E2H  06381H          str      r1,[r0,#56]
      exc[cid].faultRec.currentRegs.sp := SYSTEM.REG(SP);
.  1508   05E4H  09801H          ldr      r0,[sp,#4]
.  1510   05E6H  02802H          cmp      r0,#2
.  1512   05E8H  0D301H          bcc.n    2 -> 1518
.  1514   05EAH  0DF01H          svc      1
.  1516  <LineNo: 316>
.  1518   05EEH  0494AH          ldr      r1,[pc,#296] -> 1816
.  1520   05F0H  022C8H          movs     r2,#200
.  1522   05F2H  04350H          muls     r0,r2
.  1524   05F4H  01808H          adds     r0,r1,r0
.  1526   05F6H  04669H          mov      r1,sp
.  1528   05F8H  06301H          str      r1,[r0,#48]
      exc[cid].faultRec.currentRegs.lr := SYSTEM.REG(LR);
.  1530   05FAH  09801H          ldr      r0,[sp,#4]
.  1532   05FCH  02802H          cmp      r0,#2
.  1534   05FEH  0D301H          bcc.n    2 -> 1540
.  1536   0600H  0DF01H          svc      1
.  1538  <LineNo: 317>
.  1540   0604H  04944H          ldr      r1,[pc,#272] -> 1816
.  1542   0606H  022C8H          movs     r2,#200
.  1544   0608H  04350H          muls     r0,r2
.  1546   060AH  01808H          adds     r0,r1,r0
.  1548   060CH  04671H          mov      r1,lr
.  1550   060EH  06341H          str      r1,[r0,#52]
      SYSTEM.EMIT(MCU.MRS_R11_XPSR);
.  1552   0610H  0F3EF8B03H      .word 0x8B03F3EF /* EMIT */
      exc[cid].faultRec.currentRegs.xpsr := SYSTEM.REG(11)
.  1556   0614H  09801H          ldr      r0,[sp,#4]
.  1558   0616H  02802H          cmp      r0,#2
.  1560   0618H  0D301H          bcc.n    2 -> 1566
.  1562   061AH  0DF01H          svc      1
.  1564  <LineNo: 319>
.  1566   061EH  0493EH          ldr      r1,[pc,#248] -> 1816
.  1568   0620H  022C8H          movs     r2,#200
.  1570   0622H  04350H          muls     r0,r2
.  1572   0624H  01808H          adds     r0,r1,r0
    END;
.  1574   0626H  04659H          mov      r1,r11
.  1576   0628H  063C1H          str      r1,[r0,#60]
    exc[cid].faultRec.core := cid;
.  1578   062AH  09801H          ldr      r0,[sp,#4]
.  1580   062CH  02802H          cmp      r0,#2
.  1582   062EH  0D301H          bcc.n    2 -> 1588
.  1584   0630H  0DF01H          svc      1
.  1586  <LineNo: 321>
.  1588   0634H  04938H          ldr      r1,[pc,#224] -> 1816
.  1590   0636H  022C8H          movs     r2,#200
.  1592   0638H  04350H          muls     r0,r2
.  1594   063AH  01808H          adds     r0,r1,r0
.  1596   063CH  09901H          ldr      r1,[sp,#4]
.  1598   063EH  06041H          str      r1,[r0,#4]
    stackFrameAddr := stackFrameBase(SYSTEM.REG(SP) + 12, SYSTEM.REG(LR)); (* SP: + 12 for lr, stackFrameAddr, cid *)
.  1600   0640H  04668H          mov      r0,sp
.  1602   0642H  0300CH          adds     r0,#12
.  1604   0644H  04671H          mov      r1,lr
.  1606   0646H  0F7FFFEAFH      bl.w     -674 -> 936
.  1610   064AH  0E000H          b        0 -> 1614
.  1612  <LineNo: 322>
.  1614   064EH  09000H          str      r0,[sp]
    IF exc[cid].stackedRegsOn THEN
.  1616   0650H  09801H          ldr      r0,[sp,#4]
.  1618   0652H  02802H          cmp      r0,#2
.  1620   0654H  0D301H          bcc.n    2 -> 1626
.  1622   0656H  0DF01H          svc      1
.  1624  <LineNo: 323>
.  1626   065AH  0492FH          ldr      r1,[pc,#188] -> 1816
.  1628   065CH  022C8H          movs     r2,#200
.  1630   065EH  04350H          muls     r0,r2
.  1632   0660H  01808H          adds     r0,r1,r0
.  1634   0662H  021C6H          movs     r1,#198
.  1636   0664H  05C40H          ldrb     r0,[r0,r1]
.  1638   0666H  02101H          movs     r1,#1
.  1640   0668H  04208H          tst      r0,r1
.  1642   066AH  0D101H          bne.n    2 -> 1648
.  1644   066CH  0E012H          b        36 -> 1684
.  1646   066EH  046C0H          nop
      readRegs(stackFrameAddr, exc[cid].faultRec.stackedRegs)
.  1648   0670H  09800H          ldr      r0,[sp]
.  1650   0672H  09901H          ldr      r1,[sp,#4]
.  1652   0674H  02902H          cmp      r1,#2
.  1654   0676H  0D301H          bcc.n    2 -> 1660
.  1656   0678H  0DF01H          svc      1
.  1658  <LineNo: 324>
.  1660   067CH  04A26H          ldr      r2,[pc,#152] -> 1816
.  1662   067EH  023C8H          movs     r3,#200
.  1664   0680H  04359H          muls     r1,r3
.  1666   0682H  01851H          adds     r1,r2,r1
.  1668   0684H  0310CH          adds     r1,#12
.  1670   0686H  04A21H          ldr      r2,[pc,#132] -> 1804
.  1672   0688H  0467BH          mov      r3,pc
.  1674   068AH  018D2H          adds     r2,r2,r3
    END;
.  1676   068CH  0F7FFFE4CH      bl.w     -872 -> 808
.  1680   0690H  0E000H          b        0 -> 1684
.  1682  <LineNo: 324>
    extractFault(stackFrameAddr, exc[cid].faultRec);
.  1684   0694H  09800H          ldr      r0,[sp]
.  1686   0696H  09901H          ldr      r1,[sp,#4]
.  1688   0698H  02902H          cmp      r1,#2
.  1690   069AH  0D301H          bcc.n    2 -> 1696
.  1692   069CH  0DF01H          svc      1
.  1694  <LineNo: 326>
.  1696   06A0H  04A1DH          ldr      r2,[pc,#116] -> 1816
.  1698   06A2H  023C8H          movs     r3,#200
.  1700   06A4H  04359H          muls     r1,r3
.  1702   06A6H  01851H          adds     r1,r2,r1
.  1704   06A8H  04A19H          ldr      r2,[pc,#100] -> 1808
.  1706   06AAH  0467BH          mov      r3,pc
.  1708   06ACH  018D2H          adds     r2,r2,r3
.  1710   06AEH  0F7FFFE2DH      bl.w     -934 -> 780
.  1714   06B2H  0E000H          b        0 -> 1718
.  1716  <LineNo: 326>
    exc[cid].handleException(cid, exc[cid].faultRec);
.  1718   06B6H  09801H          ldr      r0,[sp,#4]
.  1720   06B8H  02802H          cmp      r0,#2
.  1722   06BAH  0D301H          bcc.n    2 -> 1728
.  1724   06BCH  0DF01H          svc      1
.  1726  <LineNo: 327>
.  1728   06C0H  04915H          ldr      r1,[pc,#84] -> 1816
.  1730   06C2H  022C8H          movs     r2,#200
.  1732   06C4H  04350H          muls     r0,r2
.  1734   06C6H  01808H          adds     r0,r1,r0
.  1736   06C8H  021C0H          movs     r1,#192
.  1738   06CAH  05840H          ldr      r0,[r0,r1]
.  1740   06CCH  0B401H          push     { r0 }
.  1742   06CEH  09802H          ldr      r0,[sp,#8]
.  1744   06D0H  09902H          ldr      r1,[sp,#8]
.  1746   06D2H  02902H          cmp      r1,#2
.  1748   06D4H  0D301H          bcc.n    2 -> 1754
.  1750   06D6H  0DF01H          svc      1
.  1752  <LineNo: 327>
.  1754   06DAH  04A0FH          ldr      r2,[pc,#60] -> 1816
.  1756   06DCH  023C8H          movs     r3,#200
.  1758   06DEH  04359H          muls     r1,r3
.  1760   06E0H  01851H          adds     r1,r2,r1
.  1762   06E2H  04A0CH          ldr      r2,[pc,#48] -> 1812
.  1764   06E4H  0467BH          mov      r3,pc
.  1766   06E6H  018D2H          adds     r2,r2,r3
.  1768   06E8H  0BC08H          pop      { r3 }
.  1770   06EAH  02B00H          cmp      r3,#0
.  1772   06ECH  0D101H          bne.n    2 -> 1778
.  1774   06EEH  0DF05H          svc      5
.  1776  <LineNo: 327>
.  1778   06F2H  03301H          adds     r3,#1
.  1780   06F4H  04798H          blx      r3
.  1782   06F6H  0E000H          b        0 -> 1786
.  1784  <LineNo: 326>
    HALT(cid)
.  1786   06FAH  09801H          ldr      r0,[sp,#4]
  END faultHandler;
.  1788   06FCH  0F7FFFCD2H      bl.w     -1628 -> 164
.  1792   0700H  0E000H          b        0 -> 1796
.  1794  <LineNo: 328>
.  1796   0704H  0B002H          add      sp,#8
.  1798   0706H  0BD00H          pop      { pc }
.  1800  <Const: 0D0000000H  -805306368>
.  1804  <Const: 0FFFFF9A0H  -1632>
.  1808  <Const: 0FFFFF9BAH  -1606>
.  1812  <Const: 0FFFFF980H  -1664>
.  1816  <Global: 0019002D0H  019002D0H>


  PROCEDURE* SetHandler*(cpuId: INTEGER; eh: PROCEDURE(cpuId: INTEGER; er: ExceptionRec));
  BEGIN
.  1820   071CH  0B503H          push     { r0, r1, lr }
    exc[cpuId].handleException := eh
.  1822   071EH  09800H          ldr      r0,[sp]
.  1824   0720H  04904H          ldr      r1,[pc,#16] -> 1844
.  1826   0722H  022C8H          movs     r2,#200
.  1828   0724H  04350H          muls     r0,r2
.  1830   0726H  01808H          adds     r0,r1,r0
  END SetHandler;
.  1832   0728H  09901H          ldr      r1,[sp,#4]
.  1834   072AH  022C0H          movs     r2,#192
.  1836   072CH  05081H          str      r1,[r0,r2]
.  1838   072EH  0B002H          add      sp,#8
.  1840   0730H  0BD00H          pop      { pc }
.  1842   0732H  046C0H          nop
.  1844  <Global: 00190038CH  0190038CH>

  PROCEDURE* SetHalt*(cpuId: INTEGER; on: BOOLEAN);
  BEGIN
.  1848   0738H  0B503H          push     { r0, r1, lr }
    exc[cpuId].haltOn := on
.  1850   073AH  09800H          ldr      r0,[sp]
.  1852   073CH  04904H          ldr      r1,[pc,#16] -> 1872
.  1854   073EH  022C8H          movs     r2,#200
.  1856   0740H  04350H          muls     r0,r2
.  1858   0742H  01808H          adds     r0,r1,r0
  END SetHalt;
.  1860   0744H  0A901H          add      r1,sp,#4
.  1862   0746H  07809H          ldrb     r1,[r1]
.  1864   0748H  022C4H          movs     r2,#196
.  1866   074AH  05481H          strb     r1,[r0,r2]
.  1868   074CH  0B002H          add      sp,#8
.  1870   074EH  0BD00H          pop      { pc }
.  1872  <Global: 00190039AH  0190039AH>

  PROCEDURE SetStacktraceOn*(cpuId: INTEGER; on: BOOLEAN);
  BEGIN
.  1876   0754H  0B503H          push     { r0, r1, lr }
    exc[cpuId].stackTraceOn := on
.  1878   0756H  09800H          ldr      r0,[sp]
.  1880   0758H  02802H          cmp      r0,#2
.  1882   075AH  0D301H          bcc.n    2 -> 1888
.  1884   075CH  0DF01H          svc      1
.  1886  <LineNo: 344>
.  1888   0760H  04904H          ldr      r1,[pc,#16] -> 1908
.  1890   0762H  022C8H          movs     r2,#200
.  1892   0764H  04350H          muls     r0,r2
.  1894   0766H  01808H          adds     r0,r1,r0
  END SetStacktraceOn;
.  1896   0768H  0A901H          add      r1,sp,#4
.  1898   076AH  07809H          ldrb     r1,[r1]
.  1900   076CH  022C5H          movs     r2,#197
.  1902   076EH  05481H          strb     r1,[r0,r2]
.  1904   0770H  0B002H          add      sp,#8
.  1906   0772H  0BD00H          pop      { pc }
.  1908  <Global: 0019003A8H  019003A8H>

  PROCEDURE SetStackedRegsOn*(cpuId: INTEGER; on: BOOLEAN);
  BEGIN
.  1912   0778H  0B503H          push     { r0, r1, lr }
    exc[cpuId].stackedRegsOn := on
.  1914   077AH  09800H          ldr      r0,[sp]
.  1916   077CH  02802H          cmp      r0,#2
.  1918   077EH  0D301H          bcc.n    2 -> 1924
.  1920   0780H  0DF01H          svc      1
.  1922  <LineNo: 349>
.  1924   0784H  04904H          ldr      r1,[pc,#16] -> 1944
.  1926   0786H  022C8H          movs     r2,#200
.  1928   0788H  04350H          muls     r0,r2
.  1930   078AH  01808H          adds     r0,r1,r0
  END SetStackedRegsOn;
.  1932   078CH  0A901H          add      r1,sp,#4
.  1934   078EH  07809H          ldrb     r1,[r1]
.  1936   0790H  022C6H          movs     r2,#198
.  1938   0792H  05481H          strb     r1,[r0,r2]
.  1940   0794H  0B002H          add      sp,#8
.  1942   0796H  0BD00H          pop      { pc }
.  1944  <Global: 0019003BAH  019003BAH>

  PROCEDURE SetCurrentRegsOn*(cpuId: INTEGER; on: BOOLEAN);
  BEGIN
.  1948   079CH  0B503H          push     { r0, r1, lr }
    exc[cpuId].currentRegsOn := on
.  1950   079EH  09800H          ldr      r0,[sp]
.  1952   07A0H  02802H          cmp      r0,#2
.  1954   07A2H  0D301H          bcc.n    2 -> 1960
.  1956   07A4H  0DF01H          svc      1
.  1958  <LineNo: 354>
.  1960   07A8H  04904H          ldr      r1,[pc,#16] -> 1980
.  1962   07AAH  022C8H          movs     r2,#200
.  1964   07ACH  04350H          muls     r0,r2
.  1966   07AEH  01808H          adds     r0,r1,r0
  END SetCurrentRegsOn;
.  1968   07B0H  0A901H          add      r1,sp,#4
.  1970   07B2H  07809H          ldrb     r1,[r1]
.  1972   07B4H  022C7H          movs     r2,#199
.  1974   07B6H  05481H          strb     r1,[r0,r2]
.  1976   07B8H  0B002H          add      sp,#8
.  1978   07BAH  0BD00H          pop      { pc }
.  1980  <Global: 0019003CCH  019003CCH>


  PROCEDURE* install(vectAddr: INTEGER; p: PROCEDURE);
  BEGIN
.  1984   07C0H  0B503H          push     { r0, r1, lr }
    INCL(SYSTEM.VAL(SET, p), 0); (* thumb code *)
.  1986   07C2H  09801H          ldr      r0,[sp,#4]
.  1988   07C4H  02101H          movs     r1,#1
.  1990   07C6H  04308H          orrs     r0,r1
.  1992   07C8H  09001H          str      r0,[sp,#4]
    SYSTEM.PUT(vectAddr, p)
  END install;
.  1994   07CAH  09800H          ldr      r0,[sp]
.  1996   07CCH  09901H          ldr      r1,[sp,#4]
.  1998   07CEH  06001H          str      r1,[r0]
.  2000   07D0H  0B002H          add      sp,#8
.  2002   07D2H  0BD00H          pop      { pc }


  PROCEDURE ledOnAndHalt(cid: INTEGER; er: ExceptionRec);
  (* simplistic default handler *)
  BEGIN
.  2004   07D4H  0B507H          push     { r0, r1, r2, lr }
    SYSTEM.PUT(LED.SET, ErrorLed);
.  2006   07D6H  04803H          ldr      r0,[pc,#12] -> 2020
.  2008   07D8H  02119H          movs     r1,#25
.  2010   07DAH  06001H          str      r1,[r0]
    REPEAT UNTIL FALSE (* HALT in any case *)
  END ledOnAndHalt;
.  2012   07DCH  04280H          cmp      r0,r0
.  2014   07DEH  0D0FDH          beq.n    -6 -> 2012
.  2016   07E0H  0B003H          add      sp,#12
.  2018   07E2H  0BD00H          pop      { pc }
.  2020  <Const: 0D0000014H  -805306348>


  PROCEDURE init;
    VAR i, addr, vectorTableBase, vectorTableTop: INTEGER;
  BEGIN
.  2024   07E8H  0B500H          push     { lr }
.  2026   07EAH  0B084H          sub      sp,#16
    i := 0;
.  2028   07ECH  02000H          movs     r0,#0
.  2030   07EEH  09000H          str      r0,[sp]
    WHILE i < NumCores DO
.  2032   07F0H  09800H          ldr      r0,[sp]
.  2034   07F2H  02802H          cmp      r0,#2
.  2036   07F4H  0DB01H          blt.n    2 -> 2042
.  2038   07F6H  0E059H          b        178 -> 2220
.  2040   07F8H  046C0H          nop
      (* mark top of main stack *)
      SYSTEM.PUT(Memory.DataMem[i].stackStart, Memory.DataMem[i].stackStart);
.  2042   07FAH  09800H          ldr      r0,[sp]
.  2044   07FCH  02802H          cmp      r0,#2
.  2046   07FEH  0D301H          bcc.n    2 -> 2052
.  2048   0800H  0DF01H          svc      1
.  2050  <LineNo: 379>
.  2052   0804H  04954H          ldr      r1,[pc,#336] -> 2392
.  2054   0806H  000C0H          lsls     r0,r0,#3
.  2056   0808H  01808H          adds     r0,r1,r0
.  2058   080AH  09900H          ldr      r1,[sp]
.  2060   080CH  02902H          cmp      r1,#2
.  2062   080EH  0D301H          bcc.n    2 -> 2068
.  2064   0810H  0DF01H          svc      1
.  2066  <LineNo: 379>
.  2068   0814H  04A50H          ldr      r2,[pc,#320] -> 2392
.  2070   0816H  000C9H          lsls     r1,r1,#3
.  2072   0818H  01851H          adds     r1,r2,r1
.  2074   081AH  06800H          ldr      r0,[r0]
.  2076   081CH  06809H          ldr      r1,[r1]
.  2078   081EH  06001H          str      r1,[r0]

      (* set VTOR register to SRAM bottom *)
      IF i = 0 THEN
.  2080   0820H  09800H          ldr      r0,[sp]
.  2082   0822H  02800H          cmp      r0,#0
.  2084   0824H  0D001H          beq.n    2 -> 2090
.  2086   0826H  0E004H          b        8 -> 2098
.  2088   0828H  046C0H          nop
        (* VTOR of other cores will be set by core wake-up sequence *)
        SYSTEM.PUT(MCU.SCB_VTOR, Memory.DataMem[0].dataStart)
.  2090   082AH  0484BH          ldr      r0,[pc,#300] -> 2392
      END;
.  2092   082CH  04944H          ldr      r1,[pc,#272] -> 2368
.  2094   082EH  06840H          ldr      r0,[r0,#4]
.  2096   0830H  06008H          str      r0,[r1]

      (* populate vector table *)
      vectorTableBase := Memory.DataMem[i].dataStart;
.  2098   0832H  09800H          ldr      r0,[sp]
.  2100   0834H  02802H          cmp      r0,#2
.  2102   0836H  0D301H          bcc.n    2 -> 2108
.  2104   0838H  0DF01H          svc      1
.  2106  <LineNo: 388>
.  2108   083CH  04946H          ldr      r1,[pc,#280] -> 2392
.  2110   083EH  000C0H          lsls     r0,r0,#3
.  2112   0840H  01808H          adds     r0,r1,r0
.  2114   0842H  06840H          ldr      r0,[r0,#4]
.  2116   0844H  09002H          str      r0,[sp,#8]
      vectorTableTop := vectorTableBase + MCU.VectorTableSize;
.  2118   0846H  09802H          ldr      r0,[sp,#8]
.  2120   0848H  030C0H          adds     r0,#192
.  2122   084AH  09003H          str      r0,[sp,#12]
      install(vectorTableBase + MCU.NMIhandlerOffset, faultHandler);
.  2124   084CH  09802H          ldr      r0,[sp,#8]
.  2126   084EH  03008H          adds     r0,#8
.  2128   0850H  0493CH          ldr      r1,[pc,#240] -> 2372
.  2130   0852H  04479H          add      r1,pc
.  2132   0854H  0F7FFFFB4H      bl.w     -152 -> 1984
.  2136   0858H  0E000H          b        0 -> 2140
.  2138  <LineNo: 390>
      install(vectorTableBase + MCU.HardFaultHandlerOffset, faultHandler);
.  2140   085CH  09802H          ldr      r0,[sp,#8]
.  2142   085EH  0300CH          adds     r0,#12
.  2144   0860H  04939H          ldr      r1,[pc,#228] -> 2376
.  2146   0862H  04479H          add      r1,pc
.  2148   0864H  0F7FFFFACH      bl.w     -168 -> 1984
.  2152   0868H  0E000H          b        0 -> 2156
.  2154  <LineNo: 391>
      install(vectorTableBase + MCU.SVChandlerOffset, errorHandler);
.  2156   086CH  09802H          ldr      r0,[sp,#8]
.  2158   086EH  0302CH          adds     r0,#44
.  2160   0870H  04936H          ldr      r1,[pc,#216] -> 2380
.  2162   0872H  04479H          add      r1,pc
.  2164   0874H  0F7FFFFA4H      bl.w     -184 -> 1984
.  2168   0878H  0E000H          b        0 -> 2172
.  2170  <LineNo: 392>
      addr := vectorTableBase + MCU.MissingHandlerOffset;
.  2172   087CH  09802H          ldr      r0,[sp,#8]
.  2174   087EH  03038H          adds     r0,#56
.  2176   0880H  09001H          str      r0,[sp,#4]
      WHILE addr < vectorTableTop DO
.  2178   0882H  09801H          ldr      r0,[sp,#4]
.  2180   0884H  09903H          ldr      r1,[sp,#12]
.  2182   0886H  04288H          cmp      r0,r1
.  2184   0888H  0DB01H          blt.n    2 -> 2190
.  2186   088AH  0E00BH          b        22 -> 2212
.  2188   088CH  046C0H          nop
        install(addr, faultHandler); INC(addr, 4)
.  2190   088EH  09801H          ldr      r0,[sp,#4]
.  2192   0890H  0492FH          ldr      r1,[pc,#188] -> 2384
.  2194   0892H  04479H          add      r1,pc
.  2196   0894H  0F7FFFF94H      bl.w     -216 -> 1984
.  2200   0898H  0E000H          b        0 -> 2204
.  2202  <LineNo: 395>
      END;
.  2204   089CH  09801H          ldr      r0,[sp,#4]
.  2206   089EH  03004H          adds     r0,#4
.  2208   08A0H  09001H          str      r0,[sp,#4]
.  2210   08A2H  0E7EEH          b        -36 -> 2178
      INC(i)
    END;
.  2212   08A4H  09800H          ldr      r0,[sp]
.  2214   08A6H  03001H          adds     r0,#1
.  2216   08A8H  09000H          str      r0,[sp]
.  2218   08AAH  0E7A1H          b        -190 -> 2032

    (* default options *)
    i := 0;
.  2220   08ACH  02000H          movs     r0,#0
.  2222   08AEH  09000H          str      r0,[sp]
    WHILE i < NumCores DO
.  2224   08B0H  09800H          ldr      r0,[sp]
.  2226   08B2H  02802H          cmp      r0,#2
.  2228   08B4H  0DB01H          blt.n    2 -> 2234
.  2230   08B6H  0E041H          b        130 -> 2364
.  2232   08B8H  046C0H          nop
      exc[i].handleException := ledOnAndHalt;
.  2234   08BAH  09800H          ldr      r0,[sp]
.  2236   08BCH  02802H          cmp      r0,#2
.  2238   08BEH  0D301H          bcc.n    2 -> 2244
.  2240   08C0H  0DF01H          svc      1
.  2242  <LineNo: 403>
.  2244   08C4H  04925H          ldr      r1,[pc,#148] -> 2396
.  2246   08C6H  022C8H          movs     r2,#200
.  2248   08C8H  04350H          muls     r0,r2
.  2250   08CAH  01808H          adds     r0,r1,r0
.  2252   08CCH  04921H          ldr      r1,[pc,#132] -> 2388
.  2254   08CEH  04479H          add      r1,pc
.  2256   08D0H  022C0H          movs     r2,#192
.  2258   08D2H  05081H          str      r1,[r0,r2]
      exc[i].haltOn := TRUE;
.  2260   08D4H  09800H          ldr      r0,[sp]
.  2262   08D6H  02802H          cmp      r0,#2
.  2264   08D8H  0D301H          bcc.n    2 -> 2270
.  2266   08DAH  0DF01H          svc      1
.  2268  <LineNo: 404>
.  2270   08DEH  0491FH          ldr      r1,[pc,#124] -> 2396
.  2272   08E0H  022C8H          movs     r2,#200
.  2274   08E2H  04350H          muls     r0,r2
.  2276   08E4H  01808H          adds     r0,r1,r0
.  2278   08E6H  02101H          movs     r1,#1
.  2280   08E8H  022C4H          movs     r2,#196
.  2282   08EAH  05481H          strb     r1,[r0,r2]
      exc[i].stackedRegsOn := TRUE;
.  2284   08ECH  09800H          ldr      r0,[sp]
.  2286   08EEH  02802H          cmp      r0,#2
.  2288   08F0H  0D301H          bcc.n    2 -> 2294
.  2290   08F2H  0DF01H          svc      1
.  2292  <LineNo: 405>
.  2294   08F6H  04919H          ldr      r1,[pc,#100] -> 2396
.  2296   08F8H  022C8H          movs     r2,#200
.  2298   08FAH  04350H          muls     r0,r2
.  2300   08FCH  01808H          adds     r0,r1,r0
.  2302   08FEH  02101H          movs     r1,#1
.  2304   0900H  022C6H          movs     r2,#198
.  2306   0902H  05481H          strb     r1,[r0,r2]
      exc[i].currentRegsOn := TRUE;
.  2308   0904H  09800H          ldr      r0,[sp]
.  2310   0906H  02802H          cmp      r0,#2
.  2312   0908H  0D301H          bcc.n    2 -> 2318
.  2314   090AH  0DF01H          svc      1
.  2316  <LineNo: 406>
.  2318   090EH  04913H          ldr      r1,[pc,#76] -> 2396
.  2320   0910H  022C8H          movs     r2,#200
.  2322   0912H  04350H          muls     r0,r2
.  2324   0914H  01808H          adds     r0,r1,r0
.  2326   0916H  02101H          movs     r1,#1
.  2328   0918H  022C7H          movs     r2,#199
.  2330   091AH  05481H          strb     r1,[r0,r2]
      exc[i].stackTraceOn := TRUE;
.  2332   091CH  09800H          ldr      r0,[sp]
.  2334   091EH  02802H          cmp      r0,#2
.  2336   0920H  0D301H          bcc.n    2 -> 2342
.  2338   0922H  0DF01H          svc      1
.  2340  <LineNo: 407>
.  2342   0926H  0490DH          ldr      r1,[pc,#52] -> 2396
.  2344   0928H  022C8H          movs     r2,#200
.  2346   092AH  04350H          muls     r0,r2
.  2348   092CH  01808H          adds     r0,r1,r0
.  2350   092EH  02101H          movs     r1,#1
.  2352   0930H  022C5H          movs     r2,#197
.  2354   0932H  05481H          strb     r1,[r0,r2]
      INC(i)
    END;
.  2356   0934H  09800H          ldr      r0,[sp]
.  2358   0936H  03001H          adds     r0,#1
.  2360   0938H  09000H          str      r0,[sp]
.  2362   093AH  0E7B9H          b        -142 -> 2224
  END init;
.  2364   093CH  0B004H          add      sp,#16
.  2366   093EH  0BD00H          pop      { pc }
.  2368  <Const: 0E000ED08H  -536810232>
.  2372  <Const: 0FFFFFD4EH  -690>
.  2376  <Const: 0FFFFFD3EH  -706>
.  2380  <Const: 0FFFFFB5AH  -1190>
.  2384  <Const: 0FFFFFD0EH  -754>
.  2388  <Const: 0FFFFFF02H  -254>
.  2392  <Global: 000020000H  020000H>
.  2396  <Global: 0019003DEH  019003DEH>

BEGIN
.  2400   0960H  0B500H          push     { lr }
  init
END RuntimeErrors.
.  2402   0962H  0F7FFFF41H      bl.w     -382 -> 2024
.  2406   0966H  0E000H          b        0 -> 2410
.  2408  <LineNo: 413>
.  2410   096AH  0BD00H          pop      { pc }
