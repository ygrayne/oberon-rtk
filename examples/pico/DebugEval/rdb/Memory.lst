.     0  <Pad: 0>
MODULE Memory;
(**
  Oberon RTK Framework
  * heap memory allocation for two cores
  * stacks allocation for two cores
  --
  MCU: Cortex-M0+ RP2040, tested on Pico
  --
  Copyright (c) 2023-2024 Gray, gray@grayraven.org
  Portions copyright (c) 2012-2021 CFB Software, https://www.astrobe.com
  Used with permission.
  Please refer to the licensing conditions as defined at the end of this file.
**)

  IMPORT SYSTEM, MCU := MCU2, Config, MAU;

  CONST
    NumCores = Config.NumCores;
    MaxNumProcs = Config.MaxNumProcs;

  TYPE
    CoreHeap = RECORD
      heapLimit: INTEGER;
      heapTop: INTEGER;
    END;
.     4  <Type: 8>
.     8  <Type: 0>
.    12  <Type: 0>
.    16  <Type: 0>
.    20  <Type: 0>

    Stack = RECORD
      addr: INTEGER;
      size: INTEGER
    END;
.    24  <Type: 8>
.    28  <Type: 0>
.    32  <Type: 0>
.    36  <Type: 0>
.    40  <Type: 0>

    CoreStacks = RECORD
      threadStacks: ARRAY MaxNumProcs OF Stack;
      loopStack: Stack;
      stacksBottom, stacksTop: INTEGER;
      stackCheckEnabled: BOOLEAN
    END;
.    44  <Type: 148>
.    48  <Type: 0>
.    52  <Type: 0>
.    56  <Type: 0>
.    60  <Type: 0>

    DataMemory* = RECORD
      stackStart*: INTEGER;
      dataStart*: INTEGER
    END;
.    64  <Type: 8>
.    68  <Type: 0>
.    72  <Type: 0>
.    76  <Type: 0>
.    80  <Type: 0>

    CoreDataMemory* = ARRAY NumCores OF DataMemory;

  VAR
    DataMem*: CoreDataMemory;
    heaps: ARRAY NumCores OF CoreHeap;
    stacks: ARRAY NumCores OF CoreStacks;

  (* === heap memory === *)

  (* --- Astrobe code begin --- *)

  PROCEDURE* Allocate*(VAR p: INTEGER; typeDesc: INTEGER);
  (* from Astrobe library, modified *)
  (* allocate record, prefix with typeDesc field of 1 word with offset -4 *)
    VAR cid, h, size, limit: INTEGER;
  BEGIN
.    84    054H  0B503H          push     { r0, r1, lr }
.    86    056H  0B084H          sub      sp,#16
    SYSTEM.GET(MCU.SIO_CPUID, cid); (* direct, for leaf procedure *)
.    88    058H  04821H          ldr      r0,[pc,#132] -> 224
.    90    05AH  06801H          ldr      r1,[r0]
.    92    05CH  09100H          str      r1,[sp]
    limit := heaps[cid].heapLimit;
.    94    05EH  09800H          ldr      r0,[sp]
.    96    060H  04920H          ldr      r1,[pc,#128] -> 228
.    98    062H  000C0H          lsls     r0,r0,#3
.   100    064H  01808H          adds     r0,r1,r0
.   102    066H  06800H          ldr      r0,[r0]
.   104    068H  09003H          str      r0,[sp,#12]
    IF limit = 0 THEN
.   106    06AH  09803H          ldr      r0,[sp,#12]
.   108    06CH  02800H          cmp      r0,#0
.   110    06EH  0D001H          beq.n    2 -> 116
.   112    070H  0E008H          b        16 -> 132
.   114    072H  046C0H          nop
      limit := stacks[cid].stacksBottom
.   116    074H  09800H          ldr      r0,[sp]
.   118    076H  0491CH          ldr      r1,[pc,#112] -> 232
.   120    078H  02294H          movs     r2,#148
.   122    07AH  04350H          muls     r0,r2
.   124    07CH  01808H          adds     r0,r1,r0
    END;
.   126    07EH  02188H          movs     r1,#136
.   128    080H  05840H          ldr      r0,[r0,r1]
.   130    082H  09003H          str      r0,[sp,#12]
    (* obtain record size from type descriptor, usually in flash *)
    SYSTEM.GET(typeDesc, size);
.   132    084H  09805H          ldr      r0,[sp,#20]
.   134    086H  06801H          ldr      r1,[r0]
.   136    088H  09102H          str      r1,[sp,#8]
    h := heaps[cid].heapTop + 4 + size;
.   138    08AH  09800H          ldr      r0,[sp]
.   140    08CH  04915H          ldr      r1,[pc,#84] -> 228
.   142    08EH  000C0H          lsls     r0,r0,#3
.   144    090H  01808H          adds     r0,r1,r0
.   146    092H  06840H          ldr      r0,[r0,#4]
.   148    094H  03004H          adds     r0,#4
.   150    096H  09902H          ldr      r1,[sp,#8]
.   152    098H  01840H          adds     r0,r0,r1
.   154    09AH  09001H          str      r0,[sp,#4]
    IF h > limit THEN
.   156    09CH  09801H          ldr      r0,[sp,#4]
.   158    09EH  09903H          ldr      r1,[sp,#12]
.   160    0A0H  04288H          cmp      r0,r1
.   162    0A2H  0DC01H          bgt.n    2 -> 168
.   164    0A4H  0E005H          b        10 -> 178
.   166    0A6H  046C0H          nop
      p := 0
    ELSE
.   168    0A8H  02000H          movs     r0,#0
.   170    0AAH  09904H          ldr      r1,[sp,#16]
.   172    0ACH  06008H          str      r0,[r1]
      p := heaps[cid].heapTop + 4;
.   174    0AEH  0E015H          b        42 -> 220
.   176    0B0H  046C0H          nop
.   178    0B2H  09800H          ldr      r0,[sp]
.   180    0B4H  0490BH          ldr      r1,[pc,#44] -> 228
.   182    0B6H  000C0H          lsls     r0,r0,#3
.   184    0B8H  01808H          adds     r0,r1,r0
.   186    0BAH  06840H          ldr      r0,[r0,#4]
.   188    0BCH  03004H          adds     r0,#4
.   190    0BEH  09904H          ldr      r1,[sp,#16]
.   192    0C0H  06008H          str      r0,[r1]
      (* address of type descriptor to tagfield of new record *)
      SYSTEM.PUT(heaps[cid].heapTop, typeDesc);
.   194    0C2H  09800H          ldr      r0,[sp]
.   196    0C4H  04907H          ldr      r1,[pc,#28] -> 228
.   198    0C6H  000C0H          lsls     r0,r0,#3
.   200    0C8H  01808H          adds     r0,r1,r0
.   202    0CAH  06840H          ldr      r0,[r0,#4]
.   204    0CCH  09905H          ldr      r1,[sp,#20]
.   206    0CEH  06001H          str      r1,[r0]
      heaps[cid].heapTop := h
.   208    0D0H  09800H          ldr      r0,[sp]
.   210    0D2H  04904H          ldr      r1,[pc,#16] -> 228
.   212    0D4H  000C0H          lsls     r0,r0,#3
.   214    0D6H  01808H          adds     r0,r1,r0
    END;
.   216    0D8H  09901H          ldr      r1,[sp,#4]
.   218    0DAH  06041H          str      r1,[r0,#4]
  END Allocate;
.   220    0DCH  0B006H          add      sp,#24
.   222    0DEH  0BD00H          pop      { pc }
.   224  <Const: 0D0000000H  -805306368>
.   228  <Global: 000200000H  0200000H>
.   232  <Global: 001480072H  01480072H>


  PROCEDURE Deallocate*(VAR p: INTEGER; typeDesc: INTEGER);
  (* from Astrobe Library, modified *)
  (* Assign NIL = 0 to the pointer 'p'. Reclaim the space if this was the most
     recent allocation, otherwise do nothing. *)
    VAR cid, h, size: INTEGER;
  BEGIN
.   236    0ECH  0B503H          push     { r0, r1, lr }
.   238    0EEH  0B083H          sub      sp,#12
    ASSERT(p # 0, 12);
.   240    0F0H  09803H          ldr      r0,[sp,#12]
.   242    0F2H  06800H          ldr      r0,[r0]
.   244    0F4H  02800H          cmp      r0,#0
.   246    0F6H  0D101H          bne.n    2 -> 252
.   248    0F8H  0DF0CH          svc      12
.   250  <LineNo: 85>
    SYSTEM.GET(MCU.SIO_CPUID, cid); (* direct, for leaf procedure *)
.   252    0FCH  04814H          ldr      r0,[pc,#80] -> 336
.   254    0FEH  06801H          ldr      r1,[r0]
.   256   0100H  09100H          str      r1,[sp]
    (* obtain record size from type descriptor, usually in flash *)
    SYSTEM.GET(typeDesc, size);
.   258   0102H  09804H          ldr      r0,[sp,#16]
.   260   0104H  06801H          ldr      r1,[r0]
.   262   0106H  09102H          str      r1,[sp,#8]
    h := heaps[cid].heapTop - size;
.   264   0108H  09800H          ldr      r0,[sp]
.   266   010AH  02802H          cmp      r0,#2
.   268   010CH  0D301H          bcc.n    2 -> 274
.   270   010EH  0DF01H          svc      1
.   272  <LineNo: 89>
.   274   0112H  04910H          ldr      r1,[pc,#64] -> 340
.   276   0114H  000C0H          lsls     r0,r0,#3
.   278   0116H  01808H          adds     r0,r1,r0
.   280   0118H  06840H          ldr      r0,[r0,#4]
.   282   011AH  09902H          ldr      r1,[sp,#8]
.   284   011CH  01A40H          subs     r0,r0,r1
.   286   011EH  09001H          str      r0,[sp,#4]
    IF h = p THEN heaps[cid].heapTop := h - 4 END;
.   288   0120H  09801H          ldr      r0,[sp,#4]
.   290   0122H  09903H          ldr      r1,[sp,#12]
.   292   0124H  06809H          ldr      r1,[r1]
.   294   0126H  04288H          cmp      r0,r1
.   296   0128H  0D001H          beq.n    2 -> 302
.   298   012AH  0E00BH          b        22 -> 324
.   300   012CH  046C0H          nop
.   302   012EH  09800H          ldr      r0,[sp]
.   304   0130H  02802H          cmp      r0,#2
.   306   0132H  0D301H          bcc.n    2 -> 312
.   308   0134H  0DF01H          svc      1
.   310  <LineNo: 90>
.   312   0138H  04906H          ldr      r1,[pc,#24] -> 340
.   314   013AH  000C0H          lsls     r0,r0,#3
.   316   013CH  01808H          adds     r0,r1,r0
.   318   013EH  09901H          ldr      r1,[sp,#4]
.   320   0140H  03904H          subs     r1,#4
.   322   0142H  06041H          str      r1,[r0,#4]
    p := 0
  END Deallocate;
.   324   0144H  02000H          movs     r0,#0
.   326   0146H  09903H          ldr      r1,[sp,#12]
.   328   0148H  06008H          str      r0,[r1]
.   330   014AH  0B005H          add      sp,#20
.   332   014CH  0BD00H          pop      { pc }
.   334   014EH  046C0H          nop
.   336  <Const: 0D0000000H  -805306368>
.   340  <Global: 000200074H  0200074H>

  (* --- Astrobe code end --- *)

  PROCEDURE LockHeaps*;
    CONST Core0 = 0; Core1 = 1;
  BEGIN
.   344   0158H  0B500H          push     { lr }
    heaps[Core0].heapLimit := heaps[Core0].heapTop;
.   346   015AH  04804H          ldr      r0,[pc,#16] -> 364
.   348   015CH  04903H          ldr      r1,[pc,#12] -> 364
.   350   015EH  06849H          ldr      r1,[r1,#4]
.   352   0160H  06001H          str      r1,[r0]
    heaps[Core1].heapLimit := heaps[Core1].heapTop
.   354   0162H  04802H          ldr      r0,[pc,#8] -> 364
.   356   0164H  04901H          ldr      r1,[pc,#4] -> 364
  END LockHeaps;
.   358   0166H  068C9H          ldr      r1,[r1,#12]
.   360   0168H  06081H          str      r1,[r0,#8]
.   362   016AH  0BD00H          pop      { pc }
.   364  <Global: 0002000AAH  02000AAH>

  (* === thread & loop stacks === *)

  PROCEDURE initStackCheck(addr, limit: INTEGER);
  BEGIN
.   368   0170H  0B503H          push     { r0, r1, lr }
    WHILE addr < limit DO
.   370   0172H  09800H          ldr      r0,[sp]
.   372   0174H  09901H          ldr      r1,[sp,#4]
.   374   0176H  04288H          cmp      r0,r1
.   376   0178H  0DB01H          blt.n    2 -> 382
.   378   017AH  0E008H          b        16 -> 398
.   380   017CH  046C0H          nop
      SYSTEM.PUT(addr, addr + 3);
.   382   017EH  09800H          ldr      r0,[sp]
.   384   0180H  03003H          adds     r0,#3
.   386   0182H  09900H          ldr      r1,[sp]
.   388   0184H  06008H          str      r0,[r1]
      INC(addr, 4)
    END
.   390   0186H  09800H          ldr      r0,[sp]
.   392   0188H  03004H          adds     r0,#4
.   394   018AH  09000H          str      r0,[sp]
.   396   018CH  0E7F1H          b        -30 -> 370
  END initStackCheck;
.   398   018EH  0B002H          add      sp,#8
.   400   0190H  0BD00H          pop      { pc }
.   402   0192H  046C0H          nop


  PROCEDURE checkStackUsage(addr, limit: INTEGER; VAR unused: INTEGER);
    VAR value: INTEGER;
  BEGIN
.   404   0194H  0B507H          push     { r0, r1, r2, lr }
.   406   0196H  0B081H          sub      sp,#4
    SYSTEM.GET(addr, value);
.   408   0198H  09801H          ldr      r0,[sp,#4]
.   410   019AH  06801H          ldr      r1,[r0]
.   412   019CH  09100H          str      r1,[sp]
    unused := 0;
.   414   019EH  02000H          movs     r0,#0
.   416   01A0H  09903H          ldr      r1,[sp,#12]
.   418   01A2H  06008H          str      r0,[r1]
    WHILE (value = addr + 3) & (addr < limit) DO
.   420   01A4H  09801H          ldr      r0,[sp,#4]
.   422   01A6H  03003H          adds     r0,#3
.   424   01A8H  09900H          ldr      r1,[sp]
.   426   01AAH  04281H          cmp      r1,r0
.   428   01ACH  0D001H          beq.n    2 -> 434
.   430   01AEH  0E011H          b        34 -> 468
.   432   01B0H  046C0H          nop
.   434   01B2H  09801H          ldr      r0,[sp,#4]
.   436   01B4H  09902H          ldr      r1,[sp,#8]
.   438   01B6H  04288H          cmp      r0,r1
.   440   01B8H  0DB01H          blt.n    2 -> 446
.   442   01BAH  0E00BH          b        22 -> 468
.   444   01BCH  046C0H          nop
      INC(addr, 4); INC(unused, 4);
.   446   01BEH  09801H          ldr      r0,[sp,#4]
.   448   01C0H  03004H          adds     r0,#4
.   450   01C2H  09001H          str      r0,[sp,#4]
.   452   01C4H  09803H          ldr      r0,[sp,#12]
.   454   01C6H  06801H          ldr      r1,[r0]
.   456   01C8H  03104H          adds     r1,#4
.   458   01CAH  06001H          str      r1,[r0]
      SYSTEM.GET(addr, value)
    END
.   460   01CCH  09801H          ldr      r0,[sp,#4]
.   462   01CEH  06801H          ldr      r1,[r0]
.   464   01D0H  09100H          str      r1,[sp]
.   466   01D2H  0E7E7H          b        -50 -> 420
  END checkStackUsage;
.   468   01D4H  0B004H          add      sp,#16
.   470   01D6H  0BD00H          pop      { pc }

  PROCEDURE CheckLoopStackUsage*(VAR size, used: INTEGER);
    VAR cid, addr, limit, unused: INTEGER;
  BEGIN
.   472   01D8H  0B503H          push     { r0, r1, lr }
.   474   01DAH  0B084H          sub      sp,#16
    SYSTEM.GET(MCU.SIO_CPUID, cid);
.   476   01DCH  04817H          ldr      r0,[pc,#92] -> 572
.   478   01DEH  06801H          ldr      r1,[r0]
.   480   01E0H  09100H          str      r1,[sp]
    addr := stacks[cid].loopStack.addr;
.   482   01E2H  09800H          ldr      r0,[sp]
.   484   01E4H  02802H          cmp      r0,#2
.   486   01E6H  0D301H          bcc.n    2 -> 492
.   488   01E8H  0DF01H          svc      1
.   490  <LineNo: 129>
.   492   01ECH  04914H          ldr      r1,[pc,#80] -> 576
.   494   01EEH  02294H          movs     r2,#148
.   496   01F0H  04350H          muls     r0,r2
.   498   01F2H  01808H          adds     r0,r1,r0
.   500   01F4H  02180H          movs     r1,#128
.   502   01F6H  05840H          ldr      r0,[r0,r1]
.   504   01F8H  09001H          str      r0,[sp,#4]
    size := stacks[cid].loopStack.size;
.   506   01FAH  09800H          ldr      r0,[sp]
.   508   01FCH  02802H          cmp      r0,#2
.   510   01FEH  0D301H          bcc.n    2 -> 516
.   512   0200H  0DF01H          svc      1
.   514  <LineNo: 130>
.   516   0204H  0490EH          ldr      r1,[pc,#56] -> 576
.   518   0206H  02294H          movs     r2,#148
.   520   0208H  04350H          muls     r0,r2
.   522   020AH  01808H          adds     r0,r1,r0
.   524   020CH  02184H          movs     r1,#132
.   526   020EH  05840H          ldr      r0,[r0,r1]
.   528   0210H  09904H          ldr      r1,[sp,#16]
.   530   0212H  06008H          str      r0,[r1]
    limit := addr + size;
.   532   0214H  09801H          ldr      r0,[sp,#4]
.   534   0216H  09904H          ldr      r1,[sp,#16]
.   536   0218H  06809H          ldr      r1,[r1]
.   538   021AH  01840H          adds     r0,r0,r1
.   540   021CH  09002H          str      r0,[sp,#8]
    checkStackUsage(addr, limit, unused);
.   542   021EH  09801H          ldr      r0,[sp,#4]
.   544   0220H  09902H          ldr      r1,[sp,#8]
.   546   0222H  0AA03H          add      r2,sp,#12
.   548   0224H  0F7FFFFB6H      bl.w     -148 -> 404
.   552   0228H  0E000H          b        0 -> 556
.   554  <LineNo: 132>
    used := size - unused
  END CheckLoopStackUsage;
.   556   022CH  09804H          ldr      r0,[sp,#16]
.   558   022EH  06800H          ldr      r0,[r0]
.   560   0230H  09903H          ldr      r1,[sp,#12]
.   562   0232H  01A40H          subs     r0,r0,r1
.   564   0234H  09905H          ldr      r1,[sp,#20]
.   566   0236H  06008H          str      r0,[r1]
.   568   0238H  0B006H          add      sp,#24
.   570   023AH  0BD00H          pop      { pc }
.   572  <Const: 0D0000000H  -805306368>
.   576  <Global: 0014800B6H  014800B6H>


  PROCEDURE CheckThreadStackUsage*(id: INTEGER; VAR size, used: INTEGER);
    VAR cid, addr, limit, unused: INTEGER;
  BEGIN
.   580   0244H  0B507H          push     { r0, r1, r2, lr }
.   582   0246H  0B084H          sub      sp,#16
    SYSTEM.GET(MCU.SIO_CPUID, cid);
.   584   0248H  0481DH          ldr      r0,[pc,#116] -> 704
.   586   024AH  06801H          ldr      r1,[r0]
.   588   024CH  09100H          str      r1,[sp]
    addr := stacks[cid].threadStacks[id].addr;
.   590   024EH  09800H          ldr      r0,[sp]
.   592   0250H  02802H          cmp      r0,#2
.   594   0252H  0D301H          bcc.n    2 -> 600
.   596   0254H  0DF01H          svc      1
.   598  <LineNo: 141>
.   600   0258H  0491AH          ldr      r1,[pc,#104] -> 708
.   602   025AH  02294H          movs     r2,#148
.   604   025CH  04350H          muls     r0,r2
.   606   025EH  01808H          adds     r0,r1,r0
.   608   0260H  09904H          ldr      r1,[sp,#16]
.   610   0262H  02910H          cmp      r1,#16
.   612   0264H  0D301H          bcc.n    2 -> 618
.   614   0266H  0DF01H          svc      1
.   616  <LineNo: 141>
.   618   026AH  000C9H          lsls     r1,r1,#3
.   620   026CH  01840H          adds     r0,r0,r1
.   622   026EH  06800H          ldr      r0,[r0]
.   624   0270H  09001H          str      r0,[sp,#4]
    size := stacks[cid].threadStacks[id].size;
.   626   0272H  09800H          ldr      r0,[sp]
.   628   0274H  02802H          cmp      r0,#2
.   630   0276H  0D301H          bcc.n    2 -> 636
.   632   0278H  0DF01H          svc      1
.   634  <LineNo: 142>
.   636   027CH  04911H          ldr      r1,[pc,#68] -> 708
.   638   027EH  02294H          movs     r2,#148
.   640   0280H  04350H          muls     r0,r2
.   642   0282H  01808H          adds     r0,r1,r0
.   644   0284H  09904H          ldr      r1,[sp,#16]
.   646   0286H  02910H          cmp      r1,#16
.   648   0288H  0D301H          bcc.n    2 -> 654
.   650   028AH  0DF01H          svc      1
.   652  <LineNo: 142>
.   654   028EH  000C9H          lsls     r1,r1,#3
.   656   0290H  01840H          adds     r0,r0,r1
.   658   0292H  06840H          ldr      r0,[r0,#4]
.   660   0294H  09905H          ldr      r1,[sp,#20]
.   662   0296H  06008H          str      r0,[r1]
    limit := addr + size;
.   664   0298H  09801H          ldr      r0,[sp,#4]
.   666   029AH  09905H          ldr      r1,[sp,#20]
.   668   029CH  06809H          ldr      r1,[r1]
.   670   029EH  01840H          adds     r0,r0,r1
.   672   02A0H  09002H          str      r0,[sp,#8]
    checkStackUsage(addr, limit, unused);
.   674   02A2H  09801H          ldr      r0,[sp,#4]
.   676   02A4H  09902H          ldr      r1,[sp,#8]
.   678   02A6H  0AA03H          add      r2,sp,#12
.   680   02A8H  0F7FFFF74H      bl.w     -280 -> 404
.   684   02ACH  0E000H          b        0 -> 688
.   686  <LineNo: 144>
    used := size - unused
  END CheckThreadStackUsage;
.   688   02B0H  09805H          ldr      r0,[sp,#20]
.   690   02B2H  06800H          ldr      r0,[r0]
.   692   02B4H  09903H          ldr      r1,[sp,#12]
.   694   02B6H  01A40H          subs     r0,r0,r1
.   696   02B8H  09906H          ldr      r1,[sp,#24]
.   698   02BAH  06008H          str      r0,[r1]
.   700   02BCH  0B007H          add      sp,#28
.   702   02BEH  0BD00H          pop      { pc }
.   704  <Const: 0D0000000H  -805306368>
.   708  <Global: 001480120H  01480120H>


  PROCEDURE allocStack(VAR stkAddr: INTEGER; cid, stkSize: INTEGER);
    VAR limit: INTEGER;
  BEGIN
.   712   02C8H  0B507H          push     { r0, r1, r2, lr }
.   714   02CAH  0B081H          sub      sp,#4
    limit := heaps[cid].heapLimit;
.   716   02CCH  09802H          ldr      r0,[sp,#8]
.   718   02CEH  02802H          cmp      r0,#2
.   720   02D0H  0D301H          bcc.n    2 -> 726
.   722   02D2H  0DF01H          svc      1
.   724  <LineNo: 152>
.   726   02D6H  04924H          ldr      r1,[pc,#144] -> 872
.   728   02D8H  000C0H          lsls     r0,r0,#3
.   730   02DAH  01808H          adds     r0,r1,r0
.   732   02DCH  06800H          ldr      r0,[r0]
.   734   02DEH  09000H          str      r0,[sp]
    IF limit = 0 THEN
.   736   02E0H  09800H          ldr      r0,[sp]
.   738   02E2H  02800H          cmp      r0,#0
.   740   02E4H  0D001H          beq.n    2 -> 746
.   742   02E6H  0E00AH          b        20 -> 766
.   744   02E8H  046C0H          nop
      limit := heaps[cid].heapTop
.   746   02EAH  09802H          ldr      r0,[sp,#8]
.   748   02ECH  02802H          cmp      r0,#2
.   750   02EEH  0D301H          bcc.n    2 -> 756
.   752   02F0H  0DF01H          svc      1
.   754  <LineNo: 154>
.   756   02F4H  0491CH          ldr      r1,[pc,#112] -> 872
.   758   02F6H  000C0H          lsls     r0,r0,#3
.   760   02F8H  01808H          adds     r0,r1,r0
    END;
.   762   02FAH  06840H          ldr      r0,[r0,#4]
.   764   02FCH  09000H          str      r0,[sp]
    IF stacks[cid].stacksBottom - stkSize > limit THEN
.   766   02FEH  09802H          ldr      r0,[sp,#8]
.   768   0300H  02802H          cmp      r0,#2
.   770   0302H  0D301H          bcc.n    2 -> 776
.   772   0304H  0DF01H          svc      1
.   774  <LineNo: 156>
.   776   0308H  04918H          ldr      r1,[pc,#96] -> 876
.   778   030AH  02294H          movs     r2,#148
.   780   030CH  04350H          muls     r0,r2
.   782   030EH  01808H          adds     r0,r1,r0
.   784   0310H  02188H          movs     r1,#136
.   786   0312H  05840H          ldr      r0,[r0,r1]
.   788   0314H  09903H          ldr      r1,[sp,#12]
.   790   0316H  01A40H          subs     r0,r0,r1
.   792   0318H  09900H          ldr      r1,[sp]
.   794   031AH  04288H          cmp      r0,r1
.   796   031CH  0DC01H          bgt.n    2 -> 802
.   798   031EH  0E01DH          b        58 -> 860
.   800   0320H  046C0H          nop
      DEC(stacks[cid].stacksBottom, stkSize);
.   802   0322H  09802H          ldr      r0,[sp,#8]
.   804   0324H  02802H          cmp      r0,#2
.   806   0326H  0D301H          bcc.n    2 -> 812
.   808   0328H  0DF01H          svc      1
.   810  <LineNo: 157>
.   812   032CH  0490FH          ldr      r1,[pc,#60] -> 876
.   814   032EH  02294H          movs     r2,#148
.   816   0330H  04350H          muls     r0,r2
.   818   0332H  01808H          adds     r0,r1,r0
.   820   0334H  09903H          ldr      r1,[sp,#12]
.   822   0336H  03088H          adds     r0,#136
.   824   0338H  06802H          ldr      r2,[r0]
.   826   033AH  01A52H          subs     r2,r2,r1
.   828   033CH  06002H          str      r2,[r0]
      stkAddr := stacks[cid].stacksBottom
.   830   033EH  09802H          ldr      r0,[sp,#8]
.   832   0340H  02802H          cmp      r0,#2
.   834   0342H  0D301H          bcc.n    2 -> 840
.   836   0344H  0DF01H          svc      1
.   838  <LineNo: 158>
.   840   0348H  04908H          ldr      r1,[pc,#32] -> 876
.   842   034AH  02294H          movs     r2,#148
.   844   034CH  04350H          muls     r0,r2
.   846   034EH  01808H          adds     r0,r1,r0
    ELSE
.   848   0350H  02188H          movs     r1,#136
.   850   0352H  05840H          ldr      r0,[r0,r1]
.   852   0354H  09901H          ldr      r1,[sp,#4]
.   854   0356H  06008H          str      r0,[r1]
      stkAddr := 0
.   856   0358H  0E003H          b        6 -> 866
.   858   035AH  046C0H          nop
    END
.   860   035CH  02000H          movs     r0,#0
.   862   035EH  09901H          ldr      r1,[sp,#4]
.   864   0360H  06008H          str      r0,[r1]
  END allocStack;
.   866   0362H  0B004H          add      sp,#16
.   868   0364H  0BD00H          pop      { pc }
.   870   0366H  046C0H          nop
.   872  <Global: 000200162H  0200162H>
.   876  <Global: 0014801B4H  014801B4H>


  PROCEDURE AllocThreadStack*(VAR stkAddr: INTEGER; id, stkSize: INTEGER);
    VAR cid: INTEGER;
  BEGIN
.   880   0370H  0B507H          push     { r0, r1, r2, lr }
.   882   0372H  0B081H          sub      sp,#4
    SYSTEM.GET(MCU.SIO_CPUID, cid);
.   884   0374H  04828H          ldr      r0,[pc,#160] -> 1048
.   886   0376H  06801H          ldr      r1,[r0]
.   888   0378H  09100H          str      r1,[sp]
    allocStack(stkAddr, cid, stkSize);
.   890   037AH  09801H          ldr      r0,[sp,#4]
.   892   037CH  09900H          ldr      r1,[sp]
.   894   037EH  09A03H          ldr      r2,[sp,#12]
.   896   0380H  0F7FFFFA2H      bl.w     -188 -> 712
.   900   0384H  0E000H          b        0 -> 904
.   902  <LineNo: 169>
    IF stkAddr # 0 THEN
.   904   0388H  09801H          ldr      r0,[sp,#4]
.   906   038AH  06800H          ldr      r0,[r0]
.   908   038CH  02800H          cmp      r0,#0
.   910   038EH  0D101H          bne.n    2 -> 916
.   912   0390H  0E03FH          b        126 -> 1042
.   914   0392H  046C0H          nop
      stacks[cid].threadStacks[id].addr := stkAddr;
.   916   0394H  09800H          ldr      r0,[sp]
.   918   0396H  02802H          cmp      r0,#2
.   920   0398H  0D301H          bcc.n    2 -> 926
.   922   039AH  0DF01H          svc      1
.   924  <LineNo: 171>
.   926   039EH  0491FH          ldr      r1,[pc,#124] -> 1052
.   928   03A0H  02294H          movs     r2,#148
.   930   03A2H  04350H          muls     r0,r2
.   932   03A4H  01808H          adds     r0,r1,r0
.   934   03A6H  09902H          ldr      r1,[sp,#8]
.   936   03A8H  02910H          cmp      r1,#16
.   938   03AAH  0D301H          bcc.n    2 -> 944
.   940   03ACH  0DF01H          svc      1
.   942  <LineNo: 171>
.   944   03B0H  000C9H          lsls     r1,r1,#3
.   946   03B2H  01840H          adds     r0,r0,r1
.   948   03B4H  09901H          ldr      r1,[sp,#4]
.   950   03B6H  06809H          ldr      r1,[r1]
.   952   03B8H  06001H          str      r1,[r0]
      stacks[cid].threadStacks[id].size := stkSize;
.   954   03BAH  09800H          ldr      r0,[sp]
.   956   03BCH  02802H          cmp      r0,#2
.   958   03BEH  0D301H          bcc.n    2 -> 964
.   960   03C0H  0DF01H          svc      1
.   962  <LineNo: 172>
.   964   03C4H  04915H          ldr      r1,[pc,#84] -> 1052
.   966   03C6H  02294H          movs     r2,#148
.   968   03C8H  04350H          muls     r0,r2
.   970   03CAH  01808H          adds     r0,r1,r0
.   972   03CCH  09902H          ldr      r1,[sp,#8]
.   974   03CEH  02910H          cmp      r1,#16
.   976   03D0H  0D301H          bcc.n    2 -> 982
.   978   03D2H  0DF01H          svc      1
.   980  <LineNo: 172>
.   982   03D6H  000C9H          lsls     r1,r1,#3
.   984   03D8H  01840H          adds     r0,r0,r1
.   986   03DAH  09903H          ldr      r1,[sp,#12]
.   988   03DCH  06041H          str      r1,[r0,#4]
      IF stacks[cid].stackCheckEnabled THEN
.   990   03DEH  09800H          ldr      r0,[sp]
.   992   03E0H  02802H          cmp      r0,#2
.   994   03E2H  0D301H          bcc.n    2 -> 1000
.   996   03E4H  0DF01H          svc      1
.   998  <LineNo: 173>
.  1000   03E8H  0490CH          ldr      r1,[pc,#48] -> 1052
.  1002   03EAH  02294H          movs     r2,#148
.  1004   03ECH  04350H          muls     r0,r2
.  1006   03EEH  01808H          adds     r0,r1,r0
.  1008   03F0H  02190H          movs     r1,#144
.  1010   03F2H  05C40H          ldrb     r0,[r0,r1]
.  1012   03F4H  02101H          movs     r1,#1
.  1014   03F6H  04208H          tst      r0,r1
.  1016   03F8H  0D101H          bne.n    2 -> 1022
.  1018   03FAH  0E00AH          b        20 -> 1042
.  1020   03FCH  046C0H          nop
        initStackCheck(stkAddr, stkAddr + stkSize)
.  1022   03FEH  09801H          ldr      r0,[sp,#4]
.  1024   0400H  06800H          ldr      r0,[r0]
.  1026   0402H  09901H          ldr      r1,[sp,#4]
.  1028   0404H  06809H          ldr      r1,[r1]
.  1030   0406H  09A03H          ldr      r2,[sp,#12]
.  1032   0408H  01889H          adds     r1,r1,r2
      END
.  1034   040AH  0F7FFFEB1H      bl.w     -670 -> 368
.  1038   040EH  0E000H          b        0 -> 1042
.  1040  <LineNo: 174>
    END
  END AllocThreadStack;
.  1042   0412H  0B004H          add      sp,#16
.  1044   0414H  0BD00H          pop      { pc }
.  1046   0416H  046C0H          nop
.  1048  <Const: 0D0000000H  -805306368>
.  1052  <Global: 0014801B6H  014801B6H>


  PROCEDURE AllocLoopStack*(VAR stkAddr: INTEGER; stkSize: INTEGER);
    VAR cid: INTEGER;
  BEGIN
.  1056   0420H  0B503H          push     { r0, r1, lr }
.  1058   0422H  0B081H          sub      sp,#4
    SYSTEM.GET(MCU.SIO_CPUID, cid);
.  1060   0424H  04822H          ldr      r0,[pc,#136] -> 1200
.  1062   0426H  06801H          ldr      r1,[r0]
.  1064   0428H  09100H          str      r1,[sp]
    allocStack(stkAddr, cid, stkSize);
.  1066   042AH  09801H          ldr      r0,[sp,#4]
.  1068   042CH  09900H          ldr      r1,[sp]
.  1070   042EH  09A02H          ldr      r2,[sp,#8]
.  1072   0430H  0F7FFFF4AH      bl.w     -364 -> 712
.  1076   0434H  0E000H          b        0 -> 1080
.  1078  <LineNo: 184>
    IF stkAddr # 0 THEN
.  1080   0438H  09801H          ldr      r0,[sp,#4]
.  1082   043AH  06800H          ldr      r0,[r0]
.  1084   043CH  02800H          cmp      r0,#0
.  1086   043EH  0D101H          bne.n    2 -> 1092
.  1088   0440H  0E033H          b        102 -> 1194
.  1090   0442H  046C0H          nop
      stacks[cid].loopStack.addr := stkAddr;
.  1092   0444H  09800H          ldr      r0,[sp]
.  1094   0446H  02802H          cmp      r0,#2
.  1096   0448H  0D301H          bcc.n    2 -> 1102
.  1098   044AH  0DF01H          svc      1
.  1100  <LineNo: 186>
.  1102   044EH  04919H          ldr      r1,[pc,#100] -> 1204
.  1104   0450H  02294H          movs     r2,#148
.  1106   0452H  04350H          muls     r0,r2
.  1108   0454H  01808H          adds     r0,r1,r0
.  1110   0456H  09901H          ldr      r1,[sp,#4]
.  1112   0458H  06809H          ldr      r1,[r1]
.  1114   045AH  02280H          movs     r2,#128
.  1116   045CH  05081H          str      r1,[r0,r2]
      stacks[cid].loopStack.size := stkSize;
.  1118   045EH  09800H          ldr      r0,[sp]
.  1120   0460H  02802H          cmp      r0,#2
.  1122   0462H  0D301H          bcc.n    2 -> 1128
.  1124   0464H  0DF01H          svc      1
.  1126  <LineNo: 187>
.  1128   0468H  04912H          ldr      r1,[pc,#72] -> 1204
.  1130   046AH  02294H          movs     r2,#148
.  1132   046CH  04350H          muls     r0,r2
.  1134   046EH  01808H          adds     r0,r1,r0
.  1136   0470H  09902H          ldr      r1,[sp,#8]
.  1138   0472H  02284H          movs     r2,#132
.  1140   0474H  05081H          str      r1,[r0,r2]
      IF stacks[cid].stackCheckEnabled THEN
.  1142   0476H  09800H          ldr      r0,[sp]
.  1144   0478H  02802H          cmp      r0,#2
.  1146   047AH  0D301H          bcc.n    2 -> 1152
.  1148   047CH  0DF01H          svc      1
.  1150  <LineNo: 188>
.  1152   0480H  0490CH          ldr      r1,[pc,#48] -> 1204
.  1154   0482H  02294H          movs     r2,#148
.  1156   0484H  04350H          muls     r0,r2
.  1158   0486H  01808H          adds     r0,r1,r0
.  1160   0488H  02190H          movs     r1,#144
.  1162   048AH  05C40H          ldrb     r0,[r0,r1]
.  1164   048CH  02101H          movs     r1,#1
.  1166   048EH  04208H          tst      r0,r1
.  1168   0490H  0D101H          bne.n    2 -> 1174
.  1170   0492H  0E00AH          b        20 -> 1194
.  1172   0494H  046C0H          nop
        initStackCheck(stkAddr, stkAddr + stkSize)
.  1174   0496H  09801H          ldr      r0,[sp,#4]
.  1176   0498H  06800H          ldr      r0,[r0]
.  1178   049AH  09901H          ldr      r1,[sp,#4]
.  1180   049CH  06809H          ldr      r1,[r1]
.  1182   049EH  09A02H          ldr      r2,[sp,#8]
.  1184   04A0H  01889H          adds     r1,r1,r2
      END
.  1186   04A2H  0F7FFFE65H      bl.w     -822 -> 368
.  1190   04A6H  0E000H          b        0 -> 1194
.  1192  <LineNo: 189>
    END
  END AllocLoopStack;
.  1194   04AAH  0B003H          add      sp,#12
.  1196   04ACH  0BD00H          pop      { pc }
.  1198   04AEH  046C0H          nop
.  1200  <Const: 0D0000000H  -805306368>
.  1204  <Global: 00148020EH  0148020EH>


  PROCEDURE EnableStackCheck*(on: BOOLEAN);
    VAR cid: INTEGER;
  BEGIN
.  1208   04B8H  0B501H          push     { r0, lr }
.  1210   04BAH  0B081H          sub      sp,#4
    SYSTEM.GET(MCU.SIO_CPUID, cid);
.  1212   04BCH  04808H          ldr      r0,[pc,#32] -> 1248
.  1214   04BEH  06801H          ldr      r1,[r0]
.  1216   04C0H  09100H          str      r1,[sp]
    stacks[cid].stackCheckEnabled := on
.  1218   04C2H  09800H          ldr      r0,[sp]
.  1220   04C4H  02802H          cmp      r0,#2
.  1222   04C6H  0D301H          bcc.n    2 -> 1228
.  1224   04C8H  0DF01H          svc      1
.  1226  <LineNo: 199>
.  1228   04CCH  04905H          ldr      r1,[pc,#20] -> 1252
.  1230   04CEH  02294H          movs     r2,#148
.  1232   04D0H  04350H          muls     r0,r2
.  1234   04D2H  01808H          adds     r0,r1,r0
  END EnableStackCheck;
.  1236   04D4H  0A901H          add      r1,sp,#4
.  1238   04D6H  07809H          ldrb     r1,[r1]
.  1240   04D8H  02290H          movs     r2,#144
.  1242   04DAH  05481H          strb     r1,[r0,r2]
.  1244   04DCH  0B002H          add      sp,#8
.  1246   04DEH  0BD00H          pop      { pc }
.  1248  <Const: 0D0000000H  -805306368>
.  1252  <Global: 00148025AH  0148025AH>


  PROCEDURE ResetMainStack*(cid, numAddr: INTEGER);
  (* to do: also reset main stack pointer to top *)
  (* clear out the main stack from kernel loop to get clean stack traces *)
    VAR i, addr: INTEGER;
  BEGIN
.  1256   04E8H  0B503H          push     { r0, r1, lr }
.  1258   04EAH  0B082H          sub      sp,#8
    addr := DataMem[cid].stackStart - 4;
.  1260   04ECH  09802H          ldr      r0,[sp,#8]
.  1262   04EEH  02802H          cmp      r0,#2
.  1264   04F0H  0D301H          bcc.n    2 -> 1270
.  1266   04F2H  0DF01H          svc      1
.  1268  <LineNo: 208>
.  1270   04F6H  0490DH          ldr      r1,[pc,#52] -> 1324
.  1272   04F8H  000C0H          lsls     r0,r0,#3
.  1274   04FAH  01808H          adds     r0,r1,r0
.  1276   04FCH  06800H          ldr      r0,[r0]
.  1278   04FEH  03804H          subs     r0,#4
.  1280   0500H  09001H          str      r0,[sp,#4]
    i := 0;
.  1282   0502H  02000H          movs     r0,#0
.  1284   0504H  09000H          str      r0,[sp]
    WHILE i < numAddr DO
.  1286   0506H  09800H          ldr      r0,[sp]
.  1288   0508H  09903H          ldr      r1,[sp,#12]
.  1290   050AH  04288H          cmp      r0,r1
.  1292   050CH  0DB01H          blt.n    2 -> 1298
.  1294   050EH  0E00AH          b        20 -> 1318
.  1296   0510H  046C0H          nop
      SYSTEM.PUT(addr, 0);
.  1298   0512H  09801H          ldr      r0,[sp,#4]
.  1300   0514H  02100H          movs     r1,#0
.  1302   0516H  06001H          str      r1,[r0]
      INC(i); DEC(addr, 4)
.  1304   0518H  09800H          ldr      r0,[sp]
.  1306   051AH  03001H          adds     r0,#1
.  1308   051CH  09000H          str      r0,[sp]
    END
.  1310   051EH  09801H          ldr      r0,[sp,#4]
.  1312   0520H  03804H          subs     r0,#4
.  1314   0522H  09001H          str      r0,[sp,#4]
.  1316   0524H  0E7EFH          b        -34 -> 1286
  END ResetMainStack;
.  1318   0526H  0B004H          add      sp,#16
.  1320   0528H  0BD00H          pop      { pc }
.  1322   052AH  046C0H          nop
.  1324  <Global: 000100272H  0100272H>

  (* === init === *)

  PROCEDURE init;
    CONST Core0 = 0; Core1 = 1;
  BEGIN
.  1328   0530H  0B500H          push     { lr }
    MAU.SetNew(Allocate); MAU.SetDispose(Deallocate);
.  1330   0532H  046C0H          nop
.  1332   0534H  04829H          ldr      r0,[pc,#164] -> 1500
.  1334   0536H  04478H          add      r0,pc
.  1336   0538H  004030000H      bl.w     Ext Proc #3
.  1340   053CH  0E000H          b        0 -> 1344
.  1342  <LineNo: 221>
.  1344   0540H  04827H          ldr      r0,[pc,#156] -> 1504
.  1346   0542H  04478H          add      r0,pc
.  1348   0544H  00404029CH      bl.w     Ext Proc #4
.  1352   0548H  0E000H          b        0 -> 1356
.  1354  <LineNo: 221>

    (* exported info *)
    DataMem[Core0].stackStart := Config.CoreZeroStackStart;
.  1356   054CH  0482DH          ldr      r0,[pc,#180] -> 1540
.  1358   054EH  04929H          ldr      r1,[pc,#164] -> 1524
.  1360   0550H  06809H          ldr      r1,[r1]
.  1362   0552H  06001H          str      r1,[r0]
    DataMem[Core0].dataStart := Config.CoreZeroDataStart;
.  1364   0554H  0482BH          ldr      r0,[pc,#172] -> 1540
.  1366   0556H  04928H          ldr      r1,[pc,#160] -> 1528
.  1368   0558H  06809H          ldr      r1,[r1]
.  1370   055AH  06041H          str      r1,[r0,#4]
    DataMem[Core1].stackStart := Config.CoreOneStackStart;
.  1372   055CH  04829H          ldr      r0,[pc,#164] -> 1540
.  1374   055EH  04921H          ldr      r1,[pc,#132] -> 1508
.  1376   0560H  06081H          str      r1,[r0,#8]
    DataMem[Core1].dataStart := Config.CoreOneDataStart;
.  1378   0562H  04828H          ldr      r0,[pc,#160] -> 1540
.  1380   0564H  04920H          ldr      r1,[pc,#128] -> 1512
.  1382   0566H  060C1H          str      r1,[r0,#12]

    (* heaps *)
    heaps[Core0].heapTop := Config.CoreZeroHeapStart;
.  1384   0568H  04827H          ldr      r0,[pc,#156] -> 1544
.  1386   056AH  04924H          ldr      r1,[pc,#144] -> 1532
.  1388   056CH  06809H          ldr      r1,[r1]
.  1390   056EH  06041H          str      r1,[r0,#4]
    heaps[Core0].heapLimit := Config.CoreZeroHeapLimit;
.  1392   0570H  04825H          ldr      r0,[pc,#148] -> 1544
.  1394   0572H  04923H          ldr      r1,[pc,#140] -> 1536
.  1396   0574H  06809H          ldr      r1,[r1]
.  1398   0576H  06001H          str      r1,[r0]
    heaps[Core1].heapTop := Config.CoreOneHeapStart;
.  1400   0578H  04823H          ldr      r0,[pc,#140] -> 1544
.  1402   057AH  0491CH          ldr      r1,[pc,#112] -> 1516
.  1404   057CH  060C1H          str      r1,[r0,#12]
    heaps[Core1].heapLimit := Config.CoreOneHeapLimit;
.  1406   057EH  04822H          ldr      r0,[pc,#136] -> 1544
.  1408   0580H  02100H          movs     r1,#0
.  1410   0582H  06081H          str      r1,[r0,#8]

    (* thread & loop stacks *)
    stacks[Core0].stacksBottom := Config.CoreZeroStackStart - Config.CoreZeroMainStackSize;
.  1412   0584H  04821H          ldr      r0,[pc,#132] -> 1548
.  1414   0586H  0491BH          ldr      r1,[pc,#108] -> 1524
.  1416   0588H  06809H          ldr      r1,[r1]
.  1418   058AH  02201H          movs     r2,#1
.  1420   058CH  00292H          lsls     r2,r2,#10
.  1422   058EH  01A89H          subs     r1,r1,r2
.  1424   0590H  02288H          movs     r2,#136
.  1426   0592H  05081H          str      r1,[r0,r2]
    stacks[Core0].stacksTop := Config.CoreZeroStackStart;
.  1428   0594H  0481DH          ldr      r0,[pc,#116] -> 1548
.  1430   0596H  04917H          ldr      r1,[pc,#92] -> 1524
.  1432   0598H  06809H          ldr      r1,[r1]
.  1434   059AH  0228CH          movs     r2,#140
.  1436   059CH  05081H          str      r1,[r0,r2]
    stacks[Core0].stackCheckEnabled := FALSE;
.  1438   059EH  0481BH          ldr      r0,[pc,#108] -> 1548
.  1440   05A0H  02100H          movs     r1,#0
.  1442   05A2H  02290H          movs     r2,#144
.  1444   05A4H  05481H          strb     r1,[r0,r2]
    stacks[Core1].stacksBottom := Config.CoreOneStackStart - Config.CoreOneMainStackSize;
.  1446   05A6H  04819H          ldr      r0,[pc,#100] -> 1548
.  1448   05A8H  04911H          ldr      r1,[pc,#68] -> 1520
.  1450   05AAH  02247H          movs     r2,#71
.  1452   05ACH  00092H          lsls     r2,r2,#2
.  1454   05AEH  05081H          str      r1,[r0,r2]
    stacks[Core1].stacksTop := Config.CoreOneStackStart;
.  1456   05B0H  04816H          ldr      r0,[pc,#88] -> 1548
.  1458   05B2H  0490CH          ldr      r1,[pc,#48] -> 1508
.  1460   05B4H  02209H          movs     r2,#9
.  1462   05B6H  00152H          lsls     r2,r2,#5
.  1464   05B8H  05081H          str      r1,[r0,r2]
    stacks[Core1].stackCheckEnabled := FALSE;
.  1466   05BAH  04814H          ldr      r0,[pc,#80] -> 1548
.  1468   05BCH  02100H          movs     r1,#0
.  1470   05BEH  02249H          movs     r2,#73
.  1472   05C0H  00092H          lsls     r2,r2,#2
.  1474   05C2H  05481H          strb     r1,[r0,r2]

    (* init main stacks for stack trace: mark top *)
    SYSTEM.PUT(DataMem[Core0].stackStart, DataMem[Core0].stackStart);
.  1476   05C4H  0480FH          ldr      r0,[pc,#60] -> 1540
.  1478   05C6H  0490FH          ldr      r1,[pc,#60] -> 1540
.  1480   05C8H  06800H          ldr      r0,[r0]
.  1482   05CAH  06809H          ldr      r1,[r1]
.  1484   05CCH  06001H          str      r1,[r0]
    SYSTEM.PUT(DataMem[Core1].stackStart, DataMem[Core1].stackStart)
.  1486   05CEH  0480DH          ldr      r0,[pc,#52] -> 1540
.  1488   05D0H  0490CH          ldr      r1,[pc,#48] -> 1540
  END init;
.  1490   05D2H  06880H          ldr      r0,[r0,#8]
.  1492   05D4H  06889H          ldr      r1,[r1,#8]
.  1494   05D6H  06001H          str      r1,[r0]
.  1496   05D8H  0BD00H          pop      { pc }
.  1498   05DAH  046C0H          nop
.  1500  <Const: 0FFFFFB1AH  -1254>
.  1504  <Const: 0FFFFFBA6H  -1114>
.  1508  <Const: 02003FFFCH  02003FFFCH>
.  1512  <Const: 020030000H  020030000H>
.  1516  <Const: 020030200H  020030200H>
.  1520  <Const: 02003FBFCH  02003FBFCH>
.  1524  <Global: 000020000H  020000H>
.  1528  <Global: 0000102FAH  0102FAH>
.  1532  <Global: 0000302FCH  0302FCH>
.  1536  <Global: 0000402FEH  0402FEH>
.  1540  <Global: 000100296H  0100296H>
.  1544  <Global: 000200302H  0200302H>
.  1548  <Global: 001480304H  01480304H>

BEGIN
.  1552   0610H  0B500H          push     { lr }
  init
END Memory.
.  1554   0612H  0F7FFFF8DH      bl.w     -230 -> 1328
.  1558   0616H  0E000H          b        0 -> 1562
.  1560  <LineNo: 249>
.  1562   061AH  0BD00H          pop      { pc }
